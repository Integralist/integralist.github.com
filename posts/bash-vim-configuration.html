<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, minimal-ui">
        <title>Bash, Vim and Tmux Configuration</title>
        <link rel="stylesheet" href="../styles/github-markdown.css">
        <link rel="stylesheet" href="../styles/prism-default.css">
        <style>
            body {
                min-width: 200px;
                max-width: 790px;
                margin: 0 auto;
                padding: 30px;
            }

            pre[class*="language-"] {
              border: 1px dashed #AAA;
              margin-bottom: 1em;
            }
        </style>
    </head>
    <body>
        <article class="markdown-body">

<h1>Bash, Vim and Tmux Configuration</h1>

<ul>
<li><a href="#1">Introduction</a></li>
<li><a href="#2">Bash</a></li>
<li><a href="#9">Vim</a></li>
<li><a href="#10">Tmux</a></li>
</ul>

<div id="1"></div>

<h2>Introduction</h2>

<p>One of the key components to a happy development workflow is to ensure your tools work hard for you, are efficient and also fun to use (although sadly that latter point is sorely underappreciated as a deciding factor into what tools you choose). </p>

<p>This is where configuring your own setup to suit your individual needs becomes essential.</p>

<p>Now although you and I may differ as to what we like, there will inevitably be some common tools and solutions that we&#39;ll use and build upon. So what I present here today are are my tools. My configuration and enhancements of those core tools and what I feel to be &#39;good enough&#39; to suit my needs.</p>

<p>Feel free to take whatever you like and leave the rest.</p>

<p>So what will I be covering? Good question, the running order of things will be: </p>

<ul>
<li>Bash</li>
<li>Vim</li>
<li>Tmux</li>
</ul>

<p>I&#39;ll be going over my terminal/shell configurations, as well as my current Vim and tmux setup. So let&#39;s get started...</p>

<blockquote>
<p>Note: it shouldn&#39;t matter too much, but I&#39;m running Mac OS X</p>
</blockquote>

<div id="2"></div>

<h2>Bash</h2>

<p>The reason for using Bash over another shell, such as <a href="http://www.zsh.org/">Zsh</a> (which I used to use), is primarily its ubiquitousness. I find that whenever I&#39;m writing shell scripts I&#39;ll end up using a feature that isn&#39;t supported in Bash. </p>

<p>Obviously this is fine if you&#39;re writing shell scripts for your own machine, but I sometimes write scripts for other environments (e.g. continuous integration systems) and they will mostly be running Bash only.</p>

<p>The reasons other people prefer shells like Zsh or Fish (or whatever) is that you get additional features much more easily. But as you&#39;ll see shortly, I&#39;ve configured my Bash environment to provide some of these features, and OK maybe sometimes it&#39;s not as slick as other shells; but this is the first - of possibly many - situations where I&#39;m happy with the setup and feel it&#39;s &quot;good enough&quot; to suit my needs, but you might disagree (c&#39;est la vie).</p>

<p>I&#39;ve decided to break this section down into sub parts to make easier to digest:</p>

<ul>
<li><a href="#3">Install terminal theme</a></li>
<li><a href="#4">Install a newer version of Bash</a></li>
<li><a href="#5">Configure <code>~/.bash_profile</code></a></li>
<li><a href="#6">Configure <code>~/.bashrc</code></a></li>
<li><a href="#7">Configure <code>~/.inputrc</code></a></li>
<li><a href="#8">Other dotfiles?</a></li>
</ul>

<div id="3"></div>

<h3>Install terminal theme</h3>

<p>Now although not strictly anything to do with the shell, I thought it was worth mentioning that I have a few different Terminal themes that I use and choose from. You can find a few of those themes here:</p>

<p><a href="https://github.com/Integralist/dotfiles/tree/master/terminal-themes">github.com/integralist/dotfiles</a></p>

<blockquote>
<p>Update: I&#39;m now using my own custom theme <a href="https://github.com/Integralist/mac-os-terminal-theme-integralist">integralist</a></p>
</blockquote>

<p>To install them, download the <code>.terminal</code> file you want and double click on it.</p>

<div id="4"></div>

<h3>Install a newer version of Bash</h3>

<p>I like to install a newer version of Bash via <a href="http://brew.sh/">Homebrew</a>.</p>

<p>For example, execute the following command to see your current Bash version:</p>

<pre><code class="language-bash">/bin/bash --version
</code></pre>

<p>When you do, you&#39;ll likely find Mac OS X comes with a much older version of Bash than you&#39;d expect.</p>

<p>For me I see version <code>3.2.57</code>.</p>

<p>So first things first, I want to install a newer version of Bash:</p>

<pre><code class="language-bash">brew install bash
</code></pre>

<p>Next add the location of this new Bash shell to our system&#39;s list of known shells:</p>

<pre><code class="language-bash">echo /usr/local/bin/bash | sudo tee -a /etc/shells
</code></pre>

<p>Finally, let&#39;s tell our system to permanently change to the new Bash shell:</p>

<pre><code class="language-bash">chsh -s /usr/local/bin/bash
</code></pre>

<p>OK, at this point if you open a new terminal you&#39;ll be using the new Bash shell you&#39;ve downloaded:</p>

<pre><code class="language-bash">bash --version
</code></pre>

<p>You&#39;ll notice I didn&#39;t specify the full path, I just used <code>bash</code> and the terminal was able to locate the new installation. Doing this for me tells me the new version of Bash is <code>4.3.42</code>.</p>

<div id="5"></div>

<h3>Configure <code>~/.bash_profile</code></h3>

<p>In order for the terminal to pick up my actual user configuration for Bash I needed to modify the file <code>~/.bash_profile</code>. The specific change I add to this file is as follows:</p>

<pre><code class="language-bash">#!/usr/bin/env bash

if [ -f &quot;$HOME/.bashrc&quot; ]; then
  source ~/.bashrc
  cd . || exit
fi
</code></pre>

<blockquote>
<p>Note: I use <code>/usr/bin/env</code> to identify my new brew installed version of Bash</p>
</blockquote>

<p>What this code will do is check if there is a <code>~/.bashrc</code> file, and if so &#39;source&#39; it into the currently running shell.</p>

<blockquote>
<p>Note: <code>cd .</code> isn&#39;t necessary, I just like using it<br>
e.g. each new shell will reset the location back to <code>$HOME</code></p>
</blockquote>

<p>One other thing I add to <code>~/.bash_profile</code> is the following snippet of code:</p>

<pre><code class="language-bash">if [ -f &quot;$(brew --prefix)/etc/bash_completion&quot; ]; then
  source &quot;$(brew --prefix)/etc/bash_completion&quot;
fi
</code></pre>

<p>What this does is load an auto completion script (similar to what you&#39;ll find in other shells) so you can type part of a comand, then press <code>&lt;Tab&gt;</code> and have the shell autocomplete the rest of the command for you (as well as other types of autocompletion).</p>

<p>The script itself is provided by Homebrew. Hence you&#39;ll see we tell the script to look inside the Homebrew source directory (e.g. <code>$(brew --prefix)</code>), which typically will be something like <code>/usr/local</code>.</p>

<div id="6"></div>

<h3>Configure <code>~/.bashrc</code></h3>

<p>The <code>~/.bashrc</code> file is the main container of our configuration. It&#39;ll determine things like the appearance of the shell&#39;s prompt, keybindings for moving the cursor around, how we handle the shell&#39;s history and many other things.</p>

<p>I&#39;m going to just leave this whole file here and let the comments speak for themselves, but I encourage you to view the <a href="https://github.com/Integralist/dotfiles/blob/master/.bashrc">current version in my dotfiles repo</a> as it&#39;ll be up to date and include any fixes/tweaks...</p>

<blockquote>
<p>Note: Google is your friend for any Bash voodoo you&#39;re unsure on</p>
</blockquote>

<pre><code class="language-bash">#!/usr/bin/env bash

# https://github.com/git/git/blob/master/contrib/completion/git-prompt.sh
source ~/.git-prompt.sh

# https://github.com/jarun/googler/blob/master/auto-completion/bash/googler-completion.bash
source ~/googler-completion.bash

# https://git.zx2c4.com/password-store/plain/src/completion/pass.bash-completion
source /usr/local/etc/bash_completion.d/password-store

# tells Readline to perform filename completion in a case-insensitive fashion
bind &quot;set completion-ignore-case on&quot;

# filename matching during completion will treat hyphens and underscores as equivalent
bind &quot;set completion-map-case on&quot;

# will get Readline to display all possible matches for an ambiguous pattern at the first &lt;Tab&gt; press instead of at the second
bind &quot;set show-all-if-ambiguous on&quot;

# no bell sound on error
bind &quot;set bell-style none&quot;

# enable emacs like bindings (&lt;C-a&gt; and &lt;C-e&gt; for start and end of line shortcuts)
set -o emacs

# append to the history file, don&#39;t overwrite it
shopt -s histappend

# save multi-line commands as one command
shopt -s cmdhist

# no need to type cd (works for .. but not -, although alias -- -=&#39;cd -&#39; fixes it)
shopt -s autocd 2&gt;/dev/null

# autocorrect minor spelling errors
shopt -s dirspell 2&gt;/dev/null
shopt -s cdspell 2&gt;/dev/null

# check windows size if windows is resized
shopt -s checkwinsize 2&gt;/dev/null

# use extra globing features. See man bash, search extglob.
shopt -s extglob 2&gt;/dev/null

# include .files when globbing.
shopt -s dotglob 2&gt;/dev/null

# case insensitive globbing
shopt -s nocaseglob 2&gt;/dev/null

# can be useful to utilise the gnu style error message format
shopt -s gnu_errfmt 2&gt;/dev/null

# ensure SIGHUP is sent to all jobs when an interactive login shell exits
shopt -s huponexit 2&gt;/dev/null

# specify other paths to look inside of when autocompleting
CDPATH=&quot;.:~/code&quot;

# custom environment variables
export DROPBOX=&quot;$HOME/Dropbox&quot;
export GITHUB_USER=&quot;integralist&quot;

# application configuration
export GOOGLER_COLORS=bjdxxy # https://github.com/jarun/googler/
export LSCOLORS=&quot;dxfxcxdxbxegedabagacad&quot; # http://geoff.greer.fm/lscolors/
export GREP_OPTIONS=&quot;--color=auto&quot;
export GREP_COLOR=&quot;1;32&quot;
export MANPAGER=&quot;less -X&quot; # Don&#39;t clear the screen after quitting a manual page
export GOPATH=$HOME/code/go
export PATH=$HOME/code/go/bin:$HOME/dotvim/voom:/usr/local/sbin:$PATH
export EDITOR=&quot;vim&quot;
export HOMEBREW_NO_ANALYTICS=1
export SSH_PUBLIC_KEY=&quot;$HOME/.ssh/github_rsa.pub&quot;

# git specific configurations
export GIT_PS1_SHOWCOLORHINTS=true
export GIT_PS1_SHOWDIRTYSTATE=true     # * for unstaged changes (+ staged but uncommitted changes)
export GIT_PS1_SHOWSTASHSTATE=true     # $ for stashed changes
export GIT_PS1_SHOWUNTRACKEDFILES=true # % for untracked files
export GIT_PS1_SHOWUPSTREAM=&quot;auto&quot;     # &gt; for local commits on HEAD not pushed to upstream
                                       # &lt; for commits on upstream not merged with HEAD
                                       # = HEAD points to same commit as upstream

# history configuration
history -a # record each line as it gets issued
export HISTSIZE=500000
export HISTFILESIZE=100000
export HISTCONTROL=&quot;erasedups:ignoreboth&quot; # avoid duplicate entries
export HISTIGNORE=&quot;&amp;:[ ]*:exit:ls:bg:fg:history&quot; # don&#39;t record some commands
export HISTTIMEFORMAT=&#39;%F %T &#39; # useful timestamp format

# force colours
export force_color_prompt=yes

# use colour prompt
export color_prompt=yes

# \e indicates escape sequence (sometimes you&#39;ll see \033)
# the m indicates you&#39;ve provided a colour sequence
#
# 30: Black
# 31: Red
# 32: Green
# 33: Yellow
# 34: Blue
# 35: Purple
# 36: Cyan
# 37: White
#
# a semicolon allows additional attributes:
#
# 0: Normal text
# 1: Bold or light, depending on terminal
# 4: Underline text
#
# there are also background colours (put before additional attributes with ; separator):
#
# 40: Black background
# 41: Red background
# 42: Green background
# 43: Yellow background
# 44: Blue background
# 45: Purple background
# 46: Cyan background
# 47: White background

function prompt_right() {
  echo -e &quot;&quot;
}

function prompt_left() {
  num_jobs=$(jobs | wc -l)

  if [ &quot;$num_jobs&quot; -eq 0 ]; then
    num_jobs=&quot;&quot;
  else
    num_jobs=&quot; (\j)&quot;
  fi

  echo -e &quot;\e[33m\]\u. \[\e[37m\]\w\[\e[00m\]$num_jobs\e[31m\]$(__git_ps1)\e[00m\] \e[0;37m(\A)\e[0m&quot;
}

function prompt() {
  compensate=11
  unset PS1
  PS1=$(printf &quot;%*s\r%s\n\$ &quot; &quot;$(($(tput cols)+compensate))&quot; &quot;$(prompt_right)&quot; &quot;$(prompt_left)&quot;)
}

function rubo() {
  docker run \
    --cpu-shares 1024 \
    --rm=true \
    --volume &quot;$(pwd):/app&quot; \
    bbcnews/rubocop-config --format simple --fail-level F | grep &#39;^F:\|==&#39;
}

function toggle_hidden() {
  setting=$(defaults read com.apple.finder AppleShowAllFiles)

  if [ &quot;$setting&quot; == &quot;NO&quot; ]; then
    echo &quot;Enabling hidden files&quot;
    defaults write com.apple.finder AppleShowAllFiles YES
  else
    echo &quot;Disabling hidden files&quot;
    defaults write com.apple.finder AppleShowAllFiles NO
  fi

  killall Finder
}

function gms() {
  git merge --squash &quot;$1&quot;
}

function dash {
  local docs=$1
  local query=$2
  open &quot;dash://$docs:$query&quot;
}

function gc {
  if [ -z &quot;$1&quot; ]; then
    printf &quot;\n\tUse: gc some-existing-branch-name\n&quot;
  else
    git checkout &quot;$1&quot;
  fi
}

function gcb {
  if [ -z &quot;$1&quot; ]; then
    printf &quot;\n\tUse: gcb some-new-branch-name (branch will be created)\n&quot;
  else
    git checkout -b &quot;$1&quot;
  fi
}

# We use _ to indicate an unused variable
# Otherwise shellcheck will kick up a stink
# shellcheck disable=SC2034
read -r -d &#39;&#39; git_icons &lt;&lt;- EOF
* unstaged changes
+ staged but uncommitted changes
$ stashed changes
% untracked files
&gt; local commits on HEAD not pushed to upstream
&lt; commits on upstream not merged with HEAD
= HEAD points to same commit as upstream
EOF

# use `type &lt;alias&gt;` to see what is assigned to an alias/fn/builtin/keyword
alias c=&quot;clear&quot;
alias dotfiles=&quot;ls -a | grep &#39;^\.&#39; | grep --invert-match &#39;\.DS_Store\|\.$&#39;&quot;
alias getcommit=&quot;git log -1 | cut -d &#39; &#39; -f 2 | head -n 1 | pbcopy&quot;
alias sshkey=&quot;ssh-keygen -t rsa -b 4096 -C &#39;mark.mcdx@gmail.com&#39;&quot;
alias irc=&quot;irssi&quot;
alias ls=&quot;ls -GpF&quot;
alias ll=&quot;ls -laGpFHh&quot;
alias r=&quot;source ~/.bashrc&quot;
alias cm=&quot;git checkout master&quot;
alias c-=&quot;git checkout -&quot;
alias gb=&quot;git branch&quot;
alias gbd=&quot;git branch -D&quot;
alias gcp=&quot;git cherry-pick -&quot;
alias gpr=&quot;git pull --rebase origin master&quot;
alias wat=&#39;echo &quot;$git_icons&quot;&#39;
alias wut=&#39;echo &quot;$git_icons&quot;&#39;
alias gitupstream=&quot;echo git branch -u origin/\&lt;branch\&gt;&quot;
alias sshconfig=&#39;nvim -c &quot;norm 12ggVjjjgc&quot; -c &quot;wq&quot; ~/.ssh/config &amp;&amp; cat ~/.ssh/config | awk &quot;/switch/ {for(i=0; i&lt;=3; i++) {getline; print}}&quot;&#39;
alias copy=&quot;tr -d &#39;\n&#39; | pbcopy&quot; # e.g. echo $DEV_CERT_PATH | copy
alias be=&quot;bundle exec&quot;
alias sshvm=&quot;ssh rig.dev&quot;
alias drm=&#39;docker rm $(docker ps -a -q)&#39;
alias drmi=&#39;docker rmi $(docker images -q)&#39;
alias dns=&quot;scutil --dns | grep &#39;nameserver\[[0-9]*\]&#39;&quot;
alias nvimupdate=&quot;brew reinstall --HEAD neovim&quot;
alias pipall=&quot;pip freeze --local | grep -v &#39;^\-e&#39; | cut -d = -f 1  | xargs -n1 pip install -U&quot;
alias uid=&#39;echo $(uuidgen)&#39;
alias datesec=&#39;date +%s&#39;

eval &quot;$(rbenv init -)&quot;
eval &quot;$(pyenv init -)&quot;

# lazyload nvm
# all props goes to http://broken-by.me/lazy-load-nvm/
# grabbed from reddit @ https://www.reddit.com/r/node/comments/4tg5jg/lazy_load_nvm_for_faster_shell_start/

lazynvm() {
  unset -f nvm node npm
  export NVM_DIR=~/.nvm
  [ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR/nvm.sh&quot;  # This loads nvm
}

nvm() {
  lazynvm
  nvm &quot;$@&quot;
}

node() {
  lazynvm
  node &quot;$@&quot;
}

npm() {
  lazynvm
  npm &quot;$@&quot;
}

# Setup File Search AutoComplete (Ctrl-f, type to filter, arrow to look inside folders)
[[ -s &quot;$HOME/.qfc/bin/qfc.sh&quot; ]] &amp;&amp; source &quot;$HOME/.qfc/bin/qfc.sh&quot;

# https://raw.githubusercontent.com/rcaloras/bash-preexec/master/bash-preexec.sh
source ~/.bash-preexec.sh

# preexec executes just BEFORE a command is executed
# preexec() { echo &quot;just typed $1&quot;; }

# precmd executes just AFTER a command is executed, but before the prompt is shown
precmd() { prompt; }
</code></pre>

<p>All things considered, this covers a lot of ground for me. There&#39;s just one other piece I like to utilise...</p>

<div id="7"></div>

<h3>Configure <code>~/.inputrc</code></h3>

<p>In the <code>~/.inputrc</code> file I have two lines of configuration only:</p>

<pre><code class="language-bash">TAB: menu-complete
&quot;\e[Z&quot;: &quot;\e-1\C-i&quot;
</code></pre>

<p>In short, what this gives you is the ability to press <code>&lt;C-n&gt;</code> and <code>&lt;C-p&gt;</code> to tab back and forth through any ambigious autocompletion suggestions that you may be presented with.</p>

<div id="8"></div>

<h3>Other dotfiles?</h3>

<p>My <code>$HOME</code> directory is littered with miscellaneous dotfiles such as:</p>

<ul>
<li><code>.agignore</code></li>
<li><code>.gitignore</code></li>
<li><code>.gitignore_global</code></li>
<li><code>.rspec</code></li>
</ul>

<p>...and many many more (inc dot folders such as <code>.git</code>, <code>.ssh</code> and <code>.irssi</code> etc)</p>

<p>I&#39;m not going to bother to document them all here though.</p>

<div id="9"></div>

<h2>Vim</h2>

<p>I&#39;ve written a book about Vim (<a href="http://www.amazon.co.uk/Pro-Vim-Mark-McDonnell/dp/1484202511/ref=sr_1_1?ie=UTF8&amp;qid=1417554324&amp;sr=8-1&amp;keywords=pro+Vim">Pro Vim</a>). I&#39;ve also written about it on my own site quite a few times so I won&#39;t waste time explaining it to any one. </p>

<p>So I&#39;ll assume you&#39;re already a Vim user and are just interested in my set-up.</p>

<p>One key aspect of using Vim are plugins and so any serious Vim user will need a way to manage their plugins. In my book I cover the in&#39;s and out&#39;s of <a href="https://github.com/tpope/vim-pathogen">Pathogen</a> and since then I moved back to <a href="https://github.com/VundleVim/Vundle.vim">Vundle</a> as I wanted an abstraction to help me better manage my growing list of plugins.</p>

<p>I&#39;ve since now moved over to <a href="https://github.com/airblade/voom">Voom</a> which is a simple Bash script that has a dependency on Pathogen (itself ~300 lines of VimL code). This is, to me at least, a vast improvement on the ~1k lines of VimL for Vundle and I get a simple <code>voom</code> command I can use to install/delete/update my plugins via the use of a plugin manifest file.</p>

<p>Voom utilises a manifest file (<code>~/.vim/plugins</code>) to determine what plugins are installed. Below is the current contents of that file (the configuration for the plugins themselves can be found within the <code>~/.vimrc</code> file, which I&#39;ll show to you shortly):</p>

<pre><code class="language-bash">chriskempson/vim-tomorrow-theme
endel/vim-github-colorscheme
ekalinin/Dockerfile.vim
ervandew/supertab
fatih/vim-go
godlygeek/tabular
guns/vim-clojure-highlight
guns/vim-clojure-static
guns/vim-sexp
kana/vim-textobj-user
kien/ctrlp.vim
kien/rainbow_parentheses.vim
m-kat/aws-vim
mileszs/ack.vim
nelstrom/vim-textobj-rubyblock
othree/html5.vim
plasticboy/vim-markdown
scrooloose/syntastic
sheerun/vim-polyglot
Shougo/unite.vim
Shougo/vimfiler.vim
tpope/vim-commentary
tpope/vim-endwise
tpope/vim-fireplace
tpope/vim-leiningen
tpope/vim-repeat
tpope/vim-sexp-mappings-for-regular-people
tpope/vim-surround
vim-scripts/Gist.vim
vim-scripts/camelcasemotion
</code></pre>

<blockquote>
<p>Note: <code>voom edit</code> will open the file for you</p>
</blockquote>

<p>Right. Let&#39;s now look at getting Vim setup. Below is a break-down of &#39;from nothing, to something&#39;:</p>

<pre><code class="language-bash">mkdir -p ~/.vim/{autoload,bundle}
curl -LSso ~/.vim/autoload/pathogen.vim https://tpo.pe/pathogen.vim
curl -LSso ~/.vim/plugins https://raw.githubusercontent.com/Integralist/dotfiles/master/voom/plugins
curl -LSso /usr/local/bin/voom https://raw.githubusercontent.com/airblade/voom/master/voom
chmod 744 /usr/local/bin/voom
alias voom=&#39;VIM_DIR=~/.vim voom&#39;
curl -LSso ~/.vimrc https://raw.githubusercontent.com/Integralist/dotfiles/master/.vimrc
ln -s ~/.vim ~/.config/nvim
ln -s ~/.vimrc ~/.config/nvim/init.vim
voom
</code></pre>

<p>The above snippet of code creates a <code>.vim</code> directory and then downloads Pathogen into it. We symlink the directory to <code>~/.config/nvim</code> so when we start up NeoVim it&#39;ll actually pick up the <code>~/.vim</code> directory. This means both Vim and NeoVim will work from the same set of files.</p>

<p>You&#39;ll notice that we clone down my <code>.vimrc</code> from GitHub to <code>~/.vimrc</code> and then symlink it to <code>~/.config/nvim/init.vim</code> so again when we start up NeoVim it&#39;ll work just fine. On top of that we&#39;ve installed Voom (our plugin manager) into a place where my <code>$PATH</code> has access to it, and then executed the <code>voom</code> command to start installing the plugins defined in the <code>~/.vim/plugins</code> file.</p>

<p>Note that in order for our plugins to work with Pathogen, we need the following snippet within our <code>~/.vimrc</code>:</p>

<pre><code class="language-bash">execute pathogen#infect()
syntax on
filetype plugin indent on
</code></pre>

<p>This simply sets Pathogen running whenever Vim starts up.</p>

<p>The configuration for all my plugins are placed directly inside my <code>~/.vimrc</code> file (shown below) along with all my other Vim settings. Again, I won&#39;t bother to detail every single item in my <code>~/.vimrc</code>; hopefully the comments will suffice. Otherwise Google anything you&#39;re unsure about:</p>

<blockquote>
<p>Note: again see my <a href="https://github.com/Integralist/dotfiles/blob/master/.vimrc">dotfiles repo for latest version</a></p>
</blockquote>

<pre><code class="language-ini">&quot; Use the system clipboard
set clipboard+=unnamed

&quot; Switch syntax highlighting on
syntax on

&quot; Don&#39;t worry about trying to support old school Vi features
set nocompatible

&quot; Disable Mouse (this is something that only recently affected me within NeoVim)
&quot; Seemed using the mouse to select some text would make NeoVim jump into VISUAL mode?
set mouse=
&quot; No backup files
set nobackup

&quot; No write backup
set nowritebackup

&quot; No swap file
set noswapfile

&quot; Command history
set history=100

&quot; Always show cursor
set ruler

&quot; Show incomplete commands
set showcmd

&quot; Incremental searching (search as you type)
set incsearch

&quot; Highlight search matches
set hlsearch

&quot; Ignore case in search
set smartcase

&quot; Make sure any searches /searchPhrase doesn&#39;t need the \c escape character
set ignorecase

&quot; A buffer is marked as ‘hidden’ if it has unsaved changes, and it is not currently loaded in a window
&quot; If you try and quit Vim while there are hidden buffers, you will raise an error:
&quot; E162: No write since last change for buffer “a.txt”
set hidden

&quot; Turn word wrap off
set nowrap

&quot; Allow backspace to delete end of line, indent and start of line characters
set backspace=indent,eol,start

&quot; Convert tabs to spaces
set expandtab

&quot; Set tab size in spaces (this is for manual indenting)
set tabstop=2

&quot; The number of spaces inserted for a tab (used for auto indenting)
set shiftwidth=2

&quot; Turn on line numbers
set number

&quot; Highlight tailing whitespace
set list listchars=tab:\ \ ,trail:·

&quot; Get rid of the delay when pressing O (for example)
&quot; http://stackoverflow.com/questions/2158516/vim-delay-before-o-opens-a-new-line
set timeout timeoutlen=1000 ttimeoutlen=100

&quot; Always show status bar
set laststatus=2

&quot; Set the status line to something useful
set statusline=%f\ %m\ %=L:%l/%L\ C:%c\ (%p%%)

&quot; UTF encoding
set encoding=utf-8

&quot; Autoload files that have changed outside of vim
set autoread

&quot; Better splits (new windows appear below and to the right)
set splitbelow
set splitright

&quot; Highlight the current line
set cursorline

&quot; Ensure Vim doesn&#39;t beep at you every time you make a mistype
set visualbell

&quot; Visual autocomplete for command menu (e.g. :e ~/path/to/file)
set wildmenu

&quot; Redraw only when we need to (i.e. don&#39;t redraw when executing a macro)
set lazyredraw

&quot; Highlight a matching [{()}] when cursor is placed on start/end character
set showmatch

&quot; &lt;C-x&gt;&lt;C-k&gt; for word autocomplete
set dictionary=/usr/share/dict/words

&quot; Use Ag for :grep command (would use Sift but it doesn&#39;t work well)
set grepprg=ag\ --nogroup\ --nocolor

&quot; Set built-in file system explorer to use layout similar to the NERDTree plugin
&quot; P opens file in previously focused window
&quot; o opens file in new horizontal split window
&quot; v opens file in new vertical split window
&quot; t opens file in new tab split window
let g:netrw_liststyle=3

execute pathogen#infect()
filetype plugin indent on

let g:default_theme=&quot;gruvbox&quot;

set background=dark
execute &#39;colorscheme &#39; . g:default_theme

&quot; http://pep8.readthedocs.io/en/latest/intro.html#error-codes
&quot; https://github.com/PyCQA/pep8-naming
let g:neomake_python_flake8_args = neomake#makers#ft#python#flake8()[&#39;args&#39;] + [&#39;--ignore&#39;, &#39;N802&#39;]

&quot; http://pylint-messages.wikidot.com/all-codes
&quot; http://pylint-messages.wikidot.com/all-messages
let g:neomake_python_pylint_args = neomake#makers#ft#python#pylint()[&#39;args&#39;] + [&#39;-d&#39;, &#39;missing-docstring,invalid-name&#39;]

&quot; Enable both default Python linters
let g:neomake_python_enabled_makers = [&#39;flake8&#39;, &#39;pylint&#39;]

&quot; https://github.com/koalaman/shellcheck/wiki/SC1091
let g:neomake_sh_shellcheck_args = neomake#makers#ft#sh#shellcheck()[&#39;args&#39;] + [&#39;-e&#39;, &#39;SC1090,SC1091&#39;]
let g:neomake_bash_enabled_makers = [&#39;shellcheck&#39;]

let g:neomake_c_enabled_makers = [&#39;clang&#39;]

let g:neomake_js_enabled_makers = [&#39;eslint&#39;]
let g:neomake_js_eslint_args = [&#39;--config&#39;, &#39;~/eslint.config.js&#39;]

&quot; General Neomake configuration
let g:neomake_open_list=2
let g:neomake_list_height=5
let g:neomake_verbose=3

&quot; Run Neomake whenever we enter or write a buffer
autocmd BufWritePost,BufWinEnter * silent Neomake

&quot; The following configuration is useful if you don&#39;t like
&quot; the icons (which are provided by default) for highlighting errors/warnings
&quot;
&quot; let g:neomake_warning_sign = {
&quot;   \ &#39;text&#39;: &#39;W&#39;,
&quot;   \ &#39;texthl&#39;: &#39;WarningMsg&#39;,
&quot;   \ }
&quot; let g:neomake_error_sign = {
&quot;   \ &#39;text&#39;: &#39;E&#39;,
&quot;   \ &#39;texthl&#39;: &#39;ErrorMsg&#39;,
&quot;   \ }

&quot; vim-go
let g:go_fmt_command = &quot;goimports&quot;
let g:go_metalinter_autosave = 1
let g:go_metalinter_autosave_enabled = [&#39;vet&#39;, &#39;golint&#39;]
let g:go_metalinter_enabled = [&#39;vet&#39;, &#39;golint&#39;, &#39;errcheck&#39;]

&quot; tabular
map &lt;Leader&gt;e :Tabularize /=&lt;CR&gt;
map &lt;Leader&gt;c :Tabularize /:&lt;CR&gt;
map &lt;Leader&gt;es :Tabularize /=\zs&lt;CR&gt;
map &lt;Leader&gt;cs :Tabularize /:\zs&lt;CR&gt;

&quot; ctrlp
map &lt;leader&gt;t &lt;C-p&gt;
map &lt;leader&gt;y :CtrlPBuffer&lt;CR&gt;
let g:ctrlp_show_hidden=1
let g:ctrlp_working_path_mode=0
let g:ctrlp_max_height=30
let g:ctrlp_arg_map = 1 &quot; Override &lt;C-o&gt; to provide options for how to open files
set wildignore+=*/.git/*,*/.hg/*,*/.svn/*.,*/.DS_Store &quot; Files matched are ignored when expanding wildcards
let g:ctrlp_user_command = &#39;ag %s -l --nocolor -g &quot;&quot;&#39; &quot; Use Ag for searching instead of VimScript (might not work with ctrlp_show_hidden and ctrlp_custom_ignore)
let g:ctrlp_custom_ignore = &#39;\v[\/]((node_modules)|\.(git|svn|grunt|sass-cache))$&#39; &quot; Directories to ignore when fuzzy finding

&quot; ack
let g:ackprg = &#39;ag --nogroup --nocolor --column&#39;

&quot; vim-textobj-rubyblock
runtime macros/matchit.vim

&quot; vim-commentary
xmap &lt;leader&gt;&lt;leader&gt;&lt;leader&gt; &lt;Plug&gt;Commentary
nmap &lt;leader&gt;&lt;leader&gt;&lt;leader&gt; &lt;Plug&gt;Commentary
omap &lt;leader&gt;&lt;leader&gt;&lt;leader&gt; &lt;Plug&gt;Commentary
nmap &lt;leader&gt;&lt;leader&gt;&lt;leader&gt; &lt;Plug&gt;CommentaryLine

&quot; gist
let g:github_user = $GITHUB_USER
let g:gist_detect_filetype = 1
let g:gist_open_browser_after_post = 1

&quot; camelcase
map &lt;silent&gt; w &lt;Plug&gt;CamelCaseMotion_w
map &lt;silent&gt; b &lt;Plug&gt;CamelCaseMotion_b
map &lt;silent&gt; e &lt;Plug&gt;CamelCaseMotion_e
sunmap w
sunmap b
sunmap e

&quot; nofrils
let g:nofrils_strbackgrounds=1 &quot; enable highlighting of strings and mispellings

&quot; NeoVim shortcut for quick terminal exit
:silent! tnoremap &lt;Esc&gt; &lt;C-\&gt;&lt;C-n&gt;

&quot; Allow substitutions to dynamically be represented in the buffer
&quot; https://asciinema.org/a/92207
:silent! set inccommand=nosplit

fun! StripTrailingWhitespace()
  &quot; Don&#39;t strip on these filetypes
  if &amp;ft =~ &#39;markdown&#39;
    return
  endif
  %s/\s\+$//e
endfun
autocmd BufWritePre * call StripTrailingWhitespace()

autocmd FileType gitcommit setlocal spell textwidth=72
autocmd FileType markdown setlocal wrap linebreak nolist textwidth=0 wrapmargin=0 &quot; http://vim.wikia.com/wiki/Word_wrap_without_line_breaks
autocmd FileType sh,cucumber,ruby,yaml,zsh,vim setlocal shiftwidth=2 tabstop=2 expandtab
autocmd FileType php,python setlocal shiftwidth=4 tabstop=4 expandtab

&quot; See `:h fo-table` for details of formatoptions `t` to force wrapping of text
autocmd FileType python,ruby,go,sh,javascript setlocal textwidth=79 formatoptions+=t

&quot; Set different colorscheme for Bash and VimL scripts
autocmd BufEnter *.sh,*.vimrc,*.txt colorscheme github
autocmd BufLeave *.sh,*.vimrc,*.txt execute &#39;set background=dark&#39; | execute &#39;colorscheme &#39; . g:default_theme

&quot; Specify syntax highlighting for specific files
autocmd Bufread,BufNewFile *.spv set filetype=php
autocmd Bufread,BufNewFile *.md set filetype=markdown &quot; Vim interprets .md as &#39;modula2&#39; otherwise, see :set filetype?

&quot; Run Goyo plugin on Markdown files for when I&#39;m writing blog posts
autocmd Bufread,BufEnter *.md,*.txt execute &#39;normal zR&#39; | execute &#39;Goyo&#39;
autocmd BufLeave *.md,*.txt execute &#39;Goyo!&#39;

&quot; Automatically reload vimrc when it&#39;s saved
&quot; autocmd BufWritePost .vimrc so ~/.vimrc

&quot; Rainbow parenthesis always on!
autocmd VimEnter * if exists(&#39;:RainbowParenthesesToggle&#39;) | exe &quot;:RainbowParenthesesToggleAll&quot; | endif

&quot; Change colourscheme when diffing
fun! SetDiffColours()
  highlight DiffAdd    cterm=bold ctermfg=white ctermbg=DarkGreen
  highlight DiffDelete cterm=bold ctermfg=white ctermbg=DarkGrey
  highlight DiffChange cterm=bold ctermfg=white ctermbg=DarkBlue
  highlight DiffText   cterm=bold ctermfg=white ctermbg=DarkRed
endfun
autocmd FilterWritePre * call SetDiffColours()

&quot; Map § key to :nohlsearch (or :noh for short)
map § :nohlsearch&lt;CR&gt;
</code></pre>

<div id="10"></div>

<h2>Tmux</h2>

<p>As far as tmux is concerned, my <code>~/.tmux.conf</code> is relatively short/concise compared to my other configuration files and to other config files I&#39;ve seen shared online. </p>

<p>I no longer bother to style the tmux panel, I prefer minimalism nowadays. This means my tmux settings generally revolve around key binding abstractions (although some minor tweaks here and there).</p>

<p>So one last time, just to repeat myself, I don&#39;t go into detail as to what these configurations mean; if the comments don&#39;t give you the answer you need, then a cursory Google should reveal all you need:</p>

<pre><code class="language-bash"># Remap prefix
unbind C-b
set -g prefix C-Space

# Quick key for moving back to the previous window
bind-key L last-window

# Vim style bindings for pane movement
bind-key -r h select-pane -L
bind-key -r j select-pane -D
bind-key -r k select-pane -U
bind-key -r l select-pane -R

# Fix issue with tmux repeating -r the arrow directions (meaning when you switch panes you can accidentally jump back to the other pane again)
bind-key Up    select-pane -U
bind-key Down  select-pane -D
bind-key Left  select-pane -L
bind-key Right select-pane -R

# Make resizing panes easier
bind-key &lt; resize-pane -L 5
bind-key &gt; resize-pane -R 5
bind-key + resize-pane -U 5
bind-key - resize-pane -D 5
bind-key = select-layout even-vertical
bind-key | select-layout even-horizontal

# Reload tmux config
bind-key r source-file ~/.tmux.conf

# Ensure terminal starts with its own colour scheme (helps Vim/Neovim themes to not break)
set -g default-terminal &quot;screen-256color&quot;

# Enable UTF8 support
set-window-option -g utf8 on

# Use Vi style key bindings to move around copy mode
setw -g mode-keys vi

# Make sure messages (using display-message) are displayed for long enough to read
set-option -g display-time 2000

# Remove delay when pressing esc in Vim
set -sg escape-time 0

# Fix issue with copying from within a tmux session and wanting to paste outside of it
set -g default-command &quot;reattach-to-user-namespace -l &#39;/bin/zsh&#39;&quot;

# Setup `v` and `y` operators to start and yank selections (like Vim)
bind-key -t vi-copy &#39;v&#39; begin-selection
bind-key -t vi-copy &#39;y&#39; copy-pipe &quot;reattach-to-user-namespace pbcopy&quot; # pbcopy is only available for Mac (not Linux)

# Prevent tmux from renaming the tab when processes change
set-option -g allow-rename off

# Set base index value to one (as apposed to zero)
set -g base-index 1

# Increase scrollback lines
set -g history-limit 30000

# Renumber windows automatically after removing a window
# Prevents my OCD and means I don&#39;t have to manually run {move|swap}-window
set-option -g renumber-windows on
</code></pre>

            <hr>
            <h2>Links</h2>
            <ul>
                <li><a href="../index.html">Home</a></li>
                <li><a href="../posts/about.html">About Me</a></li>
                <li><a href="https://github.com/integralist">GitHub</a></li>
                <li><a href="https://twitter.com/integralist">Twitter</a></li>
                <li><a href="http://www.integralist.co.uk/resume">Resume</a></li>
            </ul>
        </article>
        <script src="../scripts/prism.js"></script>
        <script>
            var _gaq=[['_setAccount','UA-33159515-1'],['_trackPageview']];
            (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
            g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
            s.parentNode.insertBefore(g,s)}(document,'script'));
        </script>
    </body>
</html>
