<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, minimal-ui">
        <title>Host Methods vs Native Methods</title>
        <link rel="stylesheet" href="../styles/github-markdown.css">
        <link rel="stylesheet" href="../styles/prism-default.css">
        <style>
            body {
                min-width: 200px;
                max-width: 790px;
                margin: 0 auto;
                padding: 30px;
            }

            pre[class*="language-"] {
              border: 1px dashed #AAA;
              margin-bottom: 1em;
            }
        </style>
    </head>
    <body>
        <article class="markdown-body">
          <ul class="top-nav">
              <li><a href="../index.html">Home</a></li>
              <li><a href="../posts/about.html">About Me</a></li>
              <li><a href="https://github.com/integralist">GitHub</a></li>
              <li><a href="https://twitter.com/integralist">Twitter</a></li>
              <li><a href="http://www.integralist.co.uk/resume">Resume</a></li>
          </ul>

<h1>Host Methods vs Native Methods</h1>

<ul>
<li><a href="#1">Introduction</a></li>
<li><a href="#2">What they are?</a></li>
<li><a href="#3">How to detect them?</a></li>
<li><a href="#4">When is it OK to modify them?</a></li>
</ul>

<div id="1"></div>

<h2>Introduction</h2>

<p>This was intended as a short and overly simplified post about Host methods and Native methods.</p>

<div id="2"></div>

<h2>What they are?</h2>

<p>Native methods are built-in functions provided by the ECMAScript core specification. So things like Object methods (e.g. <code>Object.create</code>), Array methods (e.g. <code>Array#forEach</code>) etc.</p>

<p>Host methods are functions provided by the host environment (most of the time when working in web development the host environment will be the user’s web browser). So things like the DOM API and the Events object are host objects/methods (e.g. <code>attachEvent</code> is a host method and <code>addEventListener</code> is a host method)</p>

<div id="3"></div>

<h2>How to detect them?</h2>

<p>Detecting Native methods is relatively straight forward. The real problem comes when you need to determine whether the object/method you’re detecting actually works the way the specification dictates it should work. So just checking it is available to use isn’t good enough.</p>

<p>Detecting host methods is similar but a lot more problematic, because the ECMAScript specification states that the host environment can implement certain methods however they like and so there is no guarantee that your checks for certain host methods (which may work today) will work in future.</p>

<p>We’ll give an example of each so you can get an idea of what I mean…</p>

<p>To detect a Native method such as Array#forEach you should be able to do the following:</p>

<pre><code class="language-javascript">if (!Array.prototype.forEach) { 
    /* polyfill for missing forEach method */ 
}
</code></pre>

<p>Note: polyfill is a term that Remy Sharp coined which means ‘a shim that mimics a future API’ (see: <a href="http://remysharp.com/2010/10/08/what-is-a-polyfill/">http://remysharp.com/2010/10/08/what-is-a-polyfill/</a>)</p>

<p>But the issue you could encounter in this example is if you’re inheriting a project from another developer and they have already extended the Native Array object with a forEach method and their polyfill version of the missing forEach function doesn’t work how the specification has dictated it should then you could find your code errors at hard to debug stages because of the difference in implementation where you’re passing parameters into a polyfill’ed method and that method hasn’t been implemented properly so the extra parameters either throw an error or (potentially worse) silently fail.</p>

<p>This is where you either ‘suck it and see’ (which is a bad idea, but not always unavoidable), or you attempt genuine ‘feature detection’ which means (in this example) you create a test Array and test the forEach method works how you expect it to.</p>

<p>The downsides to this approach (although it is the most robust and future-proof way of writing your code) is that all these checks are a performance penalty. If you’re sure the method you’re checking for is going to work how you expect it to then should you waste time/effort writing additional checks/tests to ensure the method works how the specification dictates? What happens if you do the full feature detection and discover the method doesn’t work how you expect it? You’ll still then need to implement some kind of fallback or lose the functionality that relies on that method.</p>

<p>These are important decisions that need to be made and ones that are outside the realms of this post I’m afraid (simply because there are no easy answers).</p>

<p>Now, detecting Host methods is actually worse because they can be implemented in any fashion the host environment chooses.</p>

<p>So far it has been <em>noted</em> that checking the <code>typeof</code> result for a Host method will normally result in either function, object or unknown, so if you get one of these back as a result then it’s a good chance the host object you’re checking for is available to use, but as you should be able to tell by now, this is a flawed process… fun heh!</p>

<p>Again, this isn’t a reliable assumption to make, because in a future/new host environment they might have a <code>typeof</code> result that is none of the above. Literally you could check the <code>typeof</code> for a method and its result could be <em>spacecraft</em> - there are no rules as far as the Host environment is concerned!</p>

<p>But for testing a host method exists, the following function has become the de-facto standard:</p>

<pre><code class="language-javascript">/*
 * Feature Testing a Host Method
 * Because a callable host object can legitimately have any typeof result then it can&#39;t be relied upon.
 *
 * @notes:
 * The reason for the &amp;&amp; !!object[property] is because in ECMAScript version 3, 
 * a null object has typeof result &#39;object&#39; (which is considered a bug).
 * In future versions (ECMAScript 6+) the typeof result will be &#39;null&#39; (as it should be).
 * 
 * @reference: http://michaux.ca/articles/feature-detection-state-of-the-art-browser-scripting
 */

function isHostMethod(object, property) {
    var type = typeof object[property];

    return type == &#39;function&#39; || // This is the result we&#39;re expecting (as the test is for a method)
           (type == &#39;object&#39; &amp;&amp; !!object[property]) || // Protect against ES3 &#39;null&#39; typeof result being &#39;object&#39;
           type == &#39;unknown&#39;; // For IE &lt; 9 when Microsoft used ActiveX objects for Native Functions (we&#39;re checking property of ActiveX object)
}
</code></pre>

<p>So lets take a quick re-cap of what’s going on here:</p>

<ul>
<li><p><code>function</code>:<br>
For most browsers the <code>typeof</code> operator will result with <code>function</code> when passed a callable host object</p></li>
<li><p><code>&#39;object’ &amp;&amp; !!object[property]</code>:<br>
Because we&#39;re dealing with host objects we can&#39;t expect <code>function</code> to be returned, and in most cases (as far as ECMAScript 3 [ES3] implementations are concerned) the result will normally be <code>object</code> which is incorrect but allowed as far as the ES3 spec is concerned.</p>

<p>So first of all we check for <code>object</code>.</p>

<p>If that matches we then check to make sure the property coerces to true. The reason for this is that ES3 allows the host to return whatever they like, so if the property you&#39;re checking for is actually <code>null</code> the ES3 <code>typeof</code> result (for most browsers) will still be <code>object</code> even though the result is <code>null</code>! So to work around this issue we coerce the result into a boolean (so if <code>null</code> is the result it will coerce to false and thus this whole expression will return false, otherwise it&#39;ll return true).</p></li>
<li><p><code>unknown</code>:<br>
In older versions of IE (less than 9) it implements some of its host objects not as Native functions but as ActiveX objects (admittedly this is deep browser implementation talk and normally you don’t need to know this stuff, but in this instance it’s important to understand what the heck is going on with IE). </p>

<p>So, in IE calling the <code>typeof</code> operator with properties of an ActiveX Object will result in <code>unknown</code>.</p></li>
</ul>

<div id="4"></div>

<h2>When is it OK to modify them?</h2>

<p>Modifying built-in Native objects isn’t as dangerous as host objects (as already noted by Kangax <a href="http://perfectionkills.com/extending-built-in-native-objects-evil-or-not/">http://perfectionkills.com/extending-built-in-native-objects-evil-or-not/</a>) but care needs to be taken to ensure the augmented object works as the spec dictates (something that isn’t possible all the time, for example like with <code>Object.create</code>).</p>

<p>As far as host objects are concerned, never ever ever ever modify or augment them, just too dangerous.</p>

            <hr>
            <h2>Links</h2>
            <ul>
                <li><a href="../index.html">Home</a></li>
                <li><a href="../posts/about.html">About Me</a></li>
                <li><a href="https://github.com/integralist">GitHub</a></li>
                <li><a href="https://twitter.com/integralist">Twitter</a></li>
                <li><a href="http://www.integralist.co.uk/resume">Resume</a></li>
            </ul>
        </article>
        <script src="../scripts/prism.js"></script>
        <script>
            var _gaq=[['_setAccount','UA-33159515-1'],['_trackPageview']];
            (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
            g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
            s.parentNode.insertBefore(g,s)}(document,'script'));
        </script>
    </body>
</html>
