# Thread Safe Concurrency

- [Introduction](#1)
  - [Shared Memory](#2)
  - [Message Passing](#3)
- [Various options](#4)
  - [Mutexes/Semaphores](#5)
  - [STM](#6)
  - [Actors](#7)
  - [CSP](#8)
- [Conclusion](#9)

<div id="1"></div>
## Introduction

Concurrency is a difficult concept. Regardless of programming language or idiom that you use, the practice of programming a "thread-safe" application can be harder than you think.

There are two fundamental models of concurrency:

1. Shared Memory
2. Message Passing

In the first, we have concepts such as Threads, Locks and Mutexes. In the latter we have patterns such as Actors and CSP, which rely on the mantra of...

> "don't communicate by sharing memory; share memory by communicating"

<div id="2"></div>
### Shared Memory

The following diagram is an extremely simplistic view of how CPUs, Processes and Threads interact but should help us to better understand why code can become **NON** thread-safe (as far as the "Shared Memory" model is concerned; we'll see shortly that the "message passing" model side steps this issue):

<a href="../images/cpu-processes-and-threads.png">
    <img src="../images/cpu-processes-and-threads.png">
</a>

...for those of you who cannot see the image, effectively a process can spawn multiple threads and each thread belonging to a specific process shares the memory related to the process.

Meaning if your software process creates two threads, then both threads have access to the same memory space and thus can manipulate the same chunk of memory (and by memory, I'm specifically referring to data the application creates/has access to).

This means, if your software creates some mutable data (e.g. in Ruby this could look something like `foo = "bar"` - a `foo` variable that holds the String value `bar`) and you want to modify the value of the variable, then multiple threads could manipulate the value in an unexpected order and subsequently cause a difficult to locate bug.

Any time you create a new Thread and within that Thread you modify a mutable piece of data you should be concerned about how "thread-safe" that data is.

> Note: if you're also utilising immutable data structures (as found in more functional languages, but also languages such as Go where they "pass by value" rather than "pass by reference") then this also makes code less prone to thread-safety concerns (but that's a discussion for another day)

<div id="3"></div>
### Message Passing

The message passing model relies on no data being shared, but rather communication between processes happening via either a message bus or by piping messages down a channel (depending on which style is implemented in your programming language of choice).

As well as avoiding the issue of data being shared, it also avoids the issue of trying to recover from failures (which thread/process is the correct one); which is a hard problem to reason about.

<div id="4"></div>
## Various options

There are four main types of solutions to the problem of thread-safe concurrency:

1. Mutexes/Semaphores
2. Software Transactional Memory (STM)
3. The "Actors" pattern
4. Communicating Sequential Processes (CSP)

Let's investigate each of these in turn:

<div id="5"></div>
### Mutexes/Semaphores

We'll be discussing specifically "mutexes" rather than "semaphores" (they have very similar purposes - in that they control access to specific data - although a mutex offers some additional guarantees which we won't go into here).

When using a mutex, you can "lock" a piece of data so only that specific Thread has access to the data. When done manipulating the data you can "unlock" it, thus allowing another Thread to use a mutex to "lock" the data so it can make its own changes.

Let's take a look at an example (in Ruby):

<!--language-ruby-->

    def update
      mutex = Mutex.new
      data  = 0

      Thread.new { mutex.synchronize { data += 1} }.join
    end

> Note: for the full Mutex API see [http://www.ruby-doc.org/core-2.1.5/Mutex.html](http://www.ruby-doc.org/core-2.1.5/Mutex.html)

This particular solution is the simplest of the three. It doesn't take into account any logic for handling unexpected changes to data (we'll see what that means in the next section).

<div id="6"></div>
### STM

Software Transactional Memory is known as being an "optimistic" process. Compare this to the lock-synchronisation mechanism of a Mutex, which implies the onus of whether a write action will succeed, should be on the "writer" (i.e. the "writer" locks the data, writes the data, then releases the lock). 

The STM on the other hand doesn't care what happens in another Thread, it instead records all the changes in a log file and then just before it confirms the write (referred to as a "commit" in STM terminology) it verifies the data we're modifying hasn't changed, and if it hasn't we go ahead and commit the change made by our Thread.

If a change has been made to the shared data source, then the transation will start over; but this time using the latest copy of the data we're modifying (note: this can in some cases cause a deadlock to occur).

The following example uses the Clojure programming language to implement a thead-safe modification via the STM (specifically the `ensure` function allows us to tell the STM what shared memory to watch for changes while our transaction is ongoing). 

The requirement in the code is that the two bank accounts must have at least 1000 in total between them. If we try to remove an amount from either account which results in the total amount falling below 1000 then we should not complete that transaction:

<!--language-scheme-->

    (def current-account (ref 500))
    (def savings-account (ref 600))
    
    (defn withdraw [from constraint amount]
      (dosync
        (let [total (+ @from (ensure constraint))]
          (Thread/sleep 1000) ; allows for a more visible context switch
          (if (>= (- total amount) 1000)
            (alter from - amount)
            (println "Sorry, can't withdraw due to constraint violation")))))
    
    (println "STATE BEFORE MODIFYING")
    (println "Current Account balance is" @current-account)
    (println "Savings Account balance is" @savings-account)
    (println "Total balance is" (+ @current-account @savings-account))
    
    (future (withdraw current-account savings-account 100))
    (future (withdraw savings-account current-account 100))
    
    (Thread/sleep 4000)
    
    (println "STATE AFTER MODIFYING")
    (println "Current Account balance is" @current-account)
    (println "Savings Account balance is" @savings-account)
    (println "Total balance is" (+ @current-account @savings-account))

The output of the above code could look like the following (but refer to the below note which explains why in some instances, because the transaction can fail and automatically retry, you could possibly see the failure message informing the user that the transaction failed even when it was successful):

<!--language-scheme-->

    (load-file "test.clj")

    current-account:clojure.lang.Ref@330ff9eb
    savings-account:clojure.lang.Ref@a5ec812

    STATE BEFORE MODIFYING
    Current Account balance is 500
    Savings Account balance is 600
    Total balance is 1100

    STATE AFTER MODIFYING
    Current Account balance is 500
    Savings Account balance is 500
    Total balance is 1000

> Note: `println` is sending data to *stdout* (defined as a thread-local dynamic variable). This variable is binded to the current Thread by default (meaning values don't cross over into other Threads).  

> A `future` creates a new Thread, but the binding of *stdout* is inherited by the `future`'s parent process (i.e. any `println` calls within the `withdraw` function - which runs in the parent process - can appear in the `future`'s thread); meaning the output sent by `println` doesn't necessarily reflect the correct state.

> For example, even when the transaction completes successfully, you might see the failure message printed - at some point in *stdout* - because the failing message is coming from an earlier transaction that indeed failed. But after a retry the transaction passed and so the message you see in *stdout* doesn't reflect the latest status of the application.

> I would suggest that the `println` message be moved outside of the transaction and that you add additional logic after the transaction code (this means after the transaction has completed; inc. retries) as a way to work around this issue with printing messages to *stdout* prematurely after a failed transaction. 

> I didn't bother implementing this within my example, as it wasn't essential to understanding the code.

<div id="7"></div>
### Actors

The basic premise of the Actors pattern is built upon it being a form of "message bus". The philosophy of the pattern is that everything is an Actor. An Actor receives messages and based on its state can determine whether it wants to handle the task defined in the message it has received, or to delegate the task off to other subordinates. An Actor can also create more Actors dynamically.

The use of messages allows communication to become asynchronous and loosely coupled from the rest of the system. But this can result in non-sequential message order (unless you have an Actor whose role is to ensure ordering via some form of Queue).

The Actor pattern has been made popular via Erlang and Scala (in the form of the [Akka](http://akka.io/) framework)

> Note: Akka has bindings for other JVM based languages (Clojure, JRuby, Groovy): [http://doc.akka.io/docs/akka/2.3.4/additional/language-bindings.html](http://doc.akka.io/docs/akka/2.3.4/additional/language-bindings.html)

I've yet to get around to writing any Scala code and so because Scala is the defacto example of the Akka framework I've decided to borrow an example from the official Akka site:

<!--language-scala-->

    case class Greeting(who: String)
     
    class GreetingActor extends Actor with ActorLogging {
      def receive = {
        case Greeting(who) â‡’ log.info("Hello " + who)
      }
    }
     
    val system = ActorSystem("MySystem")
    val greeter = system.actorOf(Props[GreetingActor], name = "greeter")
    greeter ! Greeting("Charlie Parker")

<div id="8"></div>
## CSP

Communicating Sequential Processes is an alternative mechanism for expressing concurrency, which has been popularized by recent languages [Clojure](http://clojure.org/) and [Go](http://golang.org/). It also is based on the idea of message passing, similar to the Actor pattern.

Some of the fundamental differences between this and the Actor pattern are:

- Messages are sequential
- Communication is synchronous
- Communication happens via defined "channels"
- Processes are anonymous 
  - i.e. Actors know who to communicate with
  - Where as Channels are pipes with messages going in and listeners the other end

You also have the option of applying other patterns such as multiplexing multiple channels down into one, think "fan-in", which can help in certain scenarios where you want to accept lots of messages comming in (the reverse is also possible, i.e. "fan-out").

Picking one model over another (Actor vs CSP) will be determined by the level of complexity you feel is inherently added by either solution and/or model your language of choice supports.

The following is an extremely simple demonstration of the CSP/channel model written in Go (there is a channel which accepts an infinite number of messages; and our `main` function will take the messages from the channel as they become available):

<!--language-go-->

    package main

    import (
        "fmt"
        "math/rand"
        "time"
    )

    func main() {
        c := createChannel("hello")

        for i := 0; i < 5; i++ {
            fmt.Printf("You say: %q\n", <-c)
        }

        fmt.Println("OK, we've received enough messages; stopping now")
    }

    func createChannel(msg string) <-chan string {
        c := make(chan string)

        // endlessly fire messages onto our channel
        go func() {
            for i := 0; ; i++ {
                c <- fmt.Sprintf("%s %d", msg, i)
                time.Sleep(time.Duration(rand.Intn(1e3)) * time.Millisecond)
            }
        }()

        return c
    }

Again, it's important to realise that Channels are synchronous and can block/cause deadlocks. In Go you can implement a timeout as a way of avoiding deadlocks. I'm not currently sure if Clojure has a similar work-around built into the language or whether you have to manually implement that yourself.

<div id="9"></div>
## Conclusion

As mentioned at the start of this post: solving the problem of thread-safe concurrency isn't necessarily as straight forward as you would have hoped (if you're new to the concepts). Throw in distributed systems and the problem is conflated even further.

But with that being said, we can clearly see there are quite a few different options available to us already - albeit with differing levels of complexity depending on the problem we're trying to solve. This is a good thing because you shouldn't always reach for a more complex solution if it's not necessary. If the problem is a small one and a simple mutex resolves it then maybe that's OK. Don't over engineer your system.
