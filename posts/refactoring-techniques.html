<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, minimal-ui">
        <title>Refactoring Techniques</title>
        <link rel="stylesheet" href="../styles/github-markdown.css">
        <style>
            body {
                min-width: 200px;
                max-width: 790px;
                margin: 0 auto;
                padding: 30px;
            }
        </style>
    </head>
    <body>
        <article class="markdown-body">

<h1>Refactoring Techniques</h1>

<ul>
<li>Introduction</li>
<li>Languages</li>
<li>Why refactor?</li>
<li>When should refactor?</li>
<li>Tests</li>
<li>Refactoring Techniques

<ul>
<li><a href="#rename-method">Rename Method</a></li>
<li><a href="#introduce-explaining-variable">Introduce Explaining Variable</a></li>
<li><a href="#inline-temp">Inline Temp</a></li>
<li><a href="#split-temp-variable">Split Temp Variable</a></li>
<li><a href="#replace-temp-with-query">Replace Temp With Query</a></li>
<li><a href="#replace-temp-with-chain">Replace Temp With Chain</a></li>
<li><a href="#extract-method">Extract Method</a></li>
<li><a href="#inline-method">Inline Method</a></li>
<li><a href="#move-method">Move Method</a></li>
<li><a href="#replace-method-with-method-object">Replace Method With Method Object</a></li>
<li><a href="#replace-loop-with-collection-closure-method">Replace Loop With Collection Closure Method</a></li>
<li><a href="#pull-up-method">Pull Up Method</a></li>
<li><a href="#form-template-method">Form Template Method</a></li>
<li><a href="#extract-surrounding-method">Extract Surrounding Method</a></li>
<li><a href="#self-encapsulate-field">Self Encapsulate Field</a></li>
<li><a href="#introduce-named-parameter">Introduce Named Parameter</a></li>
</ul></li>
<li>Conclusion</li>
</ul>

<h2>Introduction</h2>

<p>Let&#39;s begin by considering: &quot;What is Refactoring?&quot;</p>

<p>The definition of refactoring is:</p>

<blockquote>
<p>a disciplined technique for restructuring an existing body of code, altering its internal structure without changing its external behaviour</p>
</blockquote>

<p>Refactoring is a term originated from the <a href="http://en.wikipedia.org/wiki/Smalltalk">Smalltalk</a> community of developers back in the mid-late nineties. </p>

<p>Two of the most prolific programmers of recent times, <a href="http://martinfowler.com/">Martin Fowler</a> and <a href="http://en.wikipedia.org/wiki/Kent_Beck">Kent Beck</a> literally wrote the book on the subject of refactoring called &quot;<a href="http://www.amazon.com/gp/product/0201485672">Refactoring: Improving the Design of Existing Code</a>&quot; (well, written by Martin with contributions from Kent).</p>

<p>In 2009 both Martin and Kent helped with a rewrite of the book that focused more on the Ruby language than the original book&#39;s target language of Java. This follow-up book was called &quot;<a href="http://www.amazon.com/Refactoring-Ruby-Edition-Jay-Fields/dp/0321603508">Refactoring: The Ruby Edition</a>&quot; and it&#39;s that book which is the primary driving force of this post.</p>

<p>Since reading the Ruby edition I wanted to have a short summarised version of some of the more commonly used refactoring techniques (mainly for my own reference). By that I mean the techniques described in the book that I find interesting and use a lot in my day to day programming life.</p>

<h2>Languages</h2>

<p>These refactoring techniques aren&#39;t specific to the Ruby language. You can use them when working with JavaScript or PHP (or any other language for that matter). </p>

<p>Programming languages don&#39;t all offer identical APIs and so sometimes you might need to tweak the examples slightly to fit your environment. </p>

<p>Regardless, the idioms and syntax differences between languages become redundant when you just focus on the pattern(s) behind the proposed solution.</p>

<h2>Why refactor?</h2>

<p>The purpose of refactoring is to improve the quality, clarity and maintainability of your code. Simple really.</p>

<p>But also, refactoring can be a great lesson in understanding an unfamiliar code base.</p>

<p>Think about it, if you inherit a poorly designed code base that you&#39;ve not seen before and you now need to either fix a bug or add a new feature, then implementing the code necessary would be a lot easier once you had refactored it to be in a more stable, maintainable and ultimately &#39;understandable&#39; state. </p>

<p>Otherwise you would be forced to retro fit your new code on top of a poorly designed foundation and that would be the start of a very unhappy relationship.</p>

<h2>When should you refactor?</h2>

<p>You&#39;ll usually find the time you start refactoring the most is when you are fixing bugs or adding new features.</p>

<p>For example, you typically first need to understand the code that has already been written (regardless of whether it was you who wrote it originally or someone else). </p>

<p>The process of refactoring helps you better understand the code, in preparation for modifying it.</p>

<p>But don&#39;t fall into the trap of thinking that refactoring is something you set aside time for, or only consider at the start/end of a project. It&#39;s not. Refactoring should be done in small chunks throughout the entire life cycle of the project.</p>

<p>As the great <a href="http://www.cleancoder.com/">Uncle Bob</a> once said:</p>

<blockquote>
<p>leave a module in a better state than you found it</p>
</blockquote>

<p>...what this suggests is that refactoring is essential to your daily coding process.</p>

<h3>Tests</h3>

<p>Before we get started, it&#39;s important to mention that you should have tests in place when you&#39;re refactoring. </p>

<p>You <em>can</em> refactor without tests, but realise that without tests to back you up then you can have no confidence in the refactoring you are implementing.</p>

<p>Refactoring can result in substantial changes to the code and architecture but still leave the top layer API the same. So while you&#39;re refactoring remember the old adage...</p>

<blockquote>
<p>program to an interface, not an implementation</p>
</blockquote>

<p>We want to avoid changing a public API where ever possible (as that&#39;s one of the tenets of refactoring).</p>

<p>If you don&#39;t have tests then I recommend you write some (now)... don&#39;t worry, I&#39;ll wait.</p>

<p>Remember, the process of writing tests (even for an application you don&#39;t know) will help solidify your understanding and expectations of the code you&#39;re about to work on.</p>

<p>Code should be tested regularly while refactoring to ensure you don&#39;t break anything. Keep the &#39;red, green, refactor&#39; feedback loop tight. Tests help confirm if your refactoring has worked or not. Without them you&#39;re effectively flying blind.</p>

<p>So although I won&#39;t explicitly mention it below when discussing the different refactoring techniques, it is implied that on every change to your code you should really be running the relevant tests to ensure no broken code appears.</p>

<h2>Refactoring Techniques</h2>

<p>There are many documented refactoring techniques and I do not attempt to cover them all, as this post would end up becoming a book in itself. So I&#39;ve picked what I feel are the most common and useful refactoring techniques and I try my best to explain them in a short and concise way.</p>

<p>I&#39;ve put these techniques in order of how you might approach refactoring a piece of code, in a linear, top to bottom order. This is a personal preference and doesn&#39;t necessarily represent the best way to refactor.</p>

<p>Final note: with some of the techniques I have provided a basic code example, but to be honest some techniques are so simple they do not need any example. The <a href="#extract-method">Extract Method</a> is one such technique that although really useful and important, providing a code example would be a waste of time and space.</p>

<p>So without further ado, let&#39;s begin...</p>

<h3>Rename Method</h3>

<p>The single most effective and simple refactoring you can implement is to rename a property/attribute, method or object.</p>

<p>Renaming identifiers can reduce the need for code comments and nearly always helps to promote greater clarity.</p>

<p>You&#39;ll find that renaming things is a fundamental part of other refactoring techniques to aid understanding of the code.</p>

<p>This technique relies on giving items a descriptive name to ensure the developer knows at a glance exactly what it does. The following technique <a href="#introduce-explaining-variable">Introduce Explaining Variable</a> is effectively the same.</p>

<h3>Introduce Explaining Variable</h3>

<p>So here is a technique specifically based around the premise of renaming. </p>

<p>If you have a complicated expression (for example, you&#39;ll typically have a long winded set of conditions within an <code>if</code> statement) then place that complex expression into a temp variable and give it a descriptive identifier. </p>

<p>For example:</p>

<p><code>ruby
unless &quot;This is a String with some CAPS&quot;.scan(/([A-Z])/).empty?
  puts &quot;capitalised text was found&quot;
end
</code></p>

<p>Should be:</p>

<p>```ruby
caps<em>not</em>found = &quot;This is a String with some CAPS&quot;.scan(/([A-Z])/).empty?</p>

<p>unless caps<em>not</em>found
  puts &quot;capitalised text was found&quot;
end
```</p>

<p>Note: this is the only technique that finds temps (i.e. local variables) acceptable. This is because temps are deemed to be less reusable than methods (due to their very nature being &#39;local&#39;) and so introducing temps is something that shouldn&#39;t be considered lightly. Maybe consider using the <a href="#extract-method">Extract Method</a> technique instead before using this particular technique. </p>

<p>Also, don&#39;t worry about performance until you know you have a performance issue to worry about. Developers will always suggest that calling methods is slower than running code inline, but good programming is about readability and maintainability, and extracted methods are not only easier to understand but are much more reusable by other methods. </p>

<p>So if you are considering using the <a href="#introduce-explaining-variable">Introduce Explaining Variable</a> technique, first decide whether the temp would be more useful if it was available to other methods (that way you could use <a href="#extract-method">Extract Method</a> instead and avoid defining a temp altogether).</p>

<h3>Inline Temp</h3>

<p>Temp variables are a bit of a code smell as they make methods longer and can make the <a href="#extract-method">Extract Method</a> more awkward (as you&#39;d have to pass through more data to the extracted method).</p>

<p>Inline Temp effectively removes the temp variable altogether by just using the value assigned to it (I&#39;d only suggest doing this if the temp is only used once or if the resulting value has come from a method invocation).</p>

<p>For example:</p>

<p>```ruby
def add_stuff
    1 + 1
end</p>

<p>def do<em>something
    temp</em>variable<em>with</em>descriptive<em>name = add</em>stuff
    puts &quot;Number is #{temp<em>variable</em>with<em>descriptive</em>name}&quot;
end
```</p>

<p>Should be:</p>

<p>```ruby
def add_stuff
    1 + 1
end</p>

<p>def do<em>something
    puts &quot;Number is #{add</em>stuff}&quot;
end
```</p>

<p>Note: a temp by itself doesn&#39;t do any harm, and in some instances can actually make the code clearer (especially if using a result from a method invocation and the method identifier doesn&#39;t indicate the intent as well as it should).</p>

<p>But most likely you&#39;ll end up using this technique to aid the <a href="#extract-method">Extract Method</a> technique as less temp vars means less requirement to pass through additional parameters to the extracted method.</p>

<h3>Split Temp Variable</h3>

<p>This technique aims to resolve the concern of violating the SRP (Single Responsibility Principle), although slightly tamer in the sense that SRP is aimed more at Classes/Objects and methods, not typically variable assignments.</p>

<p>But regardless if a temporary variable is assigned to more than once and it is not a loop variable or a collecting/accumulator variable then it is a temp considered to have too many responsibilities.</p>

<p><strong>For example</strong>: (this is a daft example, but what the heck)</p>

<p><code>ruby
temp = 2 * (height + width)
temp = height * width
</code></p>

<p><strong>Becomes</strong>:</p>

<p><code>ruby
perimeter = 2 * (height + width)
area = height * width
</code></p>

<p>As you can see, the temp variable was handling more responsibility than it should be and so by creating two appropriately distinct temps we ensure greater code clarity.</p>

<h3>Replace Temp With Query</h3>

<p>This technique has a very similar intent to <a href="#inline-temp">Inline Temp</a> in that one of its primary focuses is to aid the <a href="#extract-method">Extract Method</a>.</p>

<p>The subtle but important difference between this technique and <a href="#inline-temp">Inline Temp</a> is that the complex expression assigned to the temp needs to be first moved to a method (where as the <a href="#inline-temp">Inline Temp</a> technique is different in that the temp may already be using a method invocation).</p>

<p>For example:</p>

<p>```ruby
class Box
  attr_reader :length, :width, :height</p>

<p>def initialize length, width, height
    @length = length
    @width  = width
    @height = height
  end</p>

<p>def volume
    # <code>area</code> is the temp
    area = length * width
    area * height
  end
end
```</p>

<p>Becomes:</p>

<p>```ruby
class Box
  attr_reader :length, :width, :height</p>

<p>def initialize length, width, height
    @length = length
    @width  = width
    @height = height
  end</p>

<p>def volume
    # notice <code>area</code> is now a direct method call
    area * height
  end</p>

<p>def area
    length * width
  end
end
```</p>

<p>This technique can help to shorten a long method by not having to define lots of temp variables just to hold values.</p>

<p>If the extracted query method is given an identifier that aptly describes its purpose then the code still can be considered clear and descriptive. </p>

<p>Also, it is considered bad form to define a variable which changes once it has been set (hence moving to a method better indicates an unstable value). </p>

<p>Note: this technique can sometimes be made easier to implement once you&#39;ve used <a href="#split-temp-variable">Split Temp Variable</a>. </p>

<p>Remember this technique (as with other techniques) is an incremental step towards removing non-essential temps, so consider using <a href="#inline-temp">Inline Temp</a> afterwards, thus removing the need for the temp altogether.</p>

<h3>Replace Temp With Chain</h3>

<p>This is yet another technique designed to rid your code of temp variables. </p>

<p>If you have a temp variable holding the result of calling an object&#39;s method, and follow the assignment by using that temp to carry out more method calls, then you should consider chaining method calls instead.</p>

<p>The implementation is quite simple, you just have to ensure the methods called return <code>self</code> (or <code>this</code> if using a language like JavaScript).</p>

<p>By allowing methods to chain we again have the opportunity to remove an unnecessary temps.</p>

<p><strong>For example</strong>:</p>

<p>```ruby
class College
    def create_course
        puts &quot;create course&quot;
    end</p>

<pre><code>def add_student
    puts &quot;add student&quot;
end
</code></pre>

<p>end</p>

<p>temp = College.new
temp.create<em>course
temp.add</em>student
temp.add<em>student
temp.add</em>student
```</p>

<p><strong>Becomes</strong>:</p>

<p>```ruby
class College
    # static method so can be accessed without creating an instance
    def self.create_course
        college = College.new
        puts &quot;create course&quot;
        college # return new object instance
    end</p>

<pre><code>def add_student
    puts &quot;add student&quot;
    self # refers to the new object instance
end
</code></pre>

<p>end</p>

<p>college = College.create<em>course
                 .add</em>student
                 .add<em>student
                 .add</em>student
```</p>

<h3>Extract Method</h3>

<p>Here it is! In my opinion &#39;<em>The</em>&#39; most used and important refactoring technique.</p>

<p>The implementation behind this technique is very simple. It consists of breaking up long methods by shifting overly complex chunks of code into new methods which have very descriptive identifiers. </p>

<p>For example:</p>

<p>```ruby
class Foo
  attr_reader :bar</p>

<p>def initialize bar
    @bar = bar
  end</p>

<p>def do_something
    puts &quot;my baz&quot; # notice this is duplication
    puts bar
  end</p>

<p>def do<em>something</em>else
    puts &quot;my baz&quot; # notice this is duplication
    puts &quot;Something else&quot;
    puts bar
  end
end
```</p>

<p>Becomes:</p>

<p>```ruby
class Foo
  attr_reader :bar</p>

<p>def initialize bar
    @bar = bar
  end</p>

<p>def do_something
    baz
    puts bar
  end</p>

<p>def do<em>something</em>else
    baz
    puts &quot;Something else&quot;
    puts bar
  end</p>

<p>def baz
    puts &quot;my baz&quot;
  end
end
```</p>

<p>But be careful with handling local variables as you&#39;ll need to pass them through to the extracted method and that can be difficult if there are lots of temps in use. Sometimes to facility the Extract Method you&#39;ll need to first incorporate other techniques such as <a href="#replace-temp-with-query">Replace Temp With Query</a> and <a href="#inline-temp">Inline Temp</a>.</p>

<h3>Inline Method</h3>

<p>Sometimes you want the opposite of the <a href="#extract-method">Extract Method</a> technique. Imagine a method exists whose content is already simple and clear, and whose identifier adds no extra benefit. In this instance we&#39;re just making an extra call for no real benefit.</p>

<p>So to fix this problem we&#39;ll convert the method invocation into an inlined piece of code (unless of course the method is used in multiple places, in that case leave it where it is as having it in a separate method keeps our code DRY).</p>

<h3>Move Method</h3>

<p>In a previous post about <a href="http://www.integralist.co.uk/posts/object-oriented-design-ood/#class-analysis">Object-Oriented Design</a> I explained that you should query your classes/objects to ensure the methods they define are actually where they should be (another reason is &#39;feature envy&#39;, if a method is asking another class a lot of questions then it may be an indication the method is on the wrong object).</p>

<p>The Move Method technique ensures this decoupling by simply moving the identified misplaced method onto the correct one.</p>

<p>Once the method has been moved you should clean up the previously passed parameters by seeing what can be moved over to the other object or whether additional data needs to be passed over now via the method invocation. </p>

<p>For example:</p>

<p>```ruby
class Gear
    attr_reader :chainring, :cog, :rim, :tire</p>

<pre><code>def initialize (chainring, cog, rim, tire)
  @chainring = chainring
  @cog       = cog
  @rim       = rim
  @tire      = tire

  # let&#39;s asked the question:
  # &quot;Please Mr. Gear what is your tire size?&quot;
  # hmm? notice this doesn&#39;t sound like it quite fits the purpose of a &#39;Gears&#39; class
end

def ratio
  chainring / cog.to_f
end

def gear_inches
    # tire goes around rim twice for diameter
    ratio * (rim + (tire * 2))
end
</code></pre>

<p>end
```</p>

<p>Becomes:</p>

<p>```ruby
class Gear
    attr_reader :chainring, :cog, :rim, :tire</p>

<pre><code>def initialize (chainring, cog, rim, tire)
  @chainring = chainring
  @cog       = cog
  @rim       = rim
  @tire      = tire.size
end

def ratio
  chainring / cog.to_f
end

def gear_inches
    # tire goes around rim twice for diameter
    ratio * (rim + (tire * 2))
end
</code></pre>

<p>end</p>

<p>class Tire
  def self.size
    5
  end
end
```</p>

<p>From the original class/object keep the original method in place while you test and change it so it now delegates to the method on the new object. Then slowly refactor by replacing delegating calls throughout your code base with direct calls to the method via its new host. </p>

<p>Finally, remove the old method altogether and the tests should tell you if you missed a replacement somewhere.</p>

<h3>Replace Method With Method Object</h3>

<p>You may run into a problem where you have a long method you want to use <a href="#extract-method">Extract Method</a> on, but the number of temporary local variables are too great to allow you to utilise the <a href="#extract-method">Extract Method</a> technique (because passing around that many variables would be just as messy as the long method itself).</p>

<p>To resolve this issue you could look at different types of smaller refactors (such as <a href="#inline-temp">Inline Temp</a>) but in some cases it would actually be better to first move the contents of the long method into an entirely new object.</p>

<p>So the first thing to do is create a new class named after the long method and add the temp local vars as properties/attributes of the class/object.</p>

<p>Now when you try to implement <a href="#extract-method">Extract Method</a> you don&#39;t have to pass around the temp vars because they are now available throughout the class/object. </p>

<p>Then from within the original class/object you can delegate any calls to the original method on to the object (you&#39;ll still pass on the original arguments to the method within the new object but from there on the method extraction becomes easier).</p>

<p>For example:</p>

<p>```ruby
class Foo
  def bar
    puts &quot;We&#39;re doing some bar stuff&quot;
  end</p>

<p>def baz(a, b, c)
    if a == &#39;something&#39;
      # do something
    end</p>

<pre><code>if b == &#39;else&#39;
  # do else
end

if c == &#39;none&#39;
  # do none
end
</code></pre>

<p>end
end
```</p>

<p>Becomes:</p>

<p>```ruby
class Foo
  def bar
    puts &quot;We&#39;re doing some bar stuff&quot;
  end
end</p>

<p>class Baz
  attr_accessor :a, :b, :c</p>

<p>def initialize(a, b, c)
    @a = a
    @b = b
    @c = c</p>

<pre><code>if a == &#39;something&#39;
  # do something
end

if b == &#39;else&#39;
  # do else
end

if c == &#39;none&#39;
  # do none
end
</code></pre>

<p>end
end
```</p>

<p>From here we&#39;re now in a better state to use both the <a href="#extract-method">Extract Method</a> and <a href="/posts/even-more-refactoring-techniques/#replace-conditional-with-polymorphism">Replace Conditional with Polymorphism</a> techniques to refactor the <code>Baz</code> class.</p>

<h3>Replace Loop With Collection Closure Method</h3>

<p>If you write a loop that parses a collection and interacts with the individual elements within the collection then move that interaction out into a separate closure based method (meaning you replace the loop with an Enumerable method). </p>

<p>This refactoring may not be as clear or impressive as other refactoring techniques but the motivation behind it is that you hide the ugly details of the loop behind a nicer iteration method, allowing the developer looking at the code to focus on the business logic instead.</p>

<p><strong>For example</strong>:</p>

<p><code>ruby
managers = []
employees.each do |e|
    managers &lt;&lt; e if e.manager?
end
</code></p>

<p><strong>Becomes</strong>:</p>

<p><code>ruby
managers = employees.select { |e| e.manager? }
</code></p>

<p>Ruby has a few of these types of enumerable methods but other languages such as PHP and JavaScript aren&#39;t so lucky. </p>

<p>JavaScript has a couple of accumulators: <code>Array#reduce</code> and <code>Array#reduceRight</code> but they aren&#39;t very useful as closure based collection methods compared to Ruby which has methods such as <code>Enumerable#inject</code>, <code>Enumerable#select</code> (seen in above example) or <code>Enumerable#collect</code>. </p>

<p>Note: in JavaScript you can implement a similar effect with clever use of closures.</p>

<h3>Pull Up Method</h3>

<p>When you have duplicated code across two separate classes then the best refactoring technique to implement is to pull that duplicate code up into a super class so we DRY (Don&#39;t Repeat Yourself) out the code and allow it to be used in multiple places without duplication (meaning changes in future only have to happen in one place).</p>

<p>For example:</p>

<p>```ruby
class Person
  attr<em>reader :first</em>name, :last_name</p>

<p>def initialize first<em>name, last</em>name
    @first<em>name = first</em>name
    @last<em>name = last</em>name
  end</p>

<p>end</p>

<p>class MalePerson &lt; Person
  # This is duplicated in the <code>FemalePerson</code> class
  def full<em>name
    first</em>name + &quot; &quot; + last_name
  end</p>

<p>def gender
    &quot;M&quot;
  end
end</p>

<p>class FemalePerson &lt; Person
  # This is duplicated in the <code>MalePerson</code> class
  def full<em>name
    first</em>name + &quot; &quot; + last_name
  end</p>

<p>def gender
    &quot;F&quot;
  end
end
```</p>

<p>Becomes:</p>

<p>```ruby
class Person
  attr<em>reader :first</em>name, :last_name</p>

<p>def initialize first<em>name, last</em>name
    @first<em>name = first</em>name
    @last<em>name = last</em>name
  end</p>

<p>def full<em>name
    first</em>name + &quot; &quot; + last_name
  end
end</p>

<p>class MalePerson &lt; Person
  def gender
    &quot;M&quot;
  end
end</p>

<p>class FemalePerson &lt; Person
  def gender
    &quot;F&quot;
  end
end
```</p>

<h3>Form Template Method</h3>

<p>The technique is reliant on inheritance: a parent class and two sub classes of
that parent. The two sub classes have methods which have similar steps, in the
same order and yet the steps themselves are different.</p>

<p>The technique involves moving the sequence of steps into the parent class and
then using polymorphism to allow the sub classes to handle the differences in
the steps.</p>

<p>Here is a silly example (I’m no good at giving real examples; you may have noticed), here is an
example of our problematic code…</p>

<p>```ruby
class Foo; end</p>

<p>class Bar &lt; Foo
  def initialize
    @hey = 1
    @hai = 2
  end</p>

<p>def qux
    @a = @hey + @hai
    @b = @a * 10
    @a + @b
  end
end</p>

<p>class Baz &lt; Foo
  def initialize
    @hey = 5
    @hai = 7
  end</p>

<p>def qux
    @a = @hey + @hai
    @b = @a * 10 * 20
    @a + @b
  end
end</p>

<p>bar = Bar.new
baz = Baz.new</p>

<p>puts bar.qux
puts baz.qux
```</p>

<p>…we could try to inject the values each sub class requires but then we still
have a lot of duplication in this code.</p>

<p>We can see the sequence of steps is:</p>

<p>determine what <code>a</code> should be<br>
determine what <code>b</code> should be<br>
return a specific calculation</p>

<p>…so we can clean up our code a little by abstracting the commonality...</p>

<p>```ruby
class Foo
  def initialize(hey=1, hai=1)
    @hey = hey
    @hai = hai
  end</p>

<p>def qux
    determine<em>a
    determine</em>b
    result
  end</p>

<p>def determine_a
    @a = @hey + @hai
  end</p>

<p>def result
    @a + @b
  end
end</p>

<p>class Bar &lt; Foo
  protected</p>

<p>def determine_b
    @b = @a * 10
  end
end</p>

<p>class Baz &lt; Foo
  protected</p>

<p>def determine_b
    @b = @a * 10 * 20
  end
end</p>

<p>bar = Bar.new(1, 2)
baz = Baz.new(5, 7)</p>

<p>puts bar.qux
puts baz.qux
```</p>

<h3>Extract Surrounding Method</h3>

<p>If you find you have different methods which contain almost identical code but with a slight variant in the middle, then pull up the duplicated code into a single method and pass a code block to the newly created method which it yields to in order to execute the unique behaviour...</p>

<p>```ruby
def do_something
    puts 1
    yield
    puts 3
end</p>

<p>do_something { puts 2 }
```</p>

<p>This is actually a common pattern in Ruby known as the &#39;wrap around&#39; method. This technique is similar to the <a href="#form-template-method">Form Template Method</a>, but is different in that you can use it without forcing an inheritance model on your code.</p>

<p>Note: JavaScript doesn&#39;t have the ability to pass a code block but it can be replicated by passing a function that acts like a callback...</p>

<p>```js
function doSomething (callback) {
        console.log(1);
        callback();
        console.log(3);
}</p>

<p>doSomething(function(){
        console.log(2);
});
```</p>

<p>...although in the latest versions of Node (as of November 2013) Generators are implemented and would allow JavaScript code to <code>yield</code> similar to how Ruby works.</p>

<h3>Self Encapsulate Field</h3>

<p>When inheriting properties from a parent class/object then it can be more flexible if the parent class only allows access to the properties from within a getter/setter.</p>

<p>The motivation for this technique is that a sub class can override and modify the behaviour of the getter/setter without affecting the parent class&#39; implementation. Which is similar to how the Decorator design pattern works (e.g. modifying the behaviour without affecting the original).</p>

<p>This technique should only be used once you find the coupling between objects is becoming a problem. Otherwise direct access to properties and instance variables should be acceptable initially.</p>

<p>For example:</p>

<p><code>ruby
def total
  @base_price * (1 + @tax_rate)
end
</code></p>

<p>Becomes:</p>

<p>```ruby
attr<em>reader :base</em>price, :tax_rate</p>

<p>def total
  base<em>price * (1 + tax</em>rate)
end
```</p>

<h3>Introduce Named Parameter</h3>

<p>When method arguments are unclear then convert them into named parameters so they become clearer (and easier to remember). </p>

<p>Although Ruby supports named parameters...</p>

<p><code>ruby
def turnOnTheTV (channel: 1, volume: 1); end
turnOnTheTV(channel: 101, volume: 10)
</code></p>

<p>...neither PHP or JavaScript do, so for PHP you can pass an associated Array and with JavaScript you can pass an Object/Hash.</p>

<p><strong>For example (JavaScript)</strong>:</p>

<p><code>ruby
function turnOnTheTV(c, v){}
turnOnTheTV(101, 10);
</code></p>

<p><strong>Becomes</strong>:</p>

<p><code>ruby
function turnOnTheTV (config) {
    // config.channel === 101
    // config.volume  === 10
}
turnOnTheTV({ channel: 101, volume: 10 });
</code></p>

<p>Note: ECMAScript 6.0 (the latest JavaScript specification - which is still being worked on as of Nov 2013) implements named parameters.</p>

<h2>Conclusion</h2>

<p>There are still many different refactoring techniques that I&#39;ve not included. But hopefully you&#39;ve found this quick reference useful so far. I&#39;ll continue these on in another post.</p>

            <hr>
            <h2>Links</h2>
            <ul>
                <li><a href="../index.html">Home</a></li>
                <li><a href="../posts/about.html">About Me</a></li>
                <li><a href="https://github.com/integralist">GitHub</a></li>
                <li><a href="https://twitter.com/integralist">Twitter</a></li>
                <li><a href="http://www.integralist.co.uk/Resume">Resume</a></li>
            </ul>
        </article>
        <script>
            var _gaq=[['_setAccount','UA-33159515-1'],['_trackPageview']];
            (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
            g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
            s.parentNode.insertBefore(g,s)}(document,'script'));
        </script>
    </body>
</html>
