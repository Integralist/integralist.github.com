<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, minimal-ui">
        <title>Security basics with GPG, OpenSSH, OpenSSL and Keybase</title>
        <link rel="stylesheet" href="../styles/github-markdown.css">
        <link rel="stylesheet" href="../styles/prism-default.css">
        <style>
            body {
                min-width: 200px;
                max-width: 790px;
                margin: 0 auto;
                padding: 30px;
            }

            pre[class*="language-"] {
              border: 1px dashed #AAA;
              margin-bottom: 1em;
            }
        </style>
    </head>
    <body>
        <article class="markdown-body">

<h1>Security basics with GPG, OpenSSH, OpenSSL and Keybase</h1>

<ul>
<li><a href="#1">Introduction</a></li>
<li><a href="#2">What are keys and how do they work?</a></li>
<li><a href="#3">Understanding PKI</a></li>
<li><a href="#4">OpenSSL vs OpenSSH</a></li>
<li><a href="#5">What is GPG?</a></li>
<li><a href="#6">Creating your own keys</a></li>
<li><a href="#7">How to encrypt data using GPG, OpenSSL and Keybase</a>

<ul>
<li><a href="#7.1">GPG encryption</a></li>
<li><a href="#7.2">OpenSSL encryption</a></li>
<li><a href="#7.3">Keybase</a></li>
</ul></li>
<li><a href="#8">Creating, self-signing, issuing and revoking certificates</a></li>
<li><a href="#9">Conclusion</a></li>
</ul>

<div id="1"></div>

<h2>Introduction</h2>

<p>This post <strong>isn&#39;t</strong> meant to be &quot;this is how you do security&quot;. I&#39;m not a security expert. I&#39;m not even a security intermediate! When I titled this post &quot;security basics&quot; I wasn&#39;t kidding. If you&#39;re working with applications and/or servers in production then <em>please</em> consult someone better equipped on the subject of security.</p>

<blockquote>
<p>Note: although quite a tough read at times, I would highly recommend &quot;Bulletproof SSL and TLS&quot; written by Ivan Ristić</p>
</blockquote>

<p>Now the actual purpose of this post was twofold:</p>

<ol>
<li>Solidify my own understanding of the tools I&#39;ll be covering</li>
<li>Helping others to also understand the purposes of said tools</li>
</ol>

<p>Security can be confusing. It&#39;s taken me longer than I care to admit to really understand the things I&#39;ll be discussing here (and even then I&#39;ll likely have missed a lot of important nuances), and with that said: what am I planning on covering in this post? Well that would be...</p>

<ul>
<li>What are keys and how do they work?</li>
<li>Understanding PKI</li>
<li>OpenSSL vs OpenSSH</li>
<li>What is GPG</li>
<li>Creating your own keys</li>
<li>How to encrypt data using GPG, OpenSSL and Keybase</li>
</ul>

<p>...and a lot more inbetween.</p>

<h3>Plaintext and Ciphers</h3>

<p>Throughout this post you&#39;ll see me use words like &quot;plaintext&quot; and &quot;cipher&quot;. It&#39;s important to know what these mean before moving on, so let&#39;s clarify this now:</p>

<p>When a file is said to be plaintext it simply means that it&#39;s unencrypted, where as a cipher is a noun that refers to a plaintext that has been encrypted. That&#39;s it.</p>

<div id="2"></div>

<h2>What are keys and how do they work?</h2>

<p>Imagine you have a plaintext file which contains a password, and you want to share this file with someone else across the internet (let&#39;s say this someone is our friend &quot;Bob&quot;).</p>

<p>You could open an email (or chat program), attach the file and send it to Bob. But this isn&#39;t very safe because you could have some devious person &#39;sniffing&#39; your network traffic, picking up your communication and subsequently stealing the plaintext file containing the password you&#39;d rather they not get access to.</p>

<p>To prevent this devious person from being able to see the password we would need to <em>encrypt</em> the plaintext document into a cipher and to transfer the cipher instead of the plaintext, meaning if anyone was to interrupt your communication then they would get the cipher and it would be unreadable.</p>

<p>In order to encrypt the plaintext into a cipher we need to use a technique that relies on the concept of a &quot;key&quot;. A key is a mathematical algorithm for turning plaintext into seemingly random alphanumeric characters. A key can be used to both encrypt and decrypt plaintext.</p>

<blockquote>
<p>Note: the longer the key, the more secure the encryption will be. This is why, when generating keys, you&#39;ll typically be asked to provide the key size (e.g. 128-bit) you want to use for your encryption key</p>
</blockquote>

<p>But in order for your recipient (Bob in this case) to know how to <em>decrypt</em> the cipher you&#39;ve sent to them, they also need to know the key you&#39;ve used.</p>

<p>So how do you let the intended recipient (Bob) know the algorithm you&#39;ve used? You can&#39;t just email them and say &quot;I&#39;ve used algorithm X to turn this plaintext document into a cipher&quot;, because the same devious person who originally sniffed your network traffic and grabbed your cipher will also be able to sniff this additional communication and learn the algorithm (i.e. the key) that was used to encrypt the plaintext; allowing them to decrypt your cipher and to retrieve your super secret password.</p>

<h3>Public-key cryptography</h3>

<p>To resolve the issue of not being able to safely communicate an encryption key, some clever people designed a scheme known as &quot;public-key cryptography&quot;. The principle idea being that you generate two keys:</p>

<ol>
<li>A public key</li>
<li>A private key</li>
</ol>

<p>As you can probably already guess, the &quot;public&quot; key is something that is safe to become public (i.e. if some devious person got a hold of your public key then it&#39;s not that much of an issue), while the &quot;private&quot; key is something you should keep hidden and not share with anyone (it&#39;s very important you protect this file).</p>

<p>But how exactly do these two keys help our situation?</p>

<p>Well, the keys are the mathematical <em>inverse</em> of each other; which means you can encrypt data with either the public or private key, and only the alternating key can be used to decrypt the data. So if you encrypted a plaintext using your public key, then the only way you can decrypt the resulting cipher is by using your private key. But imagine you encrypted a file using your public key: as your private key is something only <em>you</em> have access to it means your cipher is safe from everyone! (as long as your private key stays private)</p>

<p>Now that we have a basic understanding of public-key cryptography, you should be able to see how this can be used to keep our ciphers safe from being decrypted by unintended devious type people. So let&#39;s go back to our previous example where we have a plaintext document that we want to encrypt and only share with our friend Bob...</p>

<h3>Public-key example</h3>

<blockquote>
<p>Note: this example is INSECURE and I explain why afterwards</p>
</blockquote>

<p>In this example there are two prerequisites:</p>

<ol>
<li>We&#39;ve generated our own public/private keys</li>
<li>Bob has generated his own public/private keys</li>
</ol>

<p>With a basic understanding of public-key cryptography, the steps involved appear quite straightforward:</p>

<ul>
<li>We email Bob and ask him for his public key</li>
<li>Bob emails us his public key</li>
<li>We encrypt our plaintext using Bob&#39;s public key</li>
<li>We email Bob the cipher created using his public key</li>
<li>Bob receives the cipher and uses his private key to decrypt it</li>
<li>Bob now has a copy of the original plaintext</li>
</ul>

<p>In an ideal world these steps are fine, but we don&#39;t live in an ideal world. Now you may have already noticed the problem with this process, but if not I&#39;ll clarify why this isn&#39;t secure: the devious network sniffer has intercepted your email communication asking Bob for his public key and the devious person sends back his own public key instead. So at this point you get a public key that you think is Bob&#39;s but which actually belongs to the devious person.</p>

<p>Now when you go to send the cipher back to Bob, the devious person sees your communication going across the wire and intercepts it again and grabs the cipher and is able to decrypt it using his private key and subsequently gets access to the plaintext!</p>

<h3>Authentication</h3>

<p>We arrive at yet another security problem with encrypting data, and although using something like public-key cryptography helps it doesn&#39;t solve the issue of &quot;authentication&quot;. By this we mean: how to do we know the person we&#39;re communicating with is really who they say they are?</p>

<p>You might think for everyone to securely identify themselves they could publish their public keys online. This would mean instead of people having to provide you with their public key via an insecure communication channel, they could point you to a secure location where their public key resides. This is where a service such as <a href="https://keybase.io/">https://keybase.io/</a> comes in (this is still in preview). There are also more traditional services that you can use, such as: <a href="http://keyserver.ubuntu.com:11371/">keyserver.ubuntu.com</a>, <a href="http://pgp.mit.edu/">pgp.mit.edu</a> and <a href="https://keyserver.pgp.com/vkd/GetWelcomeScreen.event">keyserver.pgp.com</a></p>

<blockquote>
<p>Note: You can access my public key here: <a href="https://keybase.io/integralist">keybase.io/integralist</a></p>
</blockquote>

<p>But unless you&#39;re talking (in real-life or over the phone) with the actual person you want to communicate with, then how do you <em>really</em> know who published the key was the person you think it is? Authenticating people is a difficult problem to solve and this is where PKI (Public-key infrastructure) comes in.</p>

<div id="3"></div>

<h2>Understanding PKI</h2>

<p>Public key infrastructure is built on top of Public-key cryptography. The difference is that PKI introduces the concept of &quot;certificates&quot;, and these certificates are used in the software realm much like we would use a passport.</p>

<p>In the real world, the government is a trusted authority (ok so maybe that&#39;s questionable nowadays, but go along with it please...) and they issue you a passport which contains details and information that uniquely identifies you. In the digital world, a certificate does much the same thing.</p>

<p>Now at this point it&#39;s worth pointing out that certificates are designed to identify websites rather than people and so PKI is built on the premise that you are communicating with a domain/web server. They don&#39;t really help us with regards to the problem we had earlier with transferring a cipher securely (I&#39;ll come back to that issue later).</p>

<blockquote>
<p>Note: technically certificates are created using the <a href="https://en.wikipedia.org/wiki/X.509">X.509 standard</a></p>
</blockquote>

<p>What PKI can do is help verify the communication between you (e.g. your web browser) and another website is handled securely and is happening with the correct/relevant endpoint. This is useful because if you&#39;re doing some online banking, you want to be sure that communication between you and the bank are happening privately/securely without anyone being able to sniff your information over the wire. But also, you want to be sure you&#39;re communicating with your bank and not some devious endpoint <em>pretending</em> to be your bank but in fact is getting you to type in your account and password details.</p>

<p>The way that PKI manages the ability to authenticate an endpoint (i.e. some website/service you&#39;re communicating with) is through the use of certificates. When you visit a website you&#39;ll use either the http or https protocols. The latter is what signifies a secure connection. When using https, if the website has a valid certificate, then your browser knows that the communication is happening with the right website.</p>

<p>So how can you trust a certificate? Surely someone can set up a website that looks like your bank, then create a certificate and associate it with their website domain? Yes this is possible; but the idea of PKI is that it is built upon a &quot;web of trust&quot;. Let me clarify what that means...</p>

<h3>Certificate Authorities (CAs)</h3>

<p>Your web browser has a list of organisations it <em>trusts</em> (known as a &quot;CA&quot; or &quot;Certificate Authority&quot;), and these organisations can issue certificates.</p>

<p>If a website uses a certificate that has not been issued (i.e. &quot;signed&quot;) by one of these trusted CAs, then your web browser will display a warning that you probably shouldn&#39;t continue on to the website as it doesn&#39;t appear to be who it says it is (i.e. the website <em>could</em> be who they say they are - your bank - but we can&#39;t really trust them because the certificate they&#39;ve presented to us wasn&#39;t issued by a CA we know of).</p>

<blockquote>
<p>Note: certificates are created and then &quot;signed&quot; using an encrypted signature. This is done using the CAs private key. Because the CAs public key is, well... public, it means our browser can use the public key to verify that the certificate it is presented by a website was indeed issued by a CA we trust and wasn&#39;t created by some devious person/organisation instead</p>
</blockquote>

<p>So where do these trusted organisations come from? Well as you can imagine, there is a very high cost and detailed process involved with becoming an authorised CA. This is because we have to implicitly trust them to look after our best interests (and only issue certificates to companies/organisations who have proved their true identity through the CAs own rigorous registration process).</p>

<h3>Intermediate CAs</h3>

<p>Now CAs will sometimes create &quot;intermediate&quot; CAs. These are organisations who can issue certificates on behalf of the original CA (also known as the &quot;Root CA&quot;). If you go to a website that has a certificate, you can inspect the certificate to verify whether it was issued by a root CA or by an intermediate CA. If the certificate came from an intermediate CA, then you can follow the thread back to the root (the web browser typically handles this verification check for you).</p>

<p>One of the reasons this is done is because the root CA is very very important. It has the power to issue certificates and so if the private key ever fell into the wrong hands, then it could be used to generate certificates for all sorts of domains/websites that weren&#39;t who they claimed to be.</p>

<p>In the real world, once a root CA is set-up, the private key is stored offline. For example, the hard drive the private key is stored on is extracted from the computer and stored in a fire safe (even input ports are filled with glue, preventing someone from stealing the drive and trying to extract the data). Serious business this CA stuff!</p>

<h3>Certificate Revocation List (CRLs)</h3>

<p>Certificates are issued with a validity period (expiration date). Every time your browser interrogates a site&#39;s certificate, it is checking the certs validity period. If the date for the validity period has passed, then the browser will warn you that the certificate is now expired.</p>

<p>At the same time though, if the certificate hasn&#39;t expired, then your browser will consult its Certificate Revocation List to see if the certificate has been revoked. This CRL is downloaded by your browser/operating system on a regular basis and there in lies the problem with CRLs: they&#39;re not real-time results.</p>

<p>Imagine a certificate was issued for the website <code>www.foo.com</code>, but later needed to be revoked (for whatever nefarious reason). In this scenario the CRL is updated to state the website <code>www.foo.com</code> has a revoked certificate and so it cannot be trusted. But because the CRL has to be downloaded in order to see the updated list, the user (you) could end up visiting the website before you had the new CRL and so the certificate would still be seen to be valid.</p>

<p>Because of the lack of real-time validation checking, the Online Certificate Status Protocol (OCSP) has superseded CRLs in that it is (as the name would suggest) an online resource which systems can query at run-time to verify the validity of a certificate.</p>

<h3>SSL and TLS</h3>

<p>So far we&#39;ve been talking about certificates being the solution to how we can authenticate a server&#39;s identity, and PKI as the overarching process for helping us to secure that communication (using public-key cryptography under the covers).</p>

<p>To help PKI achieve its goals, a cryptographic protocol was designed called SSL (Secure Socket Layers). This protocol was subsequently superseded by a new protocol called TLS (Transport Layer Security). PKI uses these protocols to enable the secure communication.</p>

<blockquote>
<p>Note: you might wonder why you don&#39;t hear the phrase TLS used much, and instead see SSL referenced everywhere on the internet when talking about PKI security? This is just an unfortunate case of SSL having become a marketing term that most people can recognise and understand. The majority of the time if someone mentions they have SSL enabled, then what they probably really mean is that they&#39;re using the TLS protocol</p>
</blockquote>

<h3>SSL handshake (Cipher Suites and Key Exchanges)</h3>

<p>In order to secure the communication between the client and the server, PKI uses the stages defined within its protocol to fufil what&#39;s commonly referred to as the &quot;SSL handshake&quot;. This is a set of communicative steps taken between the client (your web browser) and the server.</p>

<p>Remember from earlier we discussed how public-key cryptography works and that with it we can secure the communication channel; but at this point we&#39;re still not sure how that happens without exposing the encryption key (necessary to encrypt our data back and forth across the wire) to any devious people sniffing our network traffic.</p>

<p>As we&#39;ll see in a moment, one of the steps in the SSL handshake is called the &quot;key exchange&quot;; this exchange between the client/server is for the encryption key, and is done using a public-key cryptography algorithm. The most popular choice (at the time of writing) is the <a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA algorithm</a>, which uses the server&#39;s public key (provided in the certificate the server sends to the client) to encrypt the key before sending it to the server.</p>

<blockquote>
<p>Note: if you&#39;re using the <a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange">Diffie–Hellman key exchange algorithm</a> you&#39;ll find a great visual explanation of the process which uses the analogy of &quot;mixing colours&quot; to indicate the maths behind the equation (e.g. easy to calculate in one direction, but very difficult to reverse; much like mixing two colours together is easy, but unmixing would be quite arduous). There are also performance penalties associated with some more advanced key exchange algorithms that you need to take into consideration</p>
</blockquote>

<p>In order for the SSL handshake to proceed successfully, the client needs to provide the server with some preliminary options; one being a &quot;cipher suite&quot;. A cipher suite has a structure that looks something like the following:</p>

<pre><code class="language-ini">TLS_RSA_WITH_AES_128_CBC_SHA
</code></pre>

<p>This might just look like a jumble of acronyms, so let&#39;s break down what this means:</p>

<pre><code class="language-ini">TLS: the protocol
RSA: the key exchange algorithm
AES: the encryption algorithm
128: the encryption strength
CBC: the encryption mode
SHA: the hash function for a digital signature
</code></pre>

<p>In the above example, we use <code>RSA</code> which is interpreted as <em>both</em> the key exchange algorithm AND the authentication mechanism. But with other cipher suites you&#39;ll see two separate values (e.g. <code>DHE_RSA</code> where <code>DHE</code> is the key exchange and <code>RSA</code> is the authentication mechanism).</p>

<p>The client supports various different cipher suites and so it&#39;ll send all of the different variations it is happy to handle, while the server&#39;s job is to find the most secure match and respond to confirm the cipher suite it has selected.</p>

<blockquote>
<p>Note: cipher suites are just one (of many) areas of communication open to a MITM (man-in-the-middle) attack. For example, a devious network sniffer intercepts your initial insecure communication with a server and removes all the cipher suites leaving only the weakest one. The server has no option but to select the one and only cipher suite left, meaning the attacker has an easier time brute forcing through the weaker encryption methods</p>
</blockquote>

<p>One other item we&#39;ll want to be aware of is what&#39;s called a MAC (<a href="https://en.wikipedia.org/wiki/Message_authentication_code">Message Authentication Code</a>). The MAC is a way of ensuring authentication and integrity by combining an agreed key and a hashing cipher to create a signature for some content. If we send some data we&#39;ll also send a MAC with it and because both sides have the key/cipher information we can ensure the message content hasn&#39;t been tampered with. We&#39;ll see in just a moment that one of our handshake steps will be for the client/server to verify each other using a MAC.</p>

<p>Let&#39;s take a quick look at the SSL handshake (this isn&#39;t exhaustive, and I&#39;ve left out lots of steps for brevity):</p>

<ul>
<li>Client sends cipher suite, a random number, a protocol version and list of compression methods</li>
<li>Server sends back a selected cipher suite (most secure match), a random number, the protocol version it supports and a selected compression method</li>
<li>Client requests certificate for identification **</li>
<li>Server sends its certificate</li>
<li>Client sends a &quot;premaster secret&quot; encrypted using the key exchange algorithm defined in the selected cipher suite</li>
<li>Server decrypts the premaster secret</li>
<li>Both client/server can generate a &quot;master secret&quot; using both sets of random numbers previously sent to each other</li>
<li>Client/Server uses the master secret to derive the encryption keys used to encrypt all future communication</li>
<li>Client sends a MAC of the communication so far</li>
<li>Server creates a MAC and compares with Client MAC (if the same then Server switches to encryption)</li>
<li>Server tells the client it&#39;s ready for secure messages</li>
<li>Client sends secure mesage(s)</li>
</ul>

<h3>Example messages</h3>

<p>In the previous sub section I briefly ran through the different steps the client and server take in order to communicate securely with each other. But I&#39;d like to add onto that some <em>examples</em> of these messages.</p>

<blockquote>
<p>Note: these examples are copied verbatim from the excellent book &quot;Bulletproof SSL and TLS&quot; written by Ivan Ristić</p>
</blockquote>

<p>Here is the first example, this is the client opening communication with the server:</p>

<pre><code class="language-ini">Handshake protocol: ClientHello
    Version: TLS 1.2
    Random
        Client time: May 22, 2030 02:43:46 GMT
        Random bytes: b76b0e61829557eb4c611adfd2d36eb232dc1332fe29802e321ee871
    Session ID: (empty)
    Cipher Suites
        Suite: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256”
        Suite: TLS_DHE_RSA_WITH_AES_128_GCM_SHA256
        Suite: TLS_RSA_WITH_AES_128_GCM_SHA256
        Suite: TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA
        Suite: TLS_DHE_RSA_WITH_AES_128_CBC_SHA
        Suite: TLS_RSA_WITH_AES_128_CBC_SHA
        Suite: TLS_RSA_WITH_3DES_EDE_CBC_SHA
        Suite: TLS_RSA_WITH_RC4_128_SHA
    Compression methods
        Method: null
    Extensions
        Extension: server_name
            Hostname: www.feistyduck.com
        Extension: renegotiation_info
        Extension: elliptic_curves
            Named curve: secp256r1
            Named curve: secp384r1
        Extension: signature_algorithms
            Algorithm: sha1/rsa
            Algorithm: sha256/rsa
            Algorithm: sha1/ecdsa
            Algorithm: sha256/ecdsa”
</code></pre>

<p>As you can see, all the ingredients are there as we described earlier; the cipher suite being the most important to take note of at this time. Let&#39;s move on and see what the server&#39;s response would typically look like:</p>

<pre><code class="language-ini">Handshake protocol: ServerHello
    Version: TLS 1.2
    Random
        Server time: Mar 10, 2059 02:35:57 GMT”
        Random bytes: 8469b09b480c1978182ce1b59290487609f41132312ca22aacaf5012
    Session ID: 4cae75c91cf5adf55f93c9fb5dd36d19903b1182029af3d527b7a42ef1c32c80
    Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
    Compression method: null
    Extensions
        Extension: server_name
        Extension: renegotiation_info”
</code></pre>

<p>Here we can see the server has sent back its random data (used to construct the premaster secret) and also we can see which cipher suite it has selected to be used.</p>

<h3>Verify SSL</h3>

<p>Sometimes you might need to debug an issue with your SSL connection. In order to do that you&#39;ll want to utilise the OpenSSL utility command <code>s_client</code>. This will allow you to open a connection to your host using the SSL/TLS protocol of your choice and control the various different configuration settins.</p>

<p>A basic example would be as follows:</p>

<pre><code class="language-bash">openssl s_client -connect google.com:443 -showcerts
</code></pre>

<p>You&#39;ll see we&#39;re connecting to Google (which is secured using SSL/TLS) and we also specify the <code>-showcerts</code> flag, which allows the response to display all certificates provided within the chain.</p>

<p>The response looks something like the following:</p>

<pre><code class="language-bash">CONNECTED(00000003)
depth=2 /C=US/O=GeoTrust Inc./CN=GeoTrust Global CA
verify error:num=20:unable to get local issuer certificate
verify return:0
---
Certificate chain
 0 s:/C=US/ST=California/L=Mountain View/O=Google Inc/CN=*.google.com
   i:/C=US/O=Google Inc/CN=Google Internet Authority G2
-----BEGIN CERTIFICATE-----
MIIHjTCCBnWgAwIBAgIIGo+tp3jIDvEwDQYJKoZIhvcNAQELBQAwSTELMAkGA1UE
BhMCVVMxEzARBgNVBAoTCkdvb2dsZSBJbmMxJTAjBgNVBAMTHEdvb2dsZSBJbnRl
cm5ldCBBdXRob3JpdHkgRzIwHhcNMTUxMDE1MTY0MTE2WhcNMTYwMTEzMDAwMDAw
WjBmMQswCQYDVQQGEwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwN
TW91bnRhaW4gVmlldzETMBEGA1UECgwKR29vZ2xlIEluYzEVMBMGA1UEAwwMKi5n
b29nbGUuY29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEApCZxkmtf
Au04O0RjThQnFAzC27w9VlfAoQrgqPtarJIvQDw4G8NZEUSWIlPr0nGr5z3CicxY
ddO2+U8vz/aEltcIUDqNNsdordbLLl7zBS2zkDnSZEmJcM5wYM8biJ3FSU3WzRmN
o8px1LCj49dpQButCJ7FCDIU3eaxZRYZaEiO2UCR7BT8wdyE9O49YKcDUycTgaNu
pM5oTFPqqj+3mDLZsB8BjIssboE8dutdU0TTY4SJ3EPFsSeVTOFu7WY+s628hwMw
kw5sy9viYUZf11RL0zleKarvdQ+oE6gK59ilknrrRXONpepKX6cBGwF/cF+Xl4y4
tjvbvWfNETvmPQIDAQABo4IEWjCCBFYwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsG
AQUFBwMCMIIDJgYDVR0RBIIDHTCCAxmCDCouZ29vZ2xlLmNvbYINKi5hbmRyb2lk
LmNvbYIWKi5hcHBlbmdpbmUuZ29vZ2xlLmNvbYISKi5jbG91ZC5nb29nbGUuY29t
ghYqLmdvb2dsZS1hbmFseXRpY3MuY29tggsqLmdvb2dsZS5jYYILKi5nb29nbGUu
Y2yCDiouZ29vZ2xlLmNvLmlugg4qLmdvb2dsZS5jby5qcIIOKi5nb29nbGUuY28u
dWuCDyouZ29vZ2xlLmNvbS5hcoIPKi5nb29nbGUuY29tLmF1gg8qLmdvb2dsZS5j
b20uYnKCDyouZ29vZ2xlLmNvbS5jb4IPKi5nb29nbGUuY29tLm14gg8qLmdvb2ds
ZS5jb20udHKCDyouZ29vZ2xlLmNvbS52boILKi5nb29nbGUuZGWCCyouZ29vZ2xl
LmVzggsqLmdvb2dsZS5mcoILKi5nb29nbGUuaHWCCyouZ29vZ2xlLml0ggsqLmdv
b2dsZS5ubIILKi5nb29nbGUucGyCCyouZ29vZ2xlLnB0ghIqLmdvb2dsZWFkYXBp
cy5jb22CDyouZ29vZ2xlYXBpcy5jboIUKi5nb29nbGVjb21tZXJjZS5jb22CESou
Z29vZ2xldmlkZW8uY29tggwqLmdzdGF0aWMuY26CDSouZ3N0YXRpYy5jb22CCiou
Z3Z0MS5jb22CCiouZ3Z0Mi5jb22CFCoubWV0cmljLmdzdGF0aWMuY29tggwqLnVy
Y2hpbi5jb22CECoudXJsLmdvb2dsZS5jb22CFioueW91dHViZS1ub2Nvb2tpZS5j
b22CDSoueW91dHViZS5jb22CFioueW91dHViZWVkdWNhdGlvbi5jb22CCyoueXRp
bWcuY29tggthbmRyb2lkLmNvbYIEZy5jb4IGZ29vLmdsghRnb29nbGUtYW5hbHl0
aWNzLmNvbYIKZ29vZ2xlLmNvbYISZ29vZ2xlY29tbWVyY2UuY29tggp1cmNoaW4u
Y29tggh5b3V0dS5iZYILeW91dHViZS5jb22CFHlvdXR1YmVlZHVjYXRpb24uY29t
MGgGCCsGAQUFBwEBBFwwWjArBggrBgEFBQcwAoYfaHR0cDovL3BraS5nb29nbGUu
Y29tL0dJQUcyLmNydDArBggrBgEFBQcwAYYfaHR0cDovL2NsaWVudHMxLmdvb2ds
ZS5jb20vb2NzcDAdBgNVHQ4EFgQUpypq8xCS2PlWTuyHYX7xgHb9UgwwDAYDVR0T
AQH/BAIwADAfBgNVHSMEGDAWgBRK3QYWG7z2aLV29YG2u2IaulqBLzAhBgNVHSAE
GjAYMAwGCisGAQQB1nkCBQEwCAYGZ4EMAQICMDAGA1UdHwQpMCcwJaAjoCGGH2h0
dHA6Ly9wa2kuZ29vZ2xlLmNvbS9HSUFHMi5jcmwwDQYJKoZIhvcNAQELBQADggEB
AFRzPPSVNMFRDoePYeOs7awHmRpp79v7loOBMO7ctrTjpfhVjPsQmvzDlfEken2q
HMs/r76I0s7E4hk6v2ZNFiDjSnnHvjIGG1PydfEVovL/FqsX3kUaWqqCeymGcwRC
ld2F6XqgKkPRf00DjbnFmDKGpRyEMQd91HoutzSMSypPqFCNSpVGuPFP32D1+/Vh
oukY3gGUlNGukoJ2e/VNnRrU7NBvyGkW83CGPMR2iwwa0/7aVGs1iy4aypaBo+0q
QxFmxwn1AWJYyhFbsdfrhf3ux8KEQGDEIHOSa9+SjL/GYQENXGfkVIj/OG1KV0CB
K8pC8t/AFLMrBFjS1gbkE7U=
-----END CERTIFICATE-----
 1 s:/C=US/O=Google Inc/CN=Google Internet Authority G2
   i:/C=US/O=GeoTrust Inc./CN=GeoTrust Global CA
-----BEGIN CERTIFICATE-----
MIID8DCCAtigAwIBAgIDAjqDMA0GCSqGSIb3DQEBCwUAMEIxCzAJBgNVBAYTAlVT
MRYwFAYDVQQKEw1HZW9UcnVzdCBJbmMuMRswGQYDVQQDExJHZW9UcnVzdCBHbG9i
YWwgQ0EwHhcNMTMwNDA1MTUxNTU2WhcNMTYxMjMxMjM1OTU5WjBJMQswCQYDVQQG
EwJVUzETMBEGA1UEChMKR29vZ2xlIEluYzElMCMGA1UEAxMcR29vZ2xlIEludGVy
bmV0IEF1dGhvcml0eSBHMjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEB
AJwqBHdc2FCROgajguDYUEi8iT/xGXAaiEZ+4I/F8YnOIe5a/mENtzJEiaB0C1NP
VaTOgmKV7utZX8bhBYASxF6UP7xbSDj0U/ck5vuR6RXEz/RTDfRK/J9U3n2+oGtv
h8DQUB8oMANA2ghzUWx//zo8pzcGjr1LEQTrfSTe5vn8MXH7lNVg8y5Kr0LSy+rE
ahqyzFPdFUuLH8gZYR/Nnag+YyuENWllhMgZxUYi+FOVvuOAShDGKuy6lyARxzmZ
EASg8GF6lSWMTlJ14rbtCMoU/M4iarNOz0YDl5cDfsCx3nuvRTPPuj5xt970JSXC
DTWJnZ37DhF5iR43xa+OcmkCAwEAAaOB5zCB5DAfBgNVHSMEGDAWgBTAephojYn7
qwVkDBF9qn1luMrMTjAdBgNVHQ4EFgQUSt0GFhu89mi1dvWBtrtiGrpagS8wDgYD
VR0PAQH/BAQDAgEGMC4GCCsGAQUFBwEBBCIwIDAeBggrBgEFBQcwAYYSaHR0cDov
L2cuc3ltY2QuY29tMBIGA1UdEwEB/wQIMAYBAf8CAQAwNQYDVR0fBC4wLDAqoCig
JoYkaHR0cDovL2cuc3ltY2IuY29tL2NybHMvZ3RnbG9iYWwuY3JsMBcGA1UdIAQQ
MA4wDAYKKwYBBAHWeQIFATANBgkqhkiG9w0BAQsFAAOCAQEAqvqpIM1qZ4PtXtR+
3h3Ef+AlBgDFJPupyC1tft6dgmUsgWM0Zj7pUsIItMsv91+ZOmqcUHqFBYx90SpI
hNMJbHzCzTWf84LuUt5oX+QAihcglvcpjZpNy6jehsgNb1aHA30DP9z6eX0hGfnI
Oi9RdozHQZJxjyXON/hKTAAj78Q1EK7gI4BzfE00LshukNYQHpmEcxpw8u1VDu4X
Bupn7jLrLN1nBz/2i8Jw3lsA5rsb0zYaImxssDVCbJAJPZPpZAkiDoUGn8JzIdPm
X4DkjYUiOnMDsWCOrmji9D6X52ASCWg23jrW4kOVWzeBkoEfu43XrVJkFleW2V40
fsg12A==
-----END CERTIFICATE-----
 2 s:/C=US/O=GeoTrust Inc./CN=GeoTrust Global CA
   i:/C=US/O=Equifax/OU=Equifax Secure Certificate Authority
-----BEGIN CERTIFICATE-----
MIIDfTCCAuagAwIBAgIDErvmMA0GCSqGSIb3DQEBBQUAME4xCzAJBgNVBAYTAlVT
MRAwDgYDVQQKEwdFcXVpZmF4MS0wKwYDVQQLEyRFcXVpZmF4IFNlY3VyZSBDZXJ0
aWZpY2F0ZSBBdXRob3JpdHkwHhcNMDIwNTIxMDQwMDAwWhcNMTgwODIxMDQwMDAw
WjBCMQswCQYDVQQGEwJVUzEWMBQGA1UEChMNR2VvVHJ1c3QgSW5jLjEbMBkGA1UE
AxMSR2VvVHJ1c3QgR2xvYmFsIENBMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB
CgKCAQEA2swYYzD99BcjGlZ+W988bDjkcbd4kdS8odhM+KhDtgPpTSEHCIjaWC9m
OSm9BXiLnTjoBbdqfnGk5sRgprDvgOSJKA+eJdbtg/OtppHHmMlCGDUUna2YRpIu
T8rxh0PBFpVXLVDviS2Aelet8u5fa9IAjbkU+BQVNdnARqN7csiRv8lVK83Qlz6c
JmTM386DGXHKTubU1XupGc1V3sjs0l44U+VcT4wt/lAjNvxm5suOpDkZALeVAjmR
Cw7+OC7RHQWa9k0+bw8HHa8sHo9gOeL6NlMTOdReJivbPagUvTLrGAMoUgRx5asz
PeE4uwc2hGKceeoWMPRfwCvocWvk+QIDAQABo4HwMIHtMB8GA1UdIwQYMBaAFEjm
aPkr0rKV10fYIyAQTzOYkJ/UMB0GA1UdDgQWBBTAephojYn7qwVkDBF9qn1luMrM
TjAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIBBjA6BgNVHR8EMzAxMC+g
LaArhilodHRwOi8vY3JsLmdlb3RydXN0LmNvbS9jcmxzL3NlY3VyZWNhLmNybDBO
BgNVHSAERzBFMEMGBFUdIAAwOzA5BggrBgEFBQcCARYtaHR0cHM6Ly93d3cuZ2Vv
dHJ1c3QuY29tL3Jlc291cmNlcy9yZXBvc2l0b3J5MA0GCSqGSIb3DQEBBQUAA4GB
AHbhEm5OSxYShjAGsoEIz/AIx8dxfmbuwu3UOx//8PDITtZDOLC5MH0Y0FWDomrL
NhGc6Ehmo21/uBPUR/6LWlxz/K7ZGzIZOKuXNBSqltLroxwUCEm2u+WR74M26x1W
b8ravHNjkOR/ez4iyz0H7V84dJzjA1BOoa+Y7mHyhD8S
-----END CERTIFICATE-----
---
Server certificate
subject=/C=US/ST=California/L=Mountain View/O=Google Inc/CN=*.google.com
issuer=/C=US/O=Google Inc/CN=Google Internet Authority G2
---
No client certificate CA names sent
---
SSL handshake has read 4021 bytes and written 456 bytes
---
New, TLSv1/SSLv3, Cipher is AES128-SHA
Server public key is 2048 bit
Secure Renegotiation IS supported
Compression: NONE
Expansion: NONE
SSL-Session:
    Protocol  : TLSv1
    Cipher    : AES128-SHA
    Session-ID: C9BC3D21CD96713FA4EA7C21D60FF2F5DDBC6C2D2C68543652E9790C7A98DC58
    Session-ID-ctx: 
    Master-Key: AE3A9EBD53ED49E4FDAABBCF6EA3B4096D9248127BC056CFB1F8981F2A3AB4E8779DC8195241A9A3A25DB03EDAED6077
    Key-Arg   : None
    Start Time: 1445868754
    Timeout   : 300 (sec)
    Verify return code: 0 (ok)
---
</code></pre>

<p>What might not be clear at this point is you&#39;re still sitting in an interactive mode within the shell and so you can issue additional requests like so:</p>

<pre><code class="language-bash">HEAD / HTTP/1.0
Host: www.google.com
</code></pre>

<blockquote>
<p>Note: remember to press <code>&lt;Enter&gt;</code> twice to send the request</p>
</blockquote>

<p>The above sends a request for just the headers for the specified host, and so the response looks something like the following:</p>

<pre><code class="language-bash">HTTP/1.0 302 Found
Cache-Control: private
Content-Type: text/html; charset=UTF-8
Location: https://www.google.co.uk/?gfe_rd=cr&amp;ei=wzUuVtGjLLDj8wek176wCQ
Content-Length: 262
Date: Mon, 26 Oct 2015 14:16:35 GMT
Server: GFE/2.0
Alternate-Protocol: 443:quic,p=1
Alt-Svc: quic=&quot;www.google.com:443&quot;; p=&quot;1&quot;; ma=600,quic=&quot;:443&quot;; p=&quot;1&quot;; ma=600
</code></pre>

<p>The following is another example (a non-working example unfortunately), but this time the service we&#39;re querying is utilising self-signed certificates, and so we&#39;re required to provide the CA as well as our own client certificate for authentication:</p>

<pre><code class="language-bash">openssl s_client \
  -connect my-fake-service.com:443 \
  -CAfile /Users/Integralist/.pki/custom-ca.pem \
  -cert /Users/Integralist/.pki/Certificate.pem \
  -key /Users/Integralist/.pki/Certificate.key \
  -showcerts
</code></pre>

<p>The last example I want to show you is where we try and verify if a particular cipher is disabled (in this case the insecure <code>RC4</code> cipher):</p>

<pre><code class="language-bash">openssl s_client -connect blog.mozilla.org:443 -showcerts -cipher RC4-SHA
</code></pre>

<p>Mozilla released a <a href="https://blog.mozilla.org/security/2015/09/11/deprecating-the-rc4-cipher/">blog post</a> recently that stated they&#39;ve discontinued support for this particular cipher. So the above command will return the following output, which indicates a <code>SSL handshake failure</code>:</p>

<pre><code class="language-bash">57533:error:14077410:SSL routines:SSL23_GET_SERVER_HELLO:sslv3 alert handshake failure:/BuildRoot/Library/Caches/com.apple.xbs/Sources/OpenSSL098/OpenSSL098-59/src/ssl/s23_clnt.c:593:
</code></pre>

<h3>Certificate signature</h3>

<p>One way the client and server can authenticate each other&#39;s identities is via the MAC they send during the SSL handshake. But the client first verifies the server&#39;s identity by checking the certificate provided by the server (also done at the very beginning of the SSL handshake) has not only been signed by a CA we trust, but has also not been modified at any point along the way from the server to the client.</p>

<p>The client can do this by inspecting the signature on the certificate. Earlier when we discussed how CAs generate certificates, we mentioned that the CA will &quot;sign&quot; the certificate. The signature is result of applying a <a href="https://en.wikipedia.org/wiki/Hash_function">hash function</a> to the contents of the certificate itself and then encrypting that hash value using the CAs private key.</p>

<p>The reason this technique works is because if a devious network sniffer tried to replace the certificate with their own modified version, then the client would be able to tell; and the reason the client can tell the certificate has been tampered with is because the client can verify the certificate by converting it into a hash using the same hash function as the CA used when creating its signature (details of the hashing algorithm are part of the certificate). The client can then decrypt the CAs signature (using the CAs public key) which results in the hash value. The client then compares the two hashes (the one it extracted from the signature, and the one it generated itself from the certificate content) to make sure they match. If they don&#39;t match, then we know the certificate has been modified at some point and cannot be trusted.</p>

<h3>PKI Conclusion</h3>

<p>So there you have it, that&#39;s pretty much how PKI (and subsequently SSL/TLS) works; although presented in a stripped down way to make this post even remotely bearable to any sane person.</p>

<p>Let&#39;s move on!</p>

<div id="4"></div>

<h2>OpenSSL vs OpenSSH</h2>

<p>If you want to generate your own keys and certificates, which will enable you to connect and transmit data more securely across the internet; then you&#39;re going to need to install the <a href="https://openssl.org/">OpenSSL</a> command line toolkit. OpenSSL is a library designed to implement the SSL/TLS protocols</p>

<blockquote>
<p>Note: the <code>openssl</code> command is a wrapper around the OpenSSL library</p>
</blockquote>

<p>What you might not be aware of though is how large a suite of cryptographic tools OpenSSL actually provides. Later on in this post we&#39;ll demonstrate a tiny selection of these tools in order to create our own keys and encrypt some data; but for now we&#39;ll focus more on the differences between OpenSSL and OpenSSH.</p>

<p>So where OpenSSL is designed to provide a method for securing web based communication; <a href="http://www.openssh.com/">OpenSSH</a> on the other hand provides secure and encrypted tunneling capabilities. It is typically used to enable secure shell connections from your machine to external servers.</p>

<p>OpenSSH has a different transport protocol compared to OpenSSL. Although OpenSSH does actually utilise OpenSSL for its cryptographic operations, such as key pair generation. So as long as you&#39;re using the same algorithms for generating keys you&#39;ll find no difference between OpenSSH and OpenSSL&#39;s level of security in that sense (although there is a larger attack vector with regards to OpenSSH so you could argue it&#39;s <em>potentially</em> more open to security concerns as attackers have more options available to them).</p>

<blockquote>
<p>Note: the suite of command line tools people typically associate with OpenSSH are actually commands designed <em>around</em> the OpenSSH protocol standard (i.e. there isn&#39;t an actual <code>openssh</code> command; and as such, OpenSSH is just the &#39;protocol&#39; and <em>not</em> the command line tools themselves)</p>
</blockquote>

<h3>OpenSSH utilities</h3>

<p>There are a few different tools available within OpenSSH and although (later on in the section where we learn how to generate our own keys) we&#39;ll be using the command line tools, we&#39;ll primarily be focusing on the <code>ssh-keygen</code> command along with demonstrating how I use <code>ssh-agent</code> and <code>ssh-add</code> to make working with OpenSSH a little easier.</p>

<p>Below are a list of tools that are built upon the OpenSSH protocol:</p>

<ul>
<li><code>ssh-keygen</code></li>
<li><code>ssh-agent</code></li>
<li><code>ssh-add</code></li>
<li><code>ssh-keysign</code></li>
<li><code>ssh-keyscan</code></li>
<li><code>sftp-server</code></li>
<li><code>sshd</code></li>
</ul>

<div id="5"></div>

<h2>What is GPG?</h2>

<p><a href="https://gnupg.org/">GPG</a> is a tool which provides encryption and signing capabilities. Its full name is &quot;GNU Privacy Guard&quot;.</p>

<p>GPG supports both symmetrical and asymmetrical encryption techniques along with an optional digital signing of your encrypted content to ensure integrity.</p>

<p>In the next section &quot;<a href="#6">Creating your own keys</a>&quot; I&#39;ll demonstrate how to actually use GPG.</p>

<h3>GPG vs PGP</h3>

<p>You may have also heard of PGP and wondered what the differences are between that and GPG: PGP is the protocol standard (defined under the name &quot;Open PGP&quot;) which GPG implements. So PGP isn&#39;t a tool itself, but merely a specification for other tools (such as GPG) to build upon.</p>

<div id="6"></div>

<h2>Creating your own keys</h2>

<p>OK, up until this point we&#39;ve only been talking in a theorectical sense. Time to see some pratical use cases by demonstrating how to generate your own keys using the three different toolkits we&#39;ve described up until this point (OpenSSH, OpenSSL and GPG).</p>

<p>I&#39;m going to quickly run through each utility (OpenSSH, OpenSSL and GPG) and explain how you can create your own keys for each of them. I wont go into great detail the flags/settings used in each example command as that is what the <code>man</code> command is for (i.e. I&#39;ll leave investigation of these settings as an exercise for the reader).</p>

<p>Also, generating keys is one thing. But for the OpenSSL and GPG utilities, it&#39;s not until we need to actually encrypt some data (see the next section &quot;<a href="#7">How to encrypt data using GPG, OpenSSL and Keybase</a>&quot;) that these keys can become useful (OpenSSH is another beast altogether).</p>

<p>So let&#39;s begin...</p>

<h3>OpenSSH</h3>

<p>In the following example we&#39;re generating a new set of keys (public and private) using the RSA type and using 4096 bits for the key length. This is considered quite a secure set-up (anything less than 2048 bits is easily crackable in todays digital age):</p>

<pre><code class="language-bash">ssh-keygen -t rsa -b 4096 -C &quot;your.email@service.com&quot;
</code></pre>

<p>Running this command you&#39;ll be asked to provide a name for the keys and an (optional) password. Once this is done you&#39;ll find two files in the current directory (imagine we named the key <code>foo_rsa</code> when prompted):</p>

<ol>
<li><code>foo_rsa</code>: contains your private key</li>
<li><code>foo_rsa.pub</code>: contains your public key</li>
</ol>

<blockquote>
<p>Note: you can change the passphrase associated with your private key by running <code>ssh-keygen -p</code></p>
</blockquote>

<p>Now we have these keys, we can provide our public key to an external service such as <a href="https://help.github.com/articles/generating-ssh-keys/">GitHub</a> or have them installed on a remote server. Either way this will allow us to connect our shell securely to these remote services/servers.</p>

<p>In the case of connecting to a remote server, you would have your devops or operations people add your public key into a <code>~/.ssh/authorized_keys</code> file (or you could do it yourself: <code>cat foo_rsa.pub | ssh user@123.45.56.78 &quot;mkdir -p ~/.ssh &amp;&amp; cat &gt;&gt; ~/.ssh/authorized_keys&quot;</code>). Once your public key is added you&#39;ll be able to securely connect to the server without requiring your password because your private key will be used to authenticate your access.</p>

<blockquote>
<p>Note: convention is for SSH keys to be placed inside a <code>~/.ssh</code> folder</p>
</blockquote>

<p>One final change that can be made on your remote server (again, this could be handled by your devops or operations team) is to restrict logins to your server to <em>only</em> happen via SSH keys. To do this you need to log into the server and change the file <code>/etc/ssh/sshd_config</code> by locating the line that specifies <code>PermitRootLogin</code> and changing its value like so: <code>PermitRootLogin without-password</code>. From there you would run <code>reload ssh</code> for the changes to take immediate effect.</p>

<h4>SSH Agent</h4>

<p>Most operating systems have <code>ssh-agent</code> available. If you&#39;ve got <code>ssh-keygen</code> installed, then chances are you&#39;ll have the agent and other OpenSSH tools as well. The agent is used to store private keys used for public key authentication. It makes using SSH easier (a trade-off of security for convenience) by allowing you to specify your private key password once.</p>

<p>When I&#39;m setting up my SSH keys for using GitHub I&#39;ll typically run the following commands:</p>

<pre><code class="language-bash">cd ~/.ssh
ssh-keygen -t rsa -b 4096 -C &quot;my.email@domain.com&quot; # saved as github_rsa
eval &quot;$(ssh-agent -s)&quot;
ssh-add -K ~/.ssh/github_rsa
pbcopy &lt; ~/.ssh/github_rsa.pub
ssh -T git@github.com
</code></pre>

<p>So what&#39;s happening here is:</p>

<ul>
<li>I move into the relevant directory where my SSH keys are located</li>
<li>Generate my SSH keys (saved as <code>github_rsa</code>)</li>
<li>Start the SSH Agent</li>
<li>Use <code>ssh-add</code> to add my private key to the agent</li>
<li>Copy my public key (and manually paste it into the GitHub GUI)</li>
<li>Verify the setup</li>
</ul>

<blockquote>
<p>Note: I also use the <code>-K</code> flag with <code>ssh-add</code> as that&#39;s specific to Mac OS X</p>
</blockquote>

<h3>OpenSSL</h3>

<p>Like with the OpenSSH example in the previous sub section, here we&#39;ll be generating a new set of keys (public and private) using the RSA type and using 4096 bits for the key length. The difference is that you have to generate the private key first and then extract the public key from it:</p>

<pre><code class="language-bash">openssl genrsa -out private_key.pem 4096
openssl rsa -pubout -in private_key.pem -out public_key.pem
</code></pre>

<p>You can also print out some additional details contained inside your pem file by using the <code>-text</code> flag:</p>

<pre><code class="language-bash">openssl rsa -text -in private_key.pem
</code></pre>

<h3>GPG</h3>

<p>Generating a key pair with GPG is a little bit more involved as you have some prompts you need to step through. The command to begin with is:</p>

<pre><code class="language-bash">gpg --gen-key
</code></pre>

<p>This will present the following information:</p>

<pre><code class="language-bash">Please select what kind of key you want:
(1) RSA and RSA (default)
(2) DSA and Elgamal
(3) DSA (sign only)
(4) RSA (sign only)
Your selection? 
</code></pre>

<p>You&#39;ll then be asked the key length (I entered 4096 to match other keys I&#39;ve created):</p>

<pre><code class="language-bash">RSA keys may be between 1024 and 4096 bits long.
What keysize do you want? (2048) 
</code></pre>

<p>After this you&#39;ll be asked to provide an expiration date (I picked 1 year):</p>

<pre><code class="language-bash">Requested keysize is 4096 bits       
Please specify how long the key should be valid.
         0 = key does not expire
      &lt;n&gt;  = key expires in n days
      &lt;n&gt;w = key expires in n weeks
      &lt;n&gt;m = key expires in n months
      &lt;n&gt;y = key expires in n years
Key is valid for? (0)
</code></pre>

<p>Finally, you&#39;ll need to input some personal details. I wont add those here, I&#39;ll just let you fill those in as needed. It&#39;s also worth being aware that GPG will use your system&#39;s <a href="https://en.wikipedia.org/wiki/Entropy_(computing)">entropy</a> to aid its random number generation, so for a brief moment you&#39;ll see it request that you move your cursor around a bit to help build up the entrophy output.</p>

<blockquote>
<p>Note: you could also provide all these details via an &#39;input&#39; file (useful if you find yourself generating lots of key pairs), but that&#39;s a bit outside the scope of what we want to focus on here. If you&#39;re interested, you can find the <a href="https://www.gnupg.org/documentation/manuals/gnupg/Unattended-GPG-key-generation.html">details here</a></p>
</blockquote>

<p>Now before we go any further, it&#39;s important that at this point you now generate a revocation certificate:</p>

<pre><code class="language-bash">gpg --gen-revoke my.email@domain.com
</code></pre>

<p>You&#39;ll want to put this certificate into a file and store it somewhere very safe in case you need to ever revoke your key pair. Preferably you print it out on paper and put it in a fireproof safe.</p>

<p>If you ever need to, you can then import the certificate into your keyring and that will immediately revoke your key pair:</p>

<pre><code class="language-bash">gpg --import revocation.cert
</code></pre>

<p>You can then also push up your key identifier to a key server to force it to recognise the key has been revoked:</p>

<pre><code class="language-bash">gpg --keyserver pgp.mit.edu --send-keys 123456
</code></pre>

<p>Once your key pair has been generated you&#39;ll probably be confused as to where they&#39;re stored? If you were to <code>ls</code> the current directory they wont be there. Instead you&#39;ll need to use the following command to see what public keys you&#39;ve generated:</p>

<pre><code class="language-bash">gpg --list-keys
</code></pre>

<p>For me this displays the following output:</p>

<pre><code class="language-bash">/Users/M/.gnupg/pubring.gpg
---------------------------
pub   4096R/056C9716 2015-08-14 [expires: 2016-08-13]
uid                  Mark McDonnell (Hi) &lt;my.email@domain.com&gt;
sub   4096R/A1F3D5B6 2015-08-14 [expires: 2016-08-13]
</code></pre>

<blockquote>
<p>Note: there is an equivalent command for viewing your private keys <code>gpg --list-secret-keys</code></p>
</blockquote>

<p>You can see there is a file <code>pubring.gpg</code> that appears to contain the details of all the keys I&#39;ve created, and interestingly the file itself is protected; so if I try something like <code>cat ~/.gnupg/pubring.gpg</code> it&#39;ll spew out encrypted cipher text at me.</p>

<p>If you want to see your public key, then use the following command (notice I&#39;ve specified the same name as seen from the above output from <code>--list-keys</code>; if I tried to specify something else then it wouldn&#39;t find any key to export):</p>

<pre><code class="language-bash">gpg --export --armor &quot;Mark McDonnell&quot; &gt; gpg_public.key
</code></pre>

<blockquote>
<p>Note: <code>--armor</code> creates ASCII armored output (a text format) instead of raw bytes</p>
</blockquote>

<p>To get the private key, you&#39;ll use a slightly different flag, but effectively it&#39;s the same thing:</p>

<pre><code class="language-bash">gpg --export-secret-key --armor &quot;Mark McDonnell&quot; &gt; gpg_private.key
</code></pre>

<p>If you have multiple keys under the same name then you&#39;ll find that it&#39;ll typically export the key for the <em>first</em> name it finds. To work around this you can specify the email address instead:</p>

<pre><code class="language-bash">gpg --export --armor my.email@gmail.com
</code></pre>

<blockquote>
<p>Note: by default it prints to stdout</p>
</blockquote>

<p>In the following sections we&#39;ll see more of how to use GPG, but it&#39;s worth mentioning now that all the settings you use in the command line tool can be set as defaults in a dotfile: <code>~/.gnu/gpg.conf</code></p>

<p>For example, if on the command line you used <code>--default-key</code>, then you could set the following within your <code>gpg.conf</code>:</p>

<pre><code class="language-ini">default-key 62DBDF62           # Personal
default-recipient some-user-id # In case you happen to only ever communicate with one person
</code></pre>

<div id="7"></div>

<h2>How to encrypt data using GPG, OpenSSL and Keybase</h2>

<p>Outside of PKI and SSL/TLS, the most common task people are interested in is encrypting specific files that contain sensitive information that they would prefer to be protected either from everyone or allow only a select few people to be able to access. The interface for encrypting data is different for each tool used and so we&#39;ll be looking at those we&#39;ve discussed so far: GPG and OpenSSL</p>

<div id="7.1"></div>

<h3>GPG encryption</h3>

<p>GPG offers two forms of encryption: asymmetrical and symmetrical...</p>

<h4>Asymmetrical encryption</h4>

<p>With GPG you&#39;ll need the recipients public key in order to encrypt files. So once you have the recipients public key you&#39;ll need to import it into GPG so you can reference it. To do that you&#39;ll use the following command:</p>

<pre><code class="language-bash">gpg --import public.key
</code></pre>

<blockquote>
<p>Note: to delete their public key afterwards, run <code>gpg --delete-key &quot;User Name&quot;</code></p>
</blockquote>

<p>Before we continue, let&#39;s just consider a real-world scenario:</p>

<p>Imagine at this point you&#39;re not entirely sure if the public key you&#39;ve been given over the internet is actually from who you were expecting it from (let&#39;s call them &quot;Bob&quot;). Maybe there are some nefarious government types intercepting your communication and the public key you received is theirs and not Bob&#39;s.</p>

<p>You would need to call or find <em>some form</em> of secure communication channel with Bob (or someone who you trust to know bob) to verify the public key really does belong to Bob. But what do you check any way? You could read out the contents of the public key (e.g. <code>cat bobs-public.key</code>) but this would be pain stakingly tedious.</p>

<p>Another way would be to get Bob to give you the shortened &#39;fingerprint&#39; which is derived from his public key. You do that by running the following command and asking Bob if it matches what he&#39;s seeing:</p>

<pre><code class="language-bash">gpg --fingerprint bob@example.org
</code></pre>

<p>This will return something like:</p>

<pre><code class="language-bash">pub   4096R/DD86E7F5 2016-05-24 [expires: 2017-05-24]
      Key fingerprint = FDFB E9B5 24BA 6972 A3AA  44B9 A1B1 7E6F DD86 E7F5
uid                  Mark McDonnell (Personal) &lt;mark.mcdx@gmail.com&gt;
sub   4096R/A3FDEBC6 2016-05-24 [expires: 2017-05-24]
</code></pre>

<p>Notice the <code>Key fingerprint</code> section <code>FDFB E9B5 24BA 6972 A3AA  44B9 A1B1 7E6F DD86 E7F5</code>. That&#39;s what I would read out to someone if they called me to say they wanted to verify the public key they had really did belong to me.</p>

<p>Now, once you have the public key of your recipient you can encrypt a file using it, like so:</p>

<pre><code class="language-bash">gpg --encrypt -u &quot;Sender User Name&quot; -r &quot;Receiver User Name&quot; somefile
</code></pre>

<blockquote>
<p>Note: it can sometimes be better to use the <code>pub</code> identifier number (especially when you have multiple keys with the same email). So if your pub id is <code>1234A/BC56D7E5</code> then you&#39;d use <code>-u BC56D7E5</code></p>
</blockquote>

<p>To decrypt a GPG encrypted file, the person sending you the encrypted file would have used your public key to encrypt the data. So the following command will locate your private key automatically (if you have multiple secret keys it&#39;ll ask for the password):</p>

<pre><code class="language-bash">gpg -d some_encrypted_file.gpg
</code></pre>

<p>In the above example, it&#39;ll display the contents of the file in stdout; so you&#39;ll need to redirect it to a file or alternatively use:</p>

<pre><code class="language-bash">gpg -o output_file -d some_encrypted_file.gpg
</code></pre>

<h4>Symmetrical encryption</h4>

<p>If you don&#39;t want to encrypt a file using your own key pair, you can use standard symmetrical encryption:</p>

<pre><code class="language-bash">gpg --symmetric secrets.txt
</code></pre>

<p>You&#39;ll be asked to enter a passphrase to complete the encryption. Then if you want to decrypt the file you simply run:</p>

<pre><code class="language-bash">gpg secrets.txt.gpg
</code></pre>

<p>It&#39;ll ask for the passphrase and then it&#39;ll extract the file to the current directory.</p>

<p>You can also modify the default cipher encryption algorithm, then use the <code>--cipher-algo</code> flag:</p>

<pre><code class="language-bash">gpg --verbose --cipher-algo AES256 --symmetric secrets.txt
</code></pre>

<blockquote>
<p>Note: use <code>--verbose</code> without <code>--cipher-algo</code> to see GPG&#39;s default algorithm</p>
</blockquote>

<p>To see a list of available cipher algorithms, then execute the following command and look for the section <code>Cipher</code>:</p>

<pre><code class="language-bash">gpg --version
</code></pre>

<p>So for me this outputs:</p>

<pre><code class="language-bash">gpg (GnuPG) 1.4.20
Copyright (C) 2015 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Home: ~/.gnupg
Supported algorithms:
Pubkey: RSA, RSA-E, RSA-S, ELG-E, DSA
Cipher: IDEA, 3DES, CAST5, BLOWFISH, AES, AES192, AES256, TWOFISH,
        CAMELLIA128, CAMELLIA192, CAMELLIA256
Hash: MD5, SHA1, RIPEMD160, SHA256, SHA384, SHA512, SHA224
Compression: Uncompressed, ZIP, ZLIB, BZIP2
</code></pre>

<h4>Key Signing</h4>

<p>GPG let&#39;s you &quot;sign&quot; a key, and which tells GPG you <em>trust</em> this key you have been provided (i.e. you have verified it belongs to who you think it should belong to). To sign a key you&#39;ve imported, simply run the following command and change the email to something relevant:</p>

<pre><code class="language-bash">gpg --sign-key bob@example.org
</code></pre>

<p>The real purpose of this is that if someone else (Alice) sees you&#39;ve &#39;signed&#39; another person&#39;s key (Bob&#39;s), then if Alice trusts you she is more likely to implicitly trust Bob as well. It&#39;s a web of trust.</p>

<p>In order for Bob to benefit from your &#39;trust&#39; you need to send him back the key you&#39;ve signed:</p>

<pre><code class="language-bash">gpg --export --armor bob@example.org
</code></pre>

<p>This will send their public key to <code>stdout</code> along with your signature and so they can run the following command to import the signed data you&#39;ve provided:</p>

<pre><code class="language-bash">gpg --import &lt;file path&gt;
</code></pre>

<h4>Digital Signatures</h4>

<p>You can also add a MAC (remember we looked at this earlier when discussing PKI; this is the digital signature) by adding the <code>--sign</code> flag, which means you&#39;ve used your private key to guarantee the encrypted file has come from you:</p>

<pre><code class="language-bash">gpg --default-key email@domain.com --sign -r bob@example.org secrets.txt
</code></pre>

<blockquote>
<p>Note: I added <code>--default-key &lt;email&gt;</code> because the default key isn&#39;t always the key I want to use for the signature</p>
</blockquote>

<p>We specify the recipient, but you could also add another <code>-r</code> and specify your own email so you&#39;re able to decrypt the data afterwards (this is because the message will otherwise be encrypted using Bob&#39;s public key).</p>

<p>Once the file has been signed (it&#39;ll encrypt the file as well as if you&#39;d used <code>-e</code> or <code>--encrypt</code>, but you can use that flag as well if you prefer), then you can verify the signature using the following:</p>

<pre><code class="language-bash">gpg --verify secrets.txt.gpg
</code></pre>

<p>This will output the following:</p>

<pre><code class="language-bash">gpg: Signature made Mon 17 Aug 17:37:58 2015 BST using RSA key ID BAE1D7F0
gpg: Good signature from &quot;Mark McDonnell (Integralist) &lt;email@domain.com&gt;&quot;
</code></pre>

<p>But if you want to decrypt the file as well, then use the standard <code>gpg secrets.txt.gpg</code></p>

<h4>Revoking Keys</h4>

<p>If you&#39;ve pulled keys from a public server:</p>

<pre><code class="language-bash">gpg --keyserver pgp.mit.edu  --search-keys bob@example.org
</code></pre>

<p>Then you want to regularly check those keys are still valid, and haven&#39;t been compromised:</p>

<pre><code class="language-bash">gpg --refresh-keys
</code></pre>

<blockquote>
<p>Note: you can specify <code>--keyserver</code> when refreshing key data</p>
</blockquote>

<div id="7.2"></div>

<h3>OpenSSL encryption</h3>

<p>The easiest way to encrypt a file using OpenSSL is like so (the password for the file is <code>foobar</code> and is specified at the end of the command; you&#39;ll also see we&#39;re using a <a href="https://en.wikipedia.org/wiki/Salt_(cryptography)"><code>-salt</code></a> with the password to help improve the security):</p>

<pre><code class="language-bash">echo -n &#39;someTextIWantToEncrypt&#39; | openssl enc -e -salt -out test.txt -aes-256-cbc -pass pass:foobar
</code></pre>

<p>To decrypt this file we can use the <code>-d</code> flag (instead of <code>-e</code> which is for encryption):</p>

<pre><code class="language-bash">openssl enc -d -salt -in test.txt -out decrypted.txt -aes-256-cbc -pass pass:foobar
</code></pre>

<p>Alternatively you can make things more complex, but ultimately more secure, by encrypting the file using the public key of the person you want to share the file with (which is how GPG works &#39;out-of-the-box&#39;). As this means the only person who can decrypt the file is the owner of the private key associated with the public key used for encryption.</p>

<p>In the following example let&#39;s assume you/we are &quot;Alice&quot; and the recipient of the encrypted file is &quot;Bob&quot;:</p>

<pre><code class="language-bash"># Bob needs to send us their RSA key in the PEM certificate format

# So first thing Bob does is generate a PEM containing his private key
openssl rsa -in id_rsa -outform pem &gt; id_rsa.pem

# Second thing Bob does is generate a PEM containing his public key
openssl rsa -in id_rsa -pubout -outform pem &gt; id_rsa.pub.pem
</code></pre>

<p>At this point Alice and Bob have to figure out how to securely share Bobs public key with Alice. I would suggest they do this in person to avoid network sniffers getting involved and Alice encrypting the file with the wrong details (this is where PKI helps with &quot;authentication&quot; - we don&#39;t have that process/mechanism here unfortunately).</p>

<p>Once Alice has Bob&#39;s public key she&#39;ll follow these steps:</p>

<pre><code class="language-bash"># Alice generates a 256 bit (32 byte) random key
openssl rand -base64 32 &gt; key.bin

# Alice encrypts the random key using Bobs public key
openssl rsautl -encrypt -inkey id_rsa.pub.pem -pubin -in key.bin -out key.bin.enc

# Alice encrypts the secret file using Bobs public key
openssl enc -aes-256-cbc -salt -in SECRET_FILE -out SECRET_FILE.enc -pass file:./key.bin
</code></pre>

<p>Alice can now send the encrypted file (e.g. <code>SECRET_FILE.enc</code>) to Bob. Once Bob has the encrypted file, he&#39;ll follow these steps:</p>

<pre><code class="language-bash"># Bob decrypts the random key using his private key
openssl rsautl -decrypt -inkey id_rsa.pem -in key.bin.enc -out key.bin

# Bob decrypts the file using his private key
openssl enc -d -aes-256-cbc -in SECRET_FILE.enc -out SECRET_FILE -pass file:./key.bin
</code></pre>

<div id="7.3"></div>

<h3>Keybase</h3>

<p><a href="https://keybase.io/">Keybase</a> was mentioned earlier when we were discussing the problem of &#39;authentication&#39; and that there are many public repositories where you can locate a person&#39;s public key. <a href="https://keybase.io/">Keybase</a> is a recent attempt at trying to solve this problem in a modern way.</p>

<p>I wont cover all the details of getting setup with Keybase (plus it&#39;s invitation only at the moment), but in essence you need to download their command line tool:</p>

<pre><code class="language-bash">brew install keybase
</code></pre>

<p>Once you have that installed you can log into your account:</p>

<pre><code class="language-bash">keybase login
</code></pre>

<p>At this point you can use either the website or the command line tool to generate a keypair for your account. If using the command line, then execute the following:</p>

<pre><code class="language-bash">keybase pgp gen
</code></pre>

<p>Alternatively you might want to use an already existing private key:</p>

<pre><code class="language-bash">keybase pgp select
</code></pre>

<blockquote>
<p>Note: the <code>keybase</code> program will push the public key part of your PGP or GPG key pair to the Keybase website and associate it with your Keybase account</p>
</blockquote>

<p>The point of Keybase is to help you verify the person you want to communicate with is who they say they are. So Keybase let&#39;s users prove who they are by authenticating with their social accounts. For example, if I search for a friend of mine on Keybase:</p>

<pre><code class="language-bash">keybase search sthulb
</code></pre>

<p>Then this will display the following output:</p>

<pre><code class="language-bash">sthulb twitter:sthulb github:sthulb dns://thulbourn.com
</code></pre>

<p>Now I know that he is <code>sthulb</code> on GitHub so if the user <code>sthulb</code> was able to verify the GitHub account of the same user to Keybase then I&#39;m pretty sure this is a legit setup and that I&#39;m OK to communicate with this Keybase user.</p>

<p>Now if I wanted to encrypt a file for my friend, then I would do:</p>

<pre><code class="language-bash">keybase encrypt -i secrets.txt -o secrets.txt.asc sthulb
</code></pre>

<p>This will then display the following:</p>

<pre><code class="language-bash">▶ INFO Identifying recipient sthulb
✔ public key fingerprint: D38B 2537 67F4 1E59 DFE6 7879 EDD0 4A02 7DD5 BD7A
✔ admin of DNS zone thulbourn.com: found TXT entry keybase-site-verification=JVupJZY1EQbjTiYiLc6JSVNcOWACdBEq9WfuJJWT0qg
✔ &quot;sthulb&quot; on twitter: https://twitter.com/sthulb/status/692285366053834753
✔ &quot;sthulb&quot; on github: https://gist.github.com/13a7654d90750bf154c3
</code></pre>

<blockquote>
<p>Note: <code>.asc</code> is a convention to indicate a file has been encrypted</p>
</blockquote>

<p>My friend would then be able to decrypt the encrypted file I send to him with:</p>

<pre><code class="language-bash">keybase decrypt -i secrets.txt.asc -o secrets.txt
</code></pre>

<p>But if someone sends you an encrypted file using your Keybase public key but is encrypted via a different tool, such as their own local GPG or PGP, then you&#39;d decrypt the file with (for example):</p>

<pre><code class="language-bash">keybase pgp decrypt -i some_encrypted_file.gpg
</code></pre>

<p>If you want to encrypt a file for someone who doesn&#39;t use Keybase (e.g. they use their own local GPG installation), then you can export your public/private key from Keybase using the command line tool and then import them into your local GPG so you can utilise GPG to encrypt your data and specify the user&#39;s public key:</p>

<pre><code class="language-bash">keybase pgp export -o keybase.public.key
keybase pgp export -s -o keybase.private.key
gpg --import keybase.public.key
gpg --allow-secret-key-import --import keybase.private.key
</code></pre>

<blockquote>
<p>Notice the use of <code>-s</code> to export the private key</p>
</blockquote>

<p>Now you can encrypt data via GPG using your Keybase private key:</p>

<pre><code class="language-bash">echo foobar &gt; secret.txt
gpg --encrypt -u 123 -r 456 secret.txt
</code></pre>

<blockquote>
<p>Note: <code>123</code> being your keybase identifier inside GPG and<br>
<code>456</code> being the recipient identifier<br>
(assuming you&#39;ve imported their public key already)</p>
</blockquote>

<p>The recipient can now decrypt the file:</p>

<pre><code class="language-bash">gpg -d secret.txt.gpg
</code></pre>

<h3>Which <em>should</em> I use?</h3>

<p>OpenSSL is not considered secure enough in today&#39;s digital age. There are known bugs with the implementation of the OpenSSL <code>enc</code> command, and so the recommendation in the security community seems to be to ditch OpenSSL for GPG (at least for these types of scenarios where we&#39;re simply encrypting a file that we want to share with someone else).</p>

<div id="8"></div>

<h2>Creating, self-signing, issuing and revoking certificates</h2>

<p>OK, so I <em>was</em> going to go through the process of creating a new CA root and then self-signing the certificate so we can then go ahead and issue certificates from our own personal CA. The idea was to indicate how you might do this for an organisation that doesn&#39;t want to pay for a CA to provide them a certificate (e.g. services that only allow access via client certificates doesn&#39;t have to worry about being trusted; as long the employees have trusted the organisation&#39;s self-signed certificate then it&#39;s fine).</p>

<p>The reason I&#39;m not going to do that is because Ivan Ristić (author of &quot;Bulletproof SSL and TLS&quot;) has already done the leg work and has made it freely available in his ebook &quot;OpenSSL Cookbook&quot;. Which you can get here <a href="https://www.feistyduck.com/books/openssl-cookbook/">https://www.feistyduck.com/books/openssl-cookbook/</a></p>

<p>Although, if you want a super quick run down...</p>

<p>You can generate a CSR (Certificate Signing Request; which you send to a CA to approve) using </p>

<pre><code class="language-bash">openssl req -sha256 -new -key my-private-key.pem -out csr.pem
</code></pre>

<p>You can then self-sign that certificate (while you wait for the CA to officially create you a cert and sign it) using:</p>

<pre><code class="language-bash">openssl x509 -req -days 365 -in csr.pem -signkey my-private-key.pem -out my-certificate.pem
</code></pre>

<blockquote>
<p>Note: create key pair + cert in a one liner<br>
<code>openssl req -nodes -new -x509 -keyout server.key -out server.cert</code></p>
</blockquote>

<h3>UPDATE</h3>

<p>OK so I ended up writing about this any way here: <a href="http://www.integralist.co.uk/posts/clientcertauth.html">http://www.integralist.co.uk/posts/clientcertauth.html</a> where I discuss how to handle Client Certificate Authentication using Docker.</p>

<div id="9"></div>

<h2>Conclusion</h2>

<p>Hopefully, you&#39;ve stuck with me until the end here and that you found the information contained useful, or dare say even enlightening. I wrote this post to help solidify my own knowledge and for this to become a future reference point for myself; but I ended up really enjoying diving into aspects such as the PKI and SSL handshake process, as it&#39;s an area that has confused me for the longest time.</p>

<p>If there are any glaring mistakes (I&#39;m sure there will be a few) then do please let me know so I can update and correct.</p>

<h3>References</h3>

<ul>
<li><a href="https://technet.microsoft.com/en-us/library/cc785811(v=ws.10).aspx">technet.microsoft.com</a></li>
<li><a href="https://devcentral.f5.com/articles/ssl-profiles-part-1">devcentral.f5.com</a></li>
<li><a href="http://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/ssl-server-cert.html">AWS ELB SSL Cert upload</a></li>
</ul>

            <hr>
            <h2>Links</h2>
            <ul>
                <li><a href="../index.html">Home</a></li>
                <li><a href="../posts/about.html">About Me</a></li>
                <li><a href="https://github.com/integralist">GitHub</a></li>
                <li><a href="https://twitter.com/integralist">Twitter</a></li>
                <li><a href="http://www.integralist.co.uk/resume">Resume</a></li>
            </ul>
        </article>
        <script src="../scripts/prism.js"></script>
        <script>
            var _gaq=[['_setAccount','UA-33159515-1'],['_trackPageview']];
            (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
            g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
            s.parentNode.insertBefore(g,s)}(document,'script'));
        </script>
    </body>
</html>
