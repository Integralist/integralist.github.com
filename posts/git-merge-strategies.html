<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, minimal-ui">
        <title>Git Merge Strategies</title>
        <link rel="stylesheet" href="../styles/github-markdown.css">
        <link rel="stylesheet" href="../styles/prism-default.css">
        <style>
            body {
                min-width: 200px;
                max-width: 790px;
                margin: 0 auto;
                padding: 30px;
            }

            pre[class*="language-"] {
              border: 1px dashed #AAA;
              margin-bottom: 1em;
            }
        </style>
    </head>
    <body>
        <article class="markdown-body">

<h1>Git Merge Strategies</h1>

<ul>
<li><a href="#1">Introduction</a></li>
<li><a href="#2">git merge</a></li>
<li><a href="#3">git merge --squash</a></li>
<li><a href="#4">git rebase</a></li>
<li><a href="#5">git rebase --interactive</a></li>
<li><a href="#6">git rebase --onto</a></li>
<li><a href="#6">Conclusion</a></li>
</ul>

<div id="1"></div>

<h2>Introduction</h2>

<p>Imagine I have a <code>master</code> branch with one commit:</p>

<pre><code class="language-ini">75eb1cb - (origin/master) README
</code></pre>

<p>Now imagine I have a branch from <code>master</code> called <code>feat/foo</code> and in that branch I&#39;ve made 3 additional commits:</p>

<pre><code class="language-ini">* 41d4115 - Add C (also revert A)
* 9e5626c - Modify A
* 8e7965e - Add B
</code></pre>

<p>You&#39;ll notice throughout this post that I use the command <code>git lg</code> which is an alias I have set within my <code>~/.gitconfig</code>:  </p>

<pre><code class="language-ini">log --graph --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr)%Creset&#39; --abbrev-commit --date=relative
</code></pre>

<div id="2"></div>

<h2><code>git merge</code></h2>

<p>So <code>git merge</code> is the standard workhorse for merging branches in git. It&#39;ll try to resolve the differences between the two branches the best way it can.</p>

<p>If the source branch <code>feat/foo</code> (the branch you want to merge from) can be merged <em>cleanly</em> (e.g. there are no major diverges from the destination branch <code>master</code>, which is the branch the changes are being merged into), then git will be able to perform a simple &quot;fast-forward&quot;. </p>

<p>What &quot;fast-forward: means is that git will change the <code>HEAD</code> (on the destination branch) to point to the new latest commit, and all the other commits from your source branch will also appear in the git log/history of the destination branch.</p>

<p>If you check <code>git lg</code> after doing a <code>git merge feat/foo</code>, you should see something like:</p>

<pre><code class="language-ini">* 41d4115 - (HEAD -&gt; master, origin/feat/foo, feat/foo) Add C (also revert A)
* 9e5626c - Modify A
* 8e7965e - Add B
* 75eb1cb - (origin/master) README
</code></pre>

<p>We can see all the commits from <code>feat/foo</code> were replayed onto <code>master</code> successfully.</p>

<blockquote>
<p>Note: you might not realise that there is a short cut to checking out a branch and then merging another branch into it: <code>git merge &lt;source&gt; &lt;destination&gt;</code>, which is the same as doing <code>git checkout &lt;destination&gt;</code> followed by <code>git merge &lt;source&gt;</code></p>
</blockquote>

<h2><code>git merge --no-ff --edit</code></h2>

<p>Let&#39;s say you wanted a &quot;merge commit&quot; to happen (i.e. merge commits typically only occur if there has been a divergence between the branches which means git has to resolve the problem for you), then you can force git to use a &quot;merge commit&quot; even when there is no need for one (as is the case for me here).</p>

<p>If this happens to you, and you&#39;ve not pushed the branch to a remote, then you can safely go back:</p>

<pre><code class="language-git">git reset --hard 75eb1cb
</code></pre>

<blockquote>
<p>Note: <code>75eb1cb</code> being my first commit in <code>master</code></p>
</blockquote>

<p>Now we&#39;re back to where we were originally (a separate <code>feat/foo</code> branch and a <code>master</code> branch with a single commit), we can look at how to force a merge commit.</p>

<p>To force a merge commit you&#39;ll need to use the <code>--no-ff</code> flag and then also use the <code>--edit</code> flag to allow you to modify the default merge commit message (otherwise git will provide its own commit message which is nearly always not useful or descriptive):</p>

<pre><code class="language-git">git merge --edit --no-ff feat/foo 
</code></pre>

<blockquote>
<p>Note: <code>--edit</code> doesn&#39;t work without <code>--no-ff</code>, unless there is a <em>genuine</em> merge conflict</p>
</blockquote>

<p>Now if I look at my <code>git lg</code> I can see:</p>

<pre><code class="language-ini">*   97f1257 - (HEAD -&gt; master) My custom merge commit message for &#39;feat/foo&#39;
|\  
| * 41d4115 - (origin/feat/foo, feat/foo) Add C (also revert A)
| * 9e5626c - Modify A
| * 8e7965e - Add B
|/  
* 75eb1cb - (origin/master) README
</code></pre>

<p>We can see all the commits from <code>feat/foo</code> were replayed onto <code>master</code> successfully, but now you&#39;re able to more easily distinguish the three commits came from another branch (if using my <code>git lg</code> alias).</p>

<div id="3"></div>

<h2><code>git merge --squash</code></h2>

<p>So what if you don&#39;t want all those commits in your <code>master</code>? You could instead &quot;squash&quot; all the commits down into a single commit using the <code>--squash</code> command:</p>

<pre><code class="language-git">git merge --squash feat/foo
</code></pre>

<p>Now what this does is take my changes from the source branch <code>feat/foo</code> and automatically squashes those separate commits into a single change that&#39;s placed into the staging area of my destination branch. </p>

<p>These collection of changes <em>now</em> appear as a single change to the file. They aren&#39;t actually <em>merged</em> yet. So you have the opportunity to change the commit message:</p>

<pre><code class="language-git">git commit -m &quot;your own custom commit message&quot;
</code></pre>

<div id="4"></div>

<h2><code>git rebase</code></h2>

<p>The <code>git rebase</code> feature in essence is solving the same problem as <code>git merge</code> (they both integrate a set of changes), but they do them in fundamentally different ways.</p>

<p>With <code>git merge</code> a merge commit is utilised to resolve conflicts and so is considered <em>non-destructive</em>. What this means is that the commits within either branch (destination or source) aren&#39;t modified in any way.</p>

<p>With <code>git rebase</code> the source branch commits are placed <em>before</em> the destination branch&#39;s commits, but also the commits themselves are from the source are recreated inside the destination branch.</p>

<p>Let&#39;s look and see what this does for us:</p>

<pre><code class="language-git">git rebase feat/foo
</code></pre>

<p>We can see that as there were no conflicts, git was able to &quot;fast-forward&quot; the commits. So in theory this is no different right now from originally doing <code>git merge feat/foo</code>.</p>

<p>But what if <code>master</code> had a new change committed to it, and this change happened <em>after</em> we had branched off with <code>feat/foo</code>? For example, I&#39;ll add a second commit to <code>master</code> that changes <code>- A: 1</code> to <code>- A: 9</code>.</p>

<p>If I run <code>git rebase feat/foo</code> I should see we get a merge conflict and one that git doesn&#39;t know how to resolve:</p>

<pre><code class="language-ini">First, rewinding head to replay your work on top of it...
Applying: A to 9
Using index info to reconstruct a base tree...
M   README.md
Falling back to patching base and 3-way merge...
Auto-merging README.md
CONFLICT (content): Merge conflict in README.md
error: Failed to merge in the changes.
Patch failed at 0001 A to 9
The copy of the patch that failed is found in: .git/rebase-apply/patch

When you have resolved this problem, run &quot;git rebase --continue&quot;.
If you prefer to skip this patch, run &quot;git rebase --skip&quot; instead.
To check out the original branch and stop rebasing, run &quot;git rebase --abort&quot;.
</code></pre>

<p>We can see from the information git has given us that it first rewinded <code>master</code> back to the first commit <code>75eb1cb</code> in order for it to place our <code>feat/foo</code> commits on top of it (as that initial commit is where our branch originally forked from).</p>

<p>From there we can see once git replayed our <code>feat/foo</code> commits on top of <code>75eb1cb</code> that it then tried to apply the new commit that <code>feat/foo</code> didn&#39;t have (e.g. <code>Applying: A to 9</code>) and it failed to do so.</p>

<p>Git tells us that there was a merge conflict:</p>

<pre><code class="language-ini">CONFLICT (content): Merge conflict in README.md
</code></pre>

<p>It&#39;s up to us to open <code>README.md</code> and to resolve the conflict ourself. When I open the file I see:</p>

<pre><code class="language-ini">&lt;&lt;&lt;&lt;&lt;&lt;&lt; 41d411564c1dc3106f03427d1b5920d05d95e037
- A: 1
- B: 2
- C: 3
||||||| merged common ancestors
- A: 1
=======
- A: 9
&gt;&gt;&gt;&gt;&gt;&gt;&gt; A to 9
</code></pre>

<p>So the above shows the file is split into three:</p>

<ol>
<li><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; &lt;commit_hash&gt;</code></li>
<li><code>||||||| merged common ancestors</code></li>
<li><code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;commit_message&gt;</code></li>
</ol>

<p>I know that I&#39;m happy for the line <code>- A: 1</code> (which was changed in my <code>feat/foo</code> branch commit <code>41d4115</code>) to be changed to <code>- A: 9</code> (which was changed in <code>master</code> after I originally branched from it). So I manually make that change by deleting all the added noise (e.g. <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> and <code>||||||| merged common ancestors</code> etc) so I&#39;m left with just the content the file should be expected to have now.</p>

<p>I update it to look like:</p>

<pre><code class="language-ini">- A: 9
- B: 2
- C: 3
</code></pre>

<p>I now must run the following commands:</p>

<ul>
<li><code>git add README.md</code> (as I&#39;ve made a change to the file at this point in time)</li>
<li><code>git rebase --continue</code></li>
</ul>

<p>We see that git is trying again now to apply the commit (but this time there is no merge conflict info inside of the README) and so we see the output: </p>

<pre><code class="language-ini">Applying: A to 9
</code></pre>

<p>Now when looking at the output from <code>git lg</code> I see:</p>

<pre><code class="language-ini">* 7c001cd - (HEAD -&gt; master) A to 9
* 41d4115 - (origin/feat/foo, feat/foo) Add C (also revert A)
* 9e5626c - Modify A
* 8e7965e - Add B
* 75eb1cb - (origin/master) README
</code></pre>

<p>This shows that the changes from <code>feat/foo</code> where replayed directly on top of <code>75eb1cb</code>. Otherwise if we didn&#39;t use git&#39;s rebase feature, we could&#39;ve ended up with a git history that looked like the following:</p>

<pre><code class="language-ini">* 41d4115 - (origin/feat/foo, feat/foo) Add C (also revert A)
* 9e5626c - Modify A
* 8e7965e - Add B
* 65553e0 - (HEAD -&gt; master) A to 9
* 75eb1cb - (origin/master) README
</code></pre>

<p>Notice the <code>feat/foo</code> commits are on top of the <code>A to 9</code> commit and that might no necessarily be what we want to have happen.</p>

<div id="5"></div>

<h2><code>git rebase --interactive</code></h2>

<p>The <code>--interactive</code> flag is useful for letting us rewrite our git history. We&#39;re able to move the order of our commits as well as squash commits down and change their recorded message.</p>

<p>So let&#39;s assume we want to squash all but the first commit in our <code>feat/foo</code> branch. By that I mean we currently have:</p>

<pre><code class="language-ini">* b4f9dfd - (HEAD -&gt; feat/foo) Add C (also revert A)
* 7354a41 - Modify A
* c321b40 - Add B
* 75eb1cb - (origin/master) README
</code></pre>

<p>Let&#39;s say we want &quot;Add B&quot;, &quot;Modify A&quot; and &quot;Add C (also revert A)&quot; squashed into one commit. To do this we need to locate the parent commit of the earliest commit we want to squash.</p>

<p>So &quot;Add B&quot; is the earliest commit we want as part of the squash, so the parent commit is &quot;README&quot;. To action the rebase let&#39;s run the following command:</p>

<pre><code class="language-git">git rebase --interactive 75eb1cb
</code></pre>

<p>This drops us into an editor with the following output:</p>

<pre><code class="language-ini">pick c321b40 Add B
pick 7354a41 Modify A
pick b4f9dfd Add C (also revert A)

# Rebase 75eb1cb..b4f9dfd onto 75eb1cb (3 command(s))
#
# Commands:
# p, pick = use commit
# r, reword = use commit, but edit the commit message
# e, edit = use commit, but stop for amending
# s, squash = use commit, but meld into previous commit
# f, fixup = like &quot;squash&quot;, but discard this commit&#39;s log message
# x, exec = run command (the rest of the line) using shell
# d, drop = remove commit
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
</code></pre>

<p>We can modify it like so:</p>

<pre><code class="language-ini">pick c321b40 Add B
squash 7354a41 Modify A
squash b4f9dfd Add C (also revert A)
</code></pre>

<p>This will result in the following combined commit details:</p>

<pre><code class="language-ini"># This is a combination of 3 commits.
# The first commit&#39;s message is:
Add B

# This is the 2nd commit message:

Modify A

# This is the 3rd commit message:

Add C (also revert A)

# Please enter the commit message for your changes. Lines starting
# with &#39;#&#39; will be ignored, and an empty message aborts the commit.
#
# Date:      Sun May 15 17:29:32 2016 +0100
#
# interactive rebase in progress; onto 75eb1cb
# Last commands done (3 commands done):
#    squash 7354a41 Modify A
#    squash b4f9dfd Add C (also revert A)
# No commands remaining.
# You are currently editing a commit while rebasing branch &#39;feat/foo&#39; on &#39;75eb1cb&#39;.
#
# Changes to be committed:
#   modified:   README.md
#
</code></pre>

<p>Now if we run <code>git lg -p</code> we&#39;ll see the new squashed commit does indeed contain all the previous commit&#39;s contents:</p>

<pre><code class="language-git">* b63857d - (HEAD -&gt; feat/foo) Add B (16 minutes ago)| 
| diff --git a/README.md b/README.md
| index 428f59e..f2e26b6 100644
| --- a/README.md
| +++ b/README.md
| @@ -1 +1,3 @@
|  - A: 1
| +- B: 2
| +- C: 3
</code></pre>

<div id="6"></div>

<h2><code>git rebase --onto</code></h2>

<p>Imagine we&#39;ve merged our <code>feat/foo</code> branch at this point into <code>master</code> using:</p>

<pre><code class="language-bash">git merge --squash feat/foo
</code></pre>

<blockquote>
<p>Note: you&#39;ll need to fix a conflict first for it to be successful</p>
</blockquote>

<p>So <code>master</code> should now have three commits:</p>

<pre><code class="language-bash">* 19ec1bb - (HEAD -&gt; master) Merge feat/foo
* 3fc460b - A to 9
* 75eb1cb - (origin/master) README
</code></pre>

<p>What&#39;s the easiest way to delete the middle/second commit <code>3fc460b</code>? We could use <code>git rebase --interactive</code> to delete the commit from history, but there is an alternative that&#39;s much easier:</p>

<pre><code class="language-bash">git rebase --onto 75eb1cb 3fc460b
</code></pre>

<blockquote>
<p>Note: in this scenario you&#39;ll get a conflict that you&#39;ll need to resolve first (e.g. we&#39;re removing a commit that sets A to the value 9 but that change was also pulled into the <code>feat/foo</code> branch so git isn&#39;t sure whether you definitely want that change any more or not), but in most cases you&#39;ll likely have a clean rebase</p>
</blockquote>

<p>The basic structure of this command is:</p>

<pre><code class="language-bash">  git rebase --onto &lt;commit_to_become_new_base&gt; &lt;commit_to_delete&gt;
</code></pre>

<p>For more information see the documentation for <code>git rebase</code>:</p>

<ul>
<li><code>man git-rebase</code></li>
<li><a href="https://git-scm.com/docs/git-rebase">git-scm.com/docs/git-rebase</a></li>
</ul>

<div id="7"></div>

<h2>Conclusion</h2>

<p>There are so many aspects to merging commits and dealing with git&#39;s commit history, that it&#39;s difficult to cover everything without people having to mentally store too much information that most of the time you wont utilise.</p>

<p>For example, I&#39;ve not covered anything to do with pulling commits: <code>git pull --strategy</code>, <code>git pull --squash</code>, <code>git pull --rebase</code>, <code>git pull --ff-only</code> and <code>git pull --no-commit</code>. Each have their use cases, but I think sometimes you&#39;re better picking a single strategy and defining it as a standard within your development team.</p>

<p>If you&#39;re interested in one git workflow approach that utilises git&#39;s rebasing feature, and I&#39;ve used with success in the past at the BBC, then I recommend you have a read of this blog post I wrote a few years ago: <a href="http://www.integralist.co.uk/posts/github-workflow.html">integralist.co.uk/posts/github-workflow</a></p>

<p>I&#39;ve also written about other types of git &quot;workflows&quot; as part of BBC News&#39; &quot;Coding Best Practices&quot; working group: <a href="https://github.com/bbc/news-coding-best-practices/blob/master/git-workflow.md">github.com/bbc/news-coding-best-practices/git-workflow</a></p>

            <hr>
            <h2>Links</h2>
            <ul>
                <li><a href="../index.html">Home</a></li>
                <li><a href="../posts/about.html">About Me</a></li>
                <li><a href="https://github.com/integralist">GitHub</a></li>
                <li><a href="https://twitter.com/integralist">Twitter</a></li>
                <li><a href="http://www.integralist.co.uk/resume">Resume</a></li>
            </ul>
        </article>
        <script src="../scripts/prism.js"></script>
        <script>
            var _gaq=[['_setAccount','UA-33159515-1'],['_trackPageview']];
            (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
            g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
            s.parentNode.insertBefore(g,s)}(document,'script'));
        </script>
    </body>
</html>
