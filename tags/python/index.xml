<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on integralist</title>
    <link>http://www.integralist.co.uk/tags/python/</link>
    <description>Recent content in Python on integralist</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-gb</language>
    <lastBuildDate>Sun, 26 Nov 2017 13:00:00 +0100</lastBuildDate>
    
	<atom:link href="http://www.integralist.co.uk/tags/python/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>NSQ Queue Reader Best Practices</title>
      <link>http://www.integralist.co.uk/posts/queue-reader-best-practices/</link>
      <pubDate>Sun, 26 Nov 2017 13:00:00 +0100</pubDate>
      
      <guid>http://www.integralist.co.uk/posts/queue-reader-best-practices/</guid>
      <description>Introduction Ephemeral Channels? Fail quickly Verify your message handling logic Be wary of global variables Instrument timers around your primary message handler Pynsq doesn’t support coroutines Prevent messages backing up in the queue Avoid API libraries auto-retrying expensive operations Place blocking IO operations into a thread pool Rate limit yourself Disable yourself Drop or Requeue?  
Introduction This post should serve as a guide for best practices when dealing with services that consume messages from queues and process those messages (we refer to them as QRs or &amp;lsquo;Queue Readers&amp;rsquo;).</description>
    </item>
    
    <item>
      <title>Profiling Python</title>
      <link>http://www.integralist.co.uk/posts/profiling-python/</link>
      <pubDate>Tue, 31 Oct 2017 13:00:00 +0100</pubDate>
      
      <guid>http://www.integralist.co.uk/posts/profiling-python/</guid>
      <description>Memory Management Types of Profiling Tools Matrix Analysis Steps Base Example Timer Built-in module: timeit Built-in module: profiler Line Profiler Basic Memory Profiler Tracemalloc PyFlame (Flame Graphs) Conclusion  
Memory Management Before we dive into the techniques and tools available for profiling Python applications, we should first understand a little bit about its memory model as this can help us to understand what it is we’re seeing in relation to memory consumption.</description>
    </item>
    
    <item>
      <title>Dev Environments Within Docker Containers</title>
      <link>http://www.integralist.co.uk/posts/dev-environments-within-docker-containers/</link>
      <pubDate>Wed, 29 Mar 2017 13:00:00 +0100</pubDate>
      
      <guid>http://www.integralist.co.uk/posts/dev-environments-within-docker-containers/</guid>
      <description>Introduction Python Go Mounting Volumes  
Introduction You&amp;rsquo;re a software engineer with a new laptop.
You&amp;rsquo;re going to be writing code in multiple languages.
You&amp;rsquo;re going to have projects of varying dependencies.
But you want to avoid the issues you&amp;rsquo;ve had in the past:
 Messy installations of lots of different software packages. Clogging up your system with programming language version managers.  You decide to use Docker.</description>
    </item>
    
  </channel>
</rss>