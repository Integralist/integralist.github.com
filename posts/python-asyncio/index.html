<!DOCTYPE HTML>
<!--
	Editorial by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
  <head>
    <title>Integralist</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="../../assets/css/main.css" />
  </head>
  <body class="is-preload">
    <!-- Wrapper -->
    <div id="wrapper">
      <!-- Main -->
      <div id="main">
        <div class="inner">
          <!-- Header -->
					<header id="header">
						<a href="../../index.html" class="logo"><strong>Home</strong></a>
							<ul class="icons">
							<!--<li><a href="https://x.com/integralist" class="icon brands fa-twitter" target="blank"><span class="label">Twitter</span></a></li>-->
							<!--<li><a href="https://instagram.com/wwfsuperstarsofwrestling" class="icon brands fa-instagram" target="blank"><span class="label">Instagram</span></a></li>-->
						</ul>
					</header>

          <!-- Content -->
          <section>
						<!--
            <header class="main">
              <h1>Royal Rumble 1989</h1>
              <p>A Bizarre Spectacle Where the Madness Multiplies</p>
            </header>
            <span class="image main"><img src="../images/rumble-89.jpg" alt="" /></span>
						-->
						<nav>

<ul>
<li><a href="#guide-to-concurrency-in-python-with-asyncio">Guide to Concurrency in Python with Asyncio</a>
<ul>
<li><a href="#introduction">Introduction</a></li>

<li><a href="#why-focus-on-asyncio">Why focus on asyncio?</a></li>

<li><a href="#a-quick-asyncio-summary">A quick <code>asyncio</code> summary</a></li>

<li><a href="#a-quick-concurrent-futures-summary">A quick <code>concurrent.futures</code> summary</a></li>

<li><a href="#green-threads">Green threads?</a></li>

<li><a href="#event-loop">Event Loop</a></li>

<li><a href="#awaitables">Awaitables</a>
<ul>
<li><a href="#coroutines">Coroutines</a></li>

<li><a href="#tasks">Tasks</a></li>

<li><a href="#futures">Futures</a></li>
</ul></li>

<li><a href="#running-an-asyncio-program">Running an asyncio program</a>
<ul>
<li><a href="#running-async-code-in-the-repl">Running Async Code in the REPL</a></li>

<li><a href="#use-another-event-loop">Use another Event Loop</a></li>
</ul></li>

<li><a href="#concurrent-functions">Concurrent Functions</a></li>

<li><a href="#deprecated-functions">Deprecated functions</a></li>

<li><a href="#examples">Examples</a>
<ul>
<li><a href="#gather"><code>gather</code></a></li>

<li><a href="#wait"><code>wait</code></a></li>

<li><a href="#wait-for"><code>wait_for</code></a></li>

<li><a href="#as-completed"><code>as_completed</code></a></li>

<li><a href="#create-task"><code>create_task</code></a></li>
</ul></li>

<li><a href="#callbacks">Callbacks</a></li>

<li><a href="#pools">Pools</a>
<ul>
<li><a href="#executors">Executors</a></li>

<li><a href="#asyncio-future-vs-concurrent-futures-future"><code>asyncio.Future</code> vs <code>concurrent.futures.Future</code></a></li>

<li><a href="#asyncio-wrap-future"><code>asyncio.wrap_future</code></a></li>
</ul></li>
</ul></li>
</ul>

</nav>

<h1 id="guide-to-concurrency-in-python-with-asyncio">Guide to Concurrency in Python with Asyncio</h1>

<p>This is a <em>quick</em> guide to Python&rsquo;s <code>asyncio</code> module and is based on Python version 3.8.</p>

<h2 id="introduction">Introduction</h2>

<p>So let&rsquo;s start by addressing the elephant in the room: there are <em>many</em> modules provided by the Python standard library for handling asynchronous/concurrent/multiprocess code&hellip;</p>

<ul>
<li><a href="https://docs.python.org/3.8/library/_thread.html" target="_blank"><code>_thread</code></a></li>
<li><a href="https://docs.python.org/3.8/library/threading.html" target="_blank"><code>threading</code></a></li>
<li><a href="https://docs.python.org/3.8/library/multiprocessing.html" target="_blank"><code>multiprocessing</code></a></li>
<li><a href="https://docs.python.org/3.8/library/asyncio.html" target="_blank"><code>asyncio</code></a></li>
<li><a href="https://docs.python.org/3.8/library/concurrent.futures.html" target="_blank"><code>concurrent.futures</code></a></li>
</ul>

<p>In this post we&rsquo;re going to focus on the last two. Primarily we will be focusing on <code>asyncio</code>, before wrapping up with a look at some useful features of <code>concurrent.futures</code>.</p>

<p>The motivation for this post is to understand why you will most likely want to use <code>asyncio</code> over the other available modules (e.g. <code>_thread</code> and <code>threading</code>) and when it&rsquo;s actually more appropriate to use either <code>multiprocessing</code> or <code>concurrent.futures</code>.</p>

<h2 id="why-focus-on-asyncio">Why focus on asyncio?</h2>

<p>One of the issues with writing concurrent code (using either the <code>_thread</code> or <code>threading</code> modules) is that you suffer the cost of &lsquo;CPU context switching&rsquo; (as a CPU core can only run one thread at a time) which although quick, isn&rsquo;t free.</p>

<p>Multi-threaded code also has to deal with issues such as &lsquo;race conditions&rsquo;, &lsquo;dead/live locks&rsquo; and &lsquo;resource starvation&rsquo; (where some threads are over utilized and others are under utilized).</p>

<p>Asyncio avoids these issues, so let&rsquo;s see how&hellip;</p>

<h2 id="a-quick-asyncio-summary">A quick <code>asyncio</code> summary</h2>

<blockquote>
<p>asyncio is a library to write concurrent code using the <code>async</code>/<code>await</code> syntax. &ndash; <a href="https://docs.python.org/3.8/library/asyncio.html" target="_blank">docs.python.org/3.8/library/asyncio.html</a></p>
</blockquote>

<p>The asyncio module provides both high-level and low-level APIs. Library and Framework developers will be expected to use the low-level APIs, while all other users are encouraged to use the high-level APIs.</p>

<p>It differs conceptually from the more traditional <code>threading</code> or <code>multiprocess</code> approach to asynchronous code execution in that it utilizes something called an <a href="#event-loop">event loop</a> to handle the scheduling of asynchronous &lsquo;tasks&rsquo; instead of using more traditional threads or subprocesses.</p>

<p>Importantly, asyncio is designed to solve I/O network performance, <em>not</em> CPU bound operations (which is where multiprocessing should be used). So asyncio is not a replacement for all types of asynchronous execution.</p>

<p>Asyncio is designed around the concept of &lsquo;cooperative multitasking&rsquo;, so you have complete control over when a CPU &lsquo;context switch&rsquo; occurs (i.e. context switching happens at the application level and not the hardware level).</p>

<p>When using threads the Python scheduler is responsible for this, and so your application may context switch at any moment (i.e. it becomes non-deterministic).</p>

<p>This means when using threads you&rsquo;ll need to also use some form of &lsquo;lock&rsquo; mechanism to prevent multiple threads from accessing/mutating shared memory (which would otherwise subsequently cause your program to become non-thread safe).</p>

<h2 id="a-quick-concurrent-futures-summary">A quick <code>concurrent.futures</code> summary</h2>

<blockquote>
<p>The concurrent.futures module provides a high-level interface for asynchronously executing callables. &ndash; <a href="https://docs.python.org/3.8/library/concurrent.futures.html" target="_blank">docs.python.org/3.8/library/concurrent.futures.html</a></p>
</blockquote>

<p>The <code>concurrent.futures</code> provides a high-level abstraction for the <code>threading</code> and <code>multiprocessing</code> modules, which is why we won&rsquo;t discuss those modules in detail within this post. In fact the <code>_thread</code> module is a very low-level API that the <code>threading</code> module is itself built on top of (again, this is why we won&rsquo;t be covering that either).</p>

<p>Now we&rsquo;ve already mentioned that asyncio helps us avoid using threads so why would we want to use <code>concurrent.futures</code> if it&rsquo;s just an abstraction on top of threads (and multiprocessing)? Well, because not all libraries/modules/APIs support the asyncio model.</p>

<p>For example, if you use <code>boto3</code> and interact with AWS S3, then you&rsquo;ll find those are synchronous operations. You can wrap those calls in multi-threaded code, but it would be better to use <code>concurrent.futures</code> as it means you not only benefit from traditional threads but an asyncio friendly package.</p>

<p>The <code>concurrent.futures</code> module is also designed to interop with the asyncio event loop, making it easier to work with a pool of threads/subprocesses within an otherwise asyncio driven application.</p>

<p>Additionally you&rsquo;ll also want to utilize <code>concurrent.futures</code> when you require a pool of threads or a pool of subprocesses, while also using a clean and modern Python API (as apposed to the more flexible but low-level <code>threading</code> or <code>multiprocessing</code> modules).</p>

<h2 id="green-threads">Green threads?</h2>

<p>There are many ways to achieve asynchronous programming. There&rsquo;s the event loop approach (which asyncio implements), a &lsquo;callback&rsquo; style historically favoured by single-threaded languages such as JavaScript, and more traditionally there has been a concept known as &lsquo;green threads&rsquo;.</p>

<p>In essence a green thread looks and feels exactly like a normal thread, except that the threads are scheduled by application code rather than by hardware (so effectively working around the same issue of deterministic context switching as an event loop does). But the problem of handling shared memory still exists.</p>

<p>So let&rsquo;s take a quick look now at what the &lsquo;event loop&rsquo; is, as it&rsquo;s the foundation of what makes asyncio work and why we can avoid &lsquo;callback hell&rsquo; and the problems inherent with &lsquo;green threads&rsquo;&hellip;</p>

<h2 id="event-loop">Event Loop</h2>

<p>The core element of all asyncio applications is the &lsquo;event loop&rsquo;. The event loop is what schedules and runs asynchronous tasks.</p>

<p><a href="../../assets/images/event-loop.png">
<img src="../../assets/images/event-loop.png">
</a></p>

<div class="credit">
  <a href="https://eng.paxos.com/python-3s-killer-feature-asyncio">Image Credit</a>
</div>

<p>What makes the asyncio event loop so effective is the fact that Python implements it around <a href="/posts/python-generators/">generators</a>. A generator enables a function to be partially executed, then halt its execution at a specific point, maintaining a stack of objects and exceptions, before resuming again.</p>

<p>I&rsquo;ve written about <a href="/posts/python-generators/">iterators, generators and coroutines</a> recently, so if you&rsquo;re interested in those concepts, then I&rsquo;ll refer you to that post.</p>

<blockquote>
<p>Note: for more API information on the event loop, please refer to <a href="https://docs.python.org/3.8/library/asyncio-eventloop.html" target="_blank">the official Python documentation</a>.</p>
</blockquote>

<h2 id="awaitables">Awaitables</h2>

<p>The driving force behind asyncio is the ability to schedule asynchronous &lsquo;tasks&rsquo;. There are a few different types of objects in Python that help support this, and they are generally grouped by the term &lsquo;awaitable&rsquo;.</p>

<p>Ultimately, something is <em>awaitable</em> if it can be used in an <code>await</code> expression.</p>

<p>There are three main types of awaitables:</p>

<ol>
<li>Coroutines</li>
<li>Tasks</li>
<li>Futures</li>
</ol>

<blockquote>
<p>Note: Futures is a <em>low-level</em> type and so you shouldn&rsquo;t need to worry about it too much if you&rsquo;re not a library/framework developer (as you should be using the higher-level abstraction APIs instead).</p>
</blockquote>

<h3 id="coroutines">Coroutines</h3>

<p>There are two closely related terms used here:</p>

<ul>
<li>a <em>coroutine function</em>: an <code>async def</code> function.</li>
<li>a <em>coroutine object</em>: an object returned by calling a coroutine function.</li>
</ul>

<blockquote>
<p>Generator based coroutine functions (e.g. those defined by decorating a function with <code>@asyncio.coroutine</code>) are superseded by the <code>async</code>/<code>await</code> syntax, but will continue to be supported <em>until</em> Python 3.10 &ndash; <a href="https://docs.python.org/3.8/library/asyncio-task.html#asyncio-generator-based-coro" target="_blank">docs.python.org/3.8/library/asyncio-task.html</a>.</p>

<p>Refer to my post &ldquo;<a href="/posts/python-generators/">iterators, generators, coroutines</a>&rdquo; for more details about generator based coroutines and their asyncio history.</p>
</blockquote>

<h3 id="tasks">Tasks</h3>

<p><a href="https://docs.python.org/3.8/library/asyncio-task.html#asyncio.Task" target="_blank">Tasks</a> are used to schedule coroutines <em>concurrently</em>.</p>

<p>All asyncio applications will typically have (at least) a single &lsquo;main&rsquo; entrypoint task that will be scheduled to run immediately on the event loop. This is done using the <code>asyncio.run</code> function (see &lsquo;<a href="#running-an-asyncio-program">Running an asyncio program</a>&rsquo;).</p>

<p>A coroutine function is expected to be passed to <code>asyncio.run</code>, while <em>internally</em> asyncio will check this using the helper function <code>coroutines.iscoroutine</code> (see: <a href="https://github.com/python/cpython/blob/master/Lib/asyncio/runners.py#L8" target="_blank">source code</a>). If not a coroutine, then an error is raised, otherwise the coroutine will be passed to <code>loop.run_until_complete</code> (see: <a href="https://github.com/python/cpython/blob/master/Lib/asyncio/base_events.py#L599" target="_blank">source code</a>).</p>

<p>The <code>run_until_complete</code> function expects a <a href="#futures">Future</a> (see below section for what a Future is) and uses another helper function <code>futures.isfuture</code> to check the type provided. If not a Future, then the low-level API <code>ensure_future</code> is used to convert the coroutine into a Future (see <a href="https://github.com/python/cpython/blob/master/Lib/asyncio/tasks.py#L653" target="_blank">source code</a>).</p>

<blockquote>
<p>Note: <a href="https://gist.github.com/1efc8dcfc0b1e9e8e8b89a4b2019f3af" target="_blank">here</a> is a comparison of the various methods for validating if a function is a coroutine. The results aren&rsquo;t necessarily what you might expect.</p>
</blockquote>

<p>In older versions of Python, if you were going to manually create your own Future and schedule it onto the event loop, then you would have used <code>asyncio.ensure_future</code> (now considered to be a low-level API), but with Python 3.7+ this has been superseded by <code>asyncio.create_task</code>.</p>

<p>Additionally with Python 3.7, the idea of interacting with the event loop directly (e.g. getting the event loop, creating a task with <code>create_task</code> and then passing it to the event loop) has been replaced with <code>asyncio.run</code>, which abstracts it all away for you (see &lsquo;<a href="#running-an-asyncio-program">Running an asyncio program</a>&rsquo; to understand what that means).</p>

<p>The following APIs let you see the state of the tasks running on the event loop:</p>

<ul>
<li><code>asyncio.current_task</code></li>
<li><code>asyncio.all_tasks</code></li>
</ul>

<blockquote>
<p>Note: for other available methods on a Task object please refer to <a href="https://docs.python.org/3.8/library/asyncio-task.html#asyncio.Task" target="_blank">the documentation</a>.</p>
</blockquote>

<h3 id="futures">Futures</h3>

<p>A Future is a low-level awaitable object that represents an eventual result of an asynchronous operation.</p>

<p>To use an analogy: it&rsquo;s like an empty postbox. At <em>some point</em> in the future the postman will arrive and stick a letter into the postbox.</p>

<p>This API exists to enable callback-based code to be used with <code>async</code>/<code>await</code>, while <a href="https://docs.python.org/3.8/library/asyncio-eventloop.html#asyncio.loop.run_in_executor" target="_blank"><code>loop.run_in_executor</code></a> is an example of an asyncio low-level API function that returns a Future (see also some of the APIs listed in <a href="#concurrent-functions">Concurrent Functions</a>).</p>

<blockquote>
<p>Note: for other available methods on a Future please refer to <a href="https://docs.python.org/3.8/library/asyncio-future.html#asyncio.Future" target="_blank">the documentation</a>.</p>
</blockquote>

<h2 id="running-an-asyncio-program">Running an asyncio program</h2>

<p>The high-level API (as per Python 3.7+) is:</p>

<pre><code class="language-python">import asyncio

async def foo():
    print(&quot;Foo!&quot;)

async def hello_world():
    await foo()  # waits for `foo()` to complete
    print(&quot;Hello World!&quot;)

asyncio.run(hello_world())
</code></pre>

<p>The <code>.run</code> function always creates a <em>new</em> event loop and <em>closes</em> it at the end. If you were using the lower-level APIs, then this would be something you&rsquo;d have to handle manually (as demonstrated below).</p>

<pre><code class="language-python">loop = asyncio.get_event_loop()
loop.run_until_complete(hello_world())
loop.close()
</code></pre>

<h3 id="running-async-code-in-the-repl">Running Async Code in the REPL</h3>

<p>Prior to Python 3.8 you couldn&rsquo;t execute async code within the standard Python REPL (it would have required you to use the IPython REPL instead).</p>

<p>To do this with the latest version of Python you would run <code>python -m asyncio</code>. Once the REPL has started you don&rsquo;t need to use <code>asyncio.run()</code>, but just use the <code>await</code> statement directly.</p>

<pre><code>asyncio REPL 3.8.0+ (heads/3.8:5f234538ab, Dec  1 2019, 11:05:25)

[Clang 10.0.1 (clang-1001.0.46.4)] on darwin

Use &quot;await&quot; directly instead of &quot;asyncio.run()&quot;.
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.

&gt;&gt;&gt; import asyncio
&gt;&gt;&gt; async def foo():
...   await asyncio.sleep(5)
...   print(&quot;done&quot;)
...
&gt;&gt;&gt; await foo()
done
</code></pre>

<blockquote>
<p>Notice the REPL automatically executes <code>import asyncio</code> when starting up so we&rsquo;re able to use any <code>asyncio</code> functions (such as the <code>.sleep</code> function) without having to manually type that import statement ourselves.</p>
</blockquote>

<h3 id="use-another-event-loop">Use another Event Loop</h3>

<p>If for some reason you didn&rsquo;t want to use the event loop provided by <code>asyncio</code> (which is a pure Python implementation), you can swap it out for another event loop such as <a href="https://github.com/MagicStack/uvloop/" target="_blank">uvloop</a>.</p>

<blockquote>
<p>uvloop is a fast, drop-in replacement of the built-in asyncio event loop. uvloop is implemented in <a href="https://cython.org/" target="_blank">Cython</a> and uses <a href="https://libuv.org/" target="_blank">libuv</a> under the hood.</p>
</blockquote>

<p>According to the authors of uvloop, it is comparible in speed to that of <a href="https://golang.org/" target="_blank">Go</a> programs! I recommend reading their <a href="https://magic.io/blog/uvloop-blazing-fast-python-networking/" target="_blank">blog post</a> about its initial release.</p>

<p>If you want to utilize uvloop then first install it with <code>pip install uvloop</code>, then add a call to <code>uvloop.install()</code> like so:</p>

<pre><code>import asyncio
import uvloop

async def foo():
    print(&quot;Foo!&quot;)

async def hello_world():
    await foo()
    print(&quot;Hello World!&quot;)

uvloop.install()
asyncio.run(hello_world())
</code></pre>

<h2 id="concurrent-functions">Concurrent Functions</h2>

<p>The following functions help to co-ordinate the running of functions concurrently, and offer varying degrees of control dependant on the needs of your application.</p>

<ul>
<li><code>asyncio.gather</code>: takes a sequence of awaitables, returns an aggregate list of successfully awaited values.</li>
<li><code>asyncio.shield</code>: prevent an awaitable object from being cancelled.</li>
<li><code>asyncio.wait</code>: wait for a sequence of awaitables, until the given &lsquo;condition&rsquo; is met.</li>
<li><code>asyncio.wait_for</code>: wait for a single awaitable, until the given &lsquo;timeout&rsquo; is reached.</li>
<li><code>asyncio.as_completed</code>: similar to <code>gather</code> but returns Futures that are populated when results are ready.</li>
</ul>

<blockquote>
<p>Note: <code>gather</code> has specific options for handling errors and cancellations. For example, if <code>return_exceptions: False</code> then the first exception raised by one of the awaitables is returned to the caller of <code>gather</code>, where as if set to <code>True</code> then the exceptions are aggregated in the list alongside successful results. If <code>gather()</code> is cancelled, all submitted awaitables (that have not completed yet) are also cancelled.</p>
</blockquote>

<h2 id="deprecated-functions">Deprecated functions</h2>

<ul>
<li><code>@asyncio.coroutine</code>: removed in favour of <code>async def</code> in Python 3.10</li>
<li><code>asyncio.sleep</code>: the <code>loop</code> parameter will be removed in Python 3.10</li>
</ul>

<blockquote>
<p>Note: you&rsquo;ll find in most of these APIs a <code>loop</code> argument can be provided to enable you to indicate the specific event loop you want to utilize). It seems Python has deprecated this argument in 3.8, and will remove it completely in 3.10.</p>
</blockquote>

<h2 id="examples">Examples</h2>

<h3 id="gather"><code>gather</code></h3>

<p>The following example demonstrates how to wait for multiple asynchronous tasks to complete.</p>

<pre><code>import asyncio


async def foo(n):
    await asyncio.sleep(5)  # wait 5s before continuing
    print(f&quot;n: {n}!&quot;)


async def main():
    tasks = [foo(1), foo(2), foo(3)]
    await asyncio.gather(*tasks)


asyncio.run(main())
</code></pre>

<h3 id="wait"><code>wait</code></h3>

<p>The following example uses the <code>FIRST_COMPLETED</code> option, meaning whichever task finishes first is what will be returned.</p>

<pre><code>import asyncio
from random import randrange


async def foo(n):
    s = randrange(5)
    print(f&quot;{n} will sleep for: {s} seconds&quot;)
    await asyncio.sleep(s)
    print(f&quot;n: {n}!&quot;)


async def main():
    tasks = [foo(1), foo(2), foo(3)]
    result = await asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED)
    print(result)


asyncio.run(main())
</code></pre>

<p>An example output of this program would be:</p>

<pre><code>1 will sleep for: 4 seconds
2 will sleep for: 2 seconds
3 will sleep for: 1 seconds

n: 3!

(
{&lt;Task finished coro=&lt;foo() done, defined at await.py:5&gt; result=None&gt;}, 
{
&lt;Task pending coro=&lt;foo() running at await.py:8&gt; wait_for=&lt;Future pending cb=[&lt;TaskWakeupMethWrapper object at 0x10322b468&gt;()]&gt;&gt;, 
&lt;Task pending coro=&lt;foo() running at await.py:8&gt; wait_for=&lt;Future pending cb=[&lt;TaskWakeupMethWrapper object at 0x10322b4c8&gt;()]&gt;&gt;
}
)
</code></pre>

<h3 id="wait-for"><code>wait_for</code></h3>

<p>The following example demonstrates how we can utilize a timeout to prevent waiting endlessly for an asynchronous task to finish.</p>

<pre><code>import asyncio


async def foo(n):
    await asyncio.sleep(10)
    print(f&quot;n: {n}!&quot;)


async def main():
    try:
        await asyncio.wait_for(foo(1), timeout=5)
    except asyncio.TimeoutError:
        print(&quot;timeout!&quot;)


asyncio.run(main())
</code></pre>

<blockquote>
<p>Note: the <code>asyncio.TimeoutError</code> doesn&rsquo;t provide any extra information so there&rsquo;s no point in trying to use it in your output (e.g. <code>except asyncio.TimeoutError as err: print(err)</code>).</p>
</blockquote>

<h3 id="as-completed"><code>as_completed</code></h3>

<p>The following example demonstrates how <code>as_complete</code> will yield the first task to complete, followed by the next quickest, and the next until all tasks are completed.</p>

<pre><code>import asyncio
from random import randrange


async def foo(n):
    s = randrange(10)
    print(f&quot;{n} will sleep for: {s} seconds&quot;)
    await asyncio.sleep(s)
    return f&quot;{n}!&quot;


async def main():
    counter = 0
    tasks = [foo(&quot;a&quot;), foo(&quot;b&quot;), foo(&quot;c&quot;)]

    for future in asyncio.as_completed(tasks):
        n = &quot;quickest&quot; if counter == 0 else &quot;next quickest&quot;
        counter += 1
        result = await future
        print(f&quot;the {n} result was: {result}&quot;)


asyncio.run(main())
</code></pre>

<p>An example output of this program would be:</p>

<pre><code>c will sleep for: 9 seconds
a will sleep for: 1 seconds
b will sleep for: 0 seconds

the quickest result was: b!
the next quickest result was: a!
the next quickest result was: c!
</code></pre>

<h3 id="create-task"><code>create_task</code></h3>

<p>The following example demonstrates how to convert a coroutine into a Task and schedule it onto the event loop.</p>

<pre><code>import asyncio


async def foo():
    await asyncio.sleep(10)
    print(&quot;Foo!&quot;)


async def hello_world():
    task = asyncio.create_task(foo())
    print(task)
    await asyncio.sleep(5)
    print(&quot;Hello World!&quot;)
    await asyncio.sleep(10)
    print(task)


asyncio.run(hello_world())
</code></pre>

<p>We can see from the above program that we use <code>create_task</code> to convert our coroutine function into a Task. This automatically schedules the Task to be run on the event loop at the next available tick.</p>

<p>This is in contrast to the lower-level API <code>ensure_future</code> (which is the preferred way of creating new Tasks). The <code>ensure_future</code> function has specific logic branches that make it useful for more input types than <code>create_task</code> which only supports scheduling a coroutine onto the event loop and wrapping it inside a Task (see: <a href="https://github.com/python/cpython/blob/master/Lib/asyncio/tasks.py#L653" target="_blank"><code>ensure_future</code> source code</a>).</p>

<p>The output of this program would be:</p>

<pre><code>&lt;Task pending coro=&lt;foo() running at create_task.py:4&gt;&gt;
Hello World!
Foo!
&lt;Task finished coro=&lt;foo() done, defined at create_task.py:4&gt; result=None&gt;
</code></pre>

<p>Let&rsquo;s review the code and compare to the above output we can see&hellip;</p>

<p>We convert <code>foo()</code> into a Task and then print the returned Task immediately after it is created. So when we print the Task we can see that its status is shown as &lsquo;pending&rsquo; (as it hasn&rsquo;t been executed yet).</p>

<p>Next we&rsquo;ll sleep for five seconds, as this will cause the <code>foo</code> Task to now be run (as the current Task <code>hello_world</code> will be considered busy).</p>

<p>Within the <code>foo</code> Task we also sleep, but for a <em>longer</em> period of time than <code>hello_world</code>, and so the event loop will now context switch <em>back</em> to the <code>hello_world</code> Task, where upon the sleep will pass and we&rsquo;ll print the output string <code>Hello World</code>.</p>

<p>Finally, we sleep again for ten seconds. This is just so we can give the <code>foo</code> Task enough time to complete and print its own output. If we didn&rsquo;t do that then the <code>hello_world</code> task would finish and close down the event loop. The last line of <code>hello_world</code> is printing the <code>foo</code> Task, where we&rsquo;ll see the status of the <code>foo</code> Task will now show as  &lsquo;finished&rsquo;.</p>

<h2 id="callbacks">Callbacks</h2>

<p>When dealing with a Task, which really is a Future, then you have the ability to execute a &lsquo;callback&rsquo; function once the Future has a value set on it.</p>

<p>The following example demonstrates this by modifying the previous <a href="#create_task"><code>create_task</code></a> example code:</p>

<pre><code>import asyncio


async def foo():
    await asyncio.sleep(10)
    return &quot;Foo!&quot;


def got_result(future):
    print(f&quot;got the result! {future.result()}&quot;)


async def hello_world():
    task = asyncio.create_task(foo())
    task.add_done_callback(got_result)
    print(task)
    await asyncio.sleep(5)
    print(&quot;Hello World!&quot;)
    await asyncio.sleep(10)
    print(task)


asyncio.run(hello_world())
</code></pre>

<p>Notice in the above program we add a new <code>got_result</code> function that expects to receive a Future type, and thus calls <code>.result()</code> on the Future.</p>

<p>Also notice that to get this function to be called, we pass it to <code>.add_done_callback()</code> which is called on the Task returned by <code>create_task</code>.</p>

<p>The output of this program is:</p>

<pre><code>&lt;Task pending coro=&lt;foo() running at gather.py:4&gt; cb=[got_result() at gather.py:9]&gt;
Hello World!
got the result! Foo!
&lt;Task finished coro=&lt;foo() done, defined at gather.py:4&gt; result='Foo!'&gt;
</code></pre>

<h2 id="pools">Pools</h2>

<p>When dealing with lots of concurrent operations it might be wise to utilize a &lsquo;pool&rsquo; of threads (and/or subprocesses) to prevent exhausting your application&rsquo;s host resources.</p>

<p>This is where the <code>concurrent.futures</code> module comes in. It provides a concept referred to as an Executor to help with this and which can be run standalone or be integrated into an existing asyncio event loop (see: <a href="https://docs.python.org/3.8/library/concurrent.futures.html#concurrent.futures.Executor" target="_blank">Executor documentation</a>).</p>

<h3 id="executors">Executors</h3>

<p>There are two types of &lsquo;executors&rsquo;:</p>

<ul>
<li><a href="https://docs.python.org/3.8/library/concurrent.futures.html#threadpoolexecutor" target="_blank"><code>ThreadPoolExecutor</code></a></li>
<li><a href="https://docs.python.org/3.8/library/concurrent.futures.html#processpoolexecutor" target="_blank"><code>ProcessPoolExecutor</code></a></li>
</ul>

<p>Let&rsquo;s look at the first way to execute code within one of these executors, by using an asyncio event loop to schedule the running of the executor.</p>

<p>To do this you need to call the event loop&rsquo;s <code>.run_in_executor()</code> function and pass in the executor type as the first argument. If <code>None</code> is provided, then the <em>default</em> executor is used (which is the <code>ThreadPoolExecutor</code>).</p>

<p>The following example is copied verbatim from the <a href="https://docs.python.org/3.8/library/asyncio-eventloop.html#executing-code-in-thread-or-process-pools" target="_blank">Python documentation</a>:</p>

<pre><code>import asyncio
import concurrent.futures


def blocking_io():
    # File operations (such as logging) can block the
    # event loop: run them in a thread pool.
    with open(&quot;/dev/urandom&quot;, &quot;rb&quot;) as f:
        return f.read(100)


def cpu_bound():
    # CPU-bound operations will block the event loop:
    # in general it is preferable to run them in a
    # process pool.
    return sum(i * i for i in range(10 ** 7))


async def main():
    loop = asyncio.get_running_loop()

    # 1. Run in the default loop's executor:
    result = await loop.run_in_executor(None, blocking_io)
    print(&quot;default thread pool&quot;, result)

    # 2. Run in a custom thread pool:
    with concurrent.futures.ThreadPoolExecutor() as pool:
        result = await loop.run_in_executor(pool, blocking_io)
        print(&quot;custom thread pool&quot;, result)

    # 3. Run in a custom process pool:
    with concurrent.futures.ProcessPoolExecutor() as pool:
        result = await loop.run_in_executor(pool, cpu_bound)
        print(&quot;custom process pool&quot;, result)


asyncio.run(main())
</code></pre>

<p>The second way to execute code within one of these executors is to send the code to be executed directly to the pool. This means we don&rsquo;t have to acquire the current event loop to pass the pool into it (as the earlier example demonstrated), but it comes with a caveat which is the parent program won&rsquo;t wait for the task to be completed unless you explicitly tell it to (which I&rsquo;ll demonstrate next).</p>

<p>With that in mind, let&rsquo;s take a look at this alternative approach. It involves calling the executor&rsquo;s <code>submit()</code> method:</p>

<pre><code>import concurrent.futures
import time


def slow_op(*args):
    print(f&quot;arguments: {args}&quot;)
    time.sleep(5)
    print(&quot;slow operation complete&quot;)
    return 123


def do_something():
    with concurrent.futures.ProcessPoolExecutor() as pool:
        future = pool.submit(slow_op, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;)

        for fut in concurrent.futures.as_completed([future]):
            assert future.done() and not future.cancelled()
            print(f&quot;got the result from slow_op: {fut.result()}&quot;)


if __name__ == &quot;__main__&quot;:
    print(&quot;program started&quot;)
    do_something()
    print(&quot;program complete&quot;)
</code></pre>

<blockquote>
<p>Note: be careful with a global process executor (e.g. placing something like <code>PROCESS_POOL = concurrent.futures.ProcessPoolExecutor()</code> within the global scope and using that reference within our <code>do_something()</code> function) as this means when the program is copied into a <em>new</em> process you&rsquo;ll get an error from the Python interpreter about a leaked semaphore. This is why I create the process pool executor within a function.</p>
</blockquote>

<p>One thing worth noting here is that if we hadn&rsquo;t used the <code>with</code> statement (like we do in the above example) it would mean we&rsquo;d not be shutting down the pool once it has finished its work, and so (depending on if your program continues running) you may discover resources aren&rsquo;t being cleaned up.</p>

<p>To solve that problem you can call the <code>.shutdown()</code> method which is exposed to both types of executors via its parent class <code>concurrent.futures.Executor</code>.</p>

<p>Below is an example that does that, but now using the threadpool executor:</p>

<pre><code>import concurrent.futures

THREAD_POOL = concurrent.futures.ThreadPoolExecutor(max_workers=5)


def slow_op(*args):
    with open(&quot;/dev/urandom&quot;, &quot;rb&quot;) as f:
        return f.read(100000)


def do_something():
    future = THREAD_POOL.submit(slow_op, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;)

    THREAD_POOL.shutdown()

    assert future.done() and not future.cancelled()

    print(f&quot;got the result from slow_op: {len(future.result())}&quot;)


if __name__ == &quot;__main__&quot;:
    print(&quot;program started&quot;)
    do_something()
    print(&quot;program complete&quot;)
</code></pre>

<p>Pay attention to the placement of the call to <code>.shutdown()</code>. We no longer have any code to handle waiting for the task to complete. You might have expected calling <code>.shutdown()</code> and then immediately checking if the task is complete (e.g. <code>assert future.done()</code>) to cause an error to be raised as the future is unlikely to be finished.</p>

<blockquote>
<p>Note: remember also if you call <code>.done()</code> on a future when a value has not yet been set, then you&rsquo;ll see an exception such as <code>asyncio.InvalidStateError</code>.</p>
</blockquote>

<p>But no error is raised, and the future is indeed considered &lsquo;done&rsquo; by the time we check it. This is because the shutdown method has a single argument defined called <code>wait</code> and its default value is set to <code>True</code>, which means it would wait for all scheduled tasks to complete before shutting down the executor pool.</p>

<p>Thus the <code>.shutdown()</code> method is a synchronization call (i.e. it ensures all tasks are complete before shutting down, and thus we can guarantee all results will be available).</p>

<p>Now if we had passed <code>.shutdown(wait=False)</code> instead, then the call to <code>future.done()</code> would have raised an exception (as the scheduled task would still be running as the threadpool was being closed), and so in that case we&rsquo;d need to ensure that we use another mechanism for acquiring the results of the scheduled tasks (such as <code>concurrent.futures.as_completed</code> or <code>concurrent.futures.wait</code>).</p>

<h3 id="asyncio-future-vs-concurrent-futures-future"><code>asyncio.Future</code> vs <code>concurrent.futures.Future</code></h3>

<p>One final thing to mention is that a <code>concurrent.futures.Future</code> object is <em>different</em> from an <code>asyncio.Future</code>.</p>

<p>An <code>asyncio.Future</code> is intended to be used with the asyncio&rsquo;s event loop, and is <a href="#awaitables"><em>awaitable</em></a>. A <code>concurrent.futures.Future</code> is <em>not</em> awaitable.</p>

<p>Using the <code>.run_in_executor()</code> method of an event loop will provide the necessary interoperability between the two future types by wrapping the <code>concurrent.futures.Future</code> type in a call to <a href="#asyncio-wrap-future"><code>asyncio.wrap_future</code></a> (see next section for details).</p>

<h3 id="asyncio-wrap-future"><code>asyncio.wrap_future</code></h3>

<p>Since Python 3.5 we can use <code>asyncio.wrap_future</code> to convert a <code>concurrent.futures.Future</code> to an <code>asyncio.Future</code>. An example of this can be seen below&hellip;</p>

<pre><code>import asyncio
import random
from concurrent.futures import ThreadPoolExecutor
from time import sleep


def return_after_5_secs(message):
    sleep(5)
    return message


pool = ThreadPoolExecutor(3)


async def doit():
    identify = random.randint(1, 100)
    future = pool.submit(return_after_5_secs, (f&quot;result: {identify}&quot;))
    awaitable = asyncio.wrap_future(future)
    print(f&quot;waiting result: {identify}&quot;)
    return await awaitable


async def app():
    # run some stuff multiple times
    tasks = [doit(), doit()]

    result = await asyncio.gather(*tasks)
    print(result)

print(&quot;waiting app&quot;)
asyncio.run(app())
</code></pre>

<p>The output of this program would be:</p>

<pre><code>waiting app
waiting result: 62
waiting result: 83

# ...five seconds pass by...

['result: 62', 'result: 83']
</code></pre>

          </section>
        </div>
      </div>
      <!-- Sidebar -->
<div id="sidebar">
  <div class="inner">
    <!-- Search -->
    <!--<section id="search" class="alt">-->
    <!--  <form method="post" action="#">-->
    <!--    <input type="text" name="query" id="query" placeholder="Search" />-->
    <!--  </form>-->
    <!--</section>-->
    <!-- Menu -->
    <nav id="menu">
      <header class="major">
        <h2>Menu</h2>
      </header>
      <ul>
        <li><a href="../../index.html">Home</a></li>
        <!--<li><a href="../resume/index.html">Resume</a></li>-->
				
	<li>
	  <span class="opener">Pages</span>
	  <ul>
		
	<li><a href="../../pages/christmas-movies/index.html">Christmas Movies</a></li>
	
	<li><a href="../../pages/resume/index.html">Resume</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2024</span>
	  <ul>
		
	<li><a href="../../posts/go-concurrency-patterns/index.html">Go Concurrency Patterns</a></li>
	
	<li><a href="../../posts/bitwise-operations-in-go/index.html">Bitwise Operations In Go</a></li>
	
	<li><a href="../../posts/go-typed-nil/index.html">Go Typed Nil</a></li>
	
	<li><a href="../../posts/programming-at-the-edge-with-fastly-compute/index.html">Programming At The Edge With Fastly Compute</a></li>
	
	<li><a href="../../posts/ci-cd-with-terraform-cloud-and-github-actions/index.html">Ci Cd With Terraform Cloud And Github Actions</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2023</span>
	  <ul>
		
	<li><a href="../../posts/openapi/index.html">Openapi</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2022</span>
	  <ul>
		
	<li><a href="../../posts/terraform-build-a-provider/index.html">Terraform Build A Provider</a></li>
	
	<li><a href="../../posts/rust-smart-pointers/index.html">Rust Smart Pointers</a></li>
	
	<li><a href="../../posts/laptop-setup-v2/index.html">Laptop Setup V2</a></li>
	
	<li><a href="../../posts/go-install/index.html">Go Install</a></li>
	
	<li><a href="../../posts/neovim-rust-go/index.html">Neovim Rust Go</a></li>
	
	<li><a href="../../posts/vim-themes/index.html">Vim Themes</a></li>
	
	<li><a href="../../posts/dev-tools/index.html">Dev Tools</a></li>
	
	<li><a href="../../posts/go-style-guide/index.html">Go Style Guide</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2021</span>
	  <ul>
		
	<li><a href="../../posts/vim-advanced/index.html">Vim Advanced</a></li>
	
	<li><a href="../../posts/rust-ownership/index.html">Rust Ownership</a></li>
	
	<li><a href="../../posts/github-actions/index.html">Github Actions</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2020</span>
	  <ul>
		
	<li><a href="../../posts/go-reflection/index.html">Go Reflection</a></li>
	
	<li><a href="../../posts/software-comparison/index.html">Software Comparison</a></li>
	
	<li><a href="../../posts/rate-limiting/index.html">Rate Limiting</a></li>
	
	<li><a href="../../posts/git-internals/index.html">Git Internals</a></li>
	
	<li><a href="../../posts/python-context-managers/index.html">Python Context Managers</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2019</span>
	  <ul>
		
	<li><a href="../../posts/python-generators/index.html">Python Generators</a></li>
	
	<li><a href="../../posts/tox-ini/index.html">Tox Ini</a></li>
	
	<li><a href="../../posts/python-app-dependencies/index.html">Python App Dependencies</a></li>
	
	<li><a href="../../posts/python-asyncio/index.html">Python Asyncio</a></li>
	
	<li><a href="../../posts/go-arrays-and-slices/index.html">Go Arrays And Slices</a></li>
	
	<li><a href="../../posts/anonymity/index.html">Anonymity</a></li>
	
	<li><a href="../../posts/http-caching-guide/index.html">Http Caching Guide</a></li>
	
	<li><a href="../../posts/laptop-setup/index.html">Laptop Setup</a></li>
	
	<li><a href="../../posts/git-multiple-branches/index.html">Git Multiple Branches</a></li>
	
	<li><a href="../../posts/algorithms-in-python/index.html">Algorithms In Python</a></li>
	
	<li><a href="../../posts/remote-working/index.html">Remote Working</a></li>
	
	<li><a href="../../posts/python-mocking/index.html">Python Mocking</a></li>
	
	<li><a href="../../posts/calculating-big-o/index.html">Calculating Big O</a></li>
	
	<li><a href="../../posts/algorithmic-complexity-in-python/index.html">Algorithmic Complexity In Python</a></li>
	
	<li><a href="../../posts/data-types-and-data-structures/index.html">Data Types And Data Structures</a></li>
	
	<li><a href="../../posts/design-python/index.html">Design Python</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2018</span>
	  <ul>
		
	<li><a href="../../posts/js-modern/index.html">Js Modern</a></li>
	
	<li><a href="../../posts/engineer-to-manager/index.html">Engineer To Manager</a></li>
	
	<li><a href="../../posts/interview-techniques/index.html">Interview Techniques</a></li>
	
	<li><a href="../../posts/post-mortems/index.html">Post Mortems</a></li>
	
	<li><a href="../../posts/slackbot-opsbot/index.html">Slackbot Opsbot</a></li>
	
	<li><a href="../../posts/go-interfaces/index.html">Go Interfaces</a></li>
	
	<li><a href="../../posts/multigrain-services/index.html">Multigrain Services</a></li>
	
	<li><a href="../../posts/authentication-with-aws-cognito/index.html">Authentication With Aws Cognito</a></li>
	
	<li><a href="../../posts/a-guide-to-effective-1-1-meetings/index.html">A Guide To Effective 1 1 Meetings</a></li>
	
	<li><a href="../../posts/project-management/index.html">Project Management</a></li>
	
	<li><a href="../../posts/reading-list/index.html">Reading List</a></li>
	
	<li><a href="../../posts/python-security/index.html">Python Security</a></li>
	
	<li><a href="../../posts/static-site-search/index.html">Static Site Search</a></li>
	
	<li><a href="../../posts/interview-topics/index.html">Interview Topics</a></li>
	
	<li><a href="../../posts/go-reverse-proxy/index.html">Go Reverse Proxy</a></li>
	
	<li><a href="../../posts/hashing-encryption-encoding/index.html">Hashing Encryption Encoding</a></li>
	
	<li><a href="../../posts/computers-101/index.html">Computers 101</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2017</span>
	  <ul>
		
	<li><a href="../../posts/statistics-basics/index.html">Statistics Basics</a></li>
	
	<li><a href="../../posts/queue-best-practices/index.html">Queue Best Practices</a></li>
	
	<li><a href="../../posts/monitoring-best-practices/index.html">Monitoring Best Practices</a></li>
	
	<li><a href="../../posts/load-testing-guidelines/index.html">Load Testing Guidelines</a></li>
	
	<li><a href="../../posts/logging-101/index.html">Logging 101</a></li>
	
	<li><a href="../../posts/fastly-varnish/index.html">Fastly Varnish</a></li>
	
	<li><a href="../../posts/profiling-python/index.html">Profiling Python</a></li>
	
	<li><a href="../../posts/profiling-go/index.html">Profiling Go</a></li>
	
	<li><a href="../../posts/dev-environments-within-docker-containers/index.html">Dev Environments Within Docker Containers</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2016</span>
	  <ul>
		
	<li><a href="../../posts/key-architecture/index.html">Key Architecture</a></li>
	
	<li><a href="../../posts/go-hitchhikers-guide/index.html">Go Hitchhikers Guide</a></li>
	
	<li><a href="../../posts/concepts-from-the-c-programming-language/index.html">Concepts From The C Programming Language</a></li>
	
	<li><a href="../../posts/man-pages/index.html">Man Pages</a></li>
	
	<li><a href="../../posts/c-and-syscalls/index.html">C And Syscalls</a></li>
	
	<li><a href="../../posts/bits-and-bytes/index.html">Bits And Bytes</a></li>
	
	<li><a href="../../posts/terminal-password-manager/index.html">Terminal Password Manager</a></li>
	
	<li><a href="../../posts/terminal-utils/index.html">Terminal Utils</a></li>
	
	<li><a href="../../posts/github-pull-request-formatting/index.html">Github Pull Request Formatting</a></li>
	
	<li><a href="../../posts/big-o-for-beginners/index.html">Big O For Beginners</a></li>
	
	<li><a href="../../posts/the-perfect-developer/index.html">The Perfect Developer</a></li>
	
	<li><a href="../../posts/git-merge-strategies/index.html">Git Merge Strategies</a></li>
	
	<li><a href="../../posts/grpc-for-beginners/index.html">Grpc For Beginners</a></li>
	
	<li><a href="../../posts/bash-watchtower/index.html">Bash Watchtower</a></li>
	
	<li><a href="../../posts/rpc-variations-in-go/index.html">Rpc Variations In Go</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2015</span>
	  <ul>
		
	<li><a href="../../posts/go-func-type/index.html">Go Func Type</a></li>
	
	<li><a href="../../posts/github-multiple-ssh/index.html">Github Multiple Ssh</a></li>
	
	<li><a href="../../posts/http2/index.html">Http2</a></li>
	
	<li><a href="../../posts/building-systems-with-make/index.html">Building Systems With Make</a></li>
	
	<li><a href="../../posts/client-cert-authentication/index.html">Client Cert Authentication</a></li>
	
	<li><a href="../../posts/dns-101/index.html">Dns 101</a></li>
	
	<li><a href="../../posts/security-basics/index.html">Security Basics</a></li>
	
	<li><a href="../../posts/docker-nginx/index.html">Docker Nginx</a></li>
	
	<li><a href="../../posts/designing-for-simplicity/index.html">Designing For Simplicity</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2014</span>
	  <ul>
		
	<li><a href="../../posts/concurrency/index.html">Concurrency</a></li>
	
	<li><a href="../../posts/github-workflow/index.html">Github Workflow</a></li>
	
	<li><a href="../../posts/functional-recursive-javascript-programming/index.html">Functional Recursive Javascript Programming</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2013</span>
	  <ul>
		
	<li><a href="../../posts/refactoring-techniques/index.html">Refactoring Techniques</a></li>
	
	<li><a href="../../posts/design-mvcp/index.html">Design Mvcp</a></li>
	
	<li><a href="../../posts/basic-shell-scripting/index.html">Basic Shell Scripting</a></li>
	
	<li><a href="../../posts/clean-coder/index.html">Clean Coder</a></li>
	
	<li><a href="../../posts/message-passing-in-object-oriented-code/index.html">Message Passing In Object Oriented Code</a></li>
	
	<li><a href="../../posts/design-oop/index.html">Design Oop</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2012</span>
	  <ul>
		
	<li><a href="../../posts/git-tips/index.html">Git Tips</a></li>
	
	<li><a href="../../posts/maintainable-css-with-bem/index.html">Maintainable Css With Bem</a></li>
	
	<li><a href="../../posts/host-methods-vs-native-methods/index.html">Host Methods Vs Native Methods</a></li>
	
	<li><a href="../../posts/javascript-101/index.html">Javascript 101</a></li>
	
	  </ul>
	</li>
	
      </ul>
    </nav>
    <!-- Section -->
		<!--
    <section>
      <header class="major">
        <h2>Highlights</h2>
      </header>
      <div class="mini-posts">
        <article>
          <a href="ppv-survivorseries-88.html" class="image"><img src="../images/survivor-88-index.jpg" alt="" /></a>
          <p>Get ready for the ultimate showdown as Survivor Series 1988 brings non-stop tag team action, fierce rivalries, and unforgettable battles between the biggest WWF superstars!</p>
        </article>
        <article>
          <a href="ppv-royalrumble-89.html" class="image"><img src="../images/rumble-89-index.jpg" alt="" /></a>
          <p>Royal Rumble 1989 unleashes chaos with 30 superstars battling for glory in an unforgettable over-the-top-rope showdown!</p>
        </article>
        <article>
          <a href="ppv-summerslam-88.html" class="image"><img src="../images/slam-88-index.jpg" alt="" /></a>
          <p>SummerSlam 1988 delivers explosive action with iconic matchups, as the WWF's biggest stars collide in the hottest event of the summer!</p>
        </article>
      </div>
    </section>
		-->
    <!-- Section -->
    <!--<section>-->
    <!--  <header class="major">-->
    <!--    <h2>Get in touch</h2>-->
    <!--  </header>-->
    <!--  <p>Sed varius enim lorem ullamcorper dolore aliquam aenean ornare velit lacus, ac varius enim lorem ullamcorper dolore. Proin sed aliquam facilisis ante interdum. Sed nulla amet lorem feugiat tempus aliquam.</p>-->
    <!--  <ul class="contact">-->
    <!--    <li class="icon solid fa-envelope"><a href="#">information@untitled.tld</a></li>-->
    <!--    <li class="icon solid fa-phone">(000) 000-0000</li>-->
    <!--    <li class="icon solid fa-home">1234 Somewhere Road #8254<br />-->
    <!--      Nashville, TN 00000-0000</li>-->
    <!--  </ul>-->
    <!--</section>-->
    <!-- Footer -->
    <footer id="footer">
      <p class="copyright">&copy; Integralist. All rights reserved.</p>
      <p class="copyright small">Demo Images: <a href="https://unsplash.com">Unsplash</a>. Design: <a href="https://html5up.net">HTML5 UP</a>.</p>
    </footer>
  </div>
</div>

    </div>
    <!-- Scripts -->
    <script src="../../assets/js/jquery.min.js"></script>
    <script src="../../assets/js/browser.min.js"></script>
    <script src="../../assets/js/breakpoints.min.js"></script>
    <script src="../../assets/js/util.js"></script>
    <script src="../../assets/js/main.js"></script>

		<!-- The following script is for handling the automatic TOC generated by `make build` -->
		<script>
		// Get references to the elements
		const nav = document.querySelector('#main nav');
		const h1 = document.querySelector('#main h1');

		// Move the `nav` element to be underneath the `h1`
		h1.insertAdjacentElement('afterend', nav);

		// Hide the `nav` element by default using inline styles
		nav.style.display = 'none';

		// Create a new `h2` element with the text "TOC"
		const toc = document.createElement('h2');
		toc.textContent = 'TOC';
		toc.className = "toc"

		// Add inline styles to make the `h2` look clickable
		// DISABLED: done with className
		//
		// toc.style.cursor = 'pointer';
		// toc.style.color = 'blue';
		// toc.style.textDecoration = 'underline';

		// Add a click event listener to toggle the visibility of the `nav`
		toc.addEventListener('click', () => {
				nav.style.display = nav.style.display === 'none' ? 'block' : 'none';
		});

		// Insert the `h2` element above the `nav`
		nav.insertAdjacentElement('beforebegin', toc);
		</script>

		<!-- The following script highlights the current page in the side nav -->
		<script>
		// Get the current page's URL path and normalize it
    const currentUrl = window.location.pathname;
    const normalizedCurrentUrl = currentUrl
        .replace(/.*\/(pages|posts)\//, '/$1/') // Ensure leading slash and extract from `pages/` or `posts/`
        .replace(/index\.html$/, ''); // Remove `index.html` suffix

    // Select all menu links
    const links = document.querySelectorAll('#menu ul li a');

    let matchedParentSpan = null;

    links.forEach(link => {
        // Normalize the link's href for comparison
        const normalizedHref = link.getAttribute('href')
            .replace(/^(\.\.\/)+/, '/') // Convert `../../` to `/` for consistency
            .replace(/index\.html$/, ''); // Remove `index.html` suffix

        // Check if the normalized href matches the normalized current URL
        if (normalizedHref === normalizedCurrentUrl) {
            // Add the inline style to the matching link
            link.style.color = 'black';

            // Find the parent span with the class 'opener'
            matchedParentSpan = link.closest('ul').previousElementSibling;
        }
    });

    // If a matching parent span was found, add the 'active' class
    if (matchedParentSpan && matchedParentSpan.classList.contains('opener')) {
        matchedParentSpan.classList.add('active');
    }
		</script>
  </body>
</html>
