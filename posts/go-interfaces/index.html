<!DOCTYPE HTML>
<!--
	Editorial by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
  <head>
    <title>Integralist</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="../../assets/css/main.css" />
  </head>
  <body class="is-preload">
    <!-- Wrapper -->
    <div id="wrapper">
      <!-- Main -->
      <div id="main">
        <div class="inner">
          <!-- Header -->
					<header id="header">
						<a href="../../index.html" class="logo"><strong>Home</strong></a>
							<ul class="icons">
							<!--<li><a href="https://x.com/integralist" class="icon brands fa-twitter" target="blank"><span class="label">Twitter</span></a></li>-->
							<!--<li><a href="https://instagram.com/wwfsuperstarsofwrestling" class="icon brands fa-instagram" target="blank"><span class="label">Instagram</span></a></li>-->
						</ul>
					</header>

          <!-- Content -->
          <section>
						<!--
            <header class="main">
              <h1>Royal Rumble 1989</h1>
              <p>A Bizarre Spectacle Where the Madness Multiplies</p>
            </header>
            <span class="image main"><img src="../images/rumble-89.jpg" alt="" /></span>
						-->
						<nav>

<ul>
<li><a href="#thinking-about-interfaces-in-go">Thinking about Interfaces in Go</a>
<ul>
<li><a href="#interfaces-in-go">Interfaces in Go</a></li>

<li><a href="#name-your-interface-arguments">Name Your Interface Arguments</a></li>

<li><a href="#keep-interfaces-small">Keep Interfaces Small</a></li>

<li><a href="#accept-interfaces-return-concrete-types">Accept Interfaces, Return Concrete Types</a></li>

<li><a href="#don-t-return-concrete-types">Don&rsquo;t Return Concrete Types</a></li>

<li><a href="#use-existing-interfaces">Use Existing Interfaces</a></li>

<li><a href="#don-t-force-interfaces">Don&rsquo;t Force Interfaces</a></li>

<li><a href="#embedding-interfaces">Embedding Interfaces</a></li>

<li><a href="#upgrading-interfaces">Upgrading Interfaces</a></li>

<li><a href="#standard-library-interfaces">Standard Library Interfaces</a></li>

<li><a href="#tight-coupling">Tight Coupling</a></li>

<li><a href="#dependency-injection">Dependency Injection</a></li>

<li><a href="#refactoring-considerations">Refactoring Considerations</a></li>

<li><a href="#testing">Testing</a></li>

<li><a href="#more-flexible-solutions">More flexible solutions?</a></li>

<li><a href="#conclusion">Conclusion</a></li>
</ul></li>
</ul>

</nav>

<h1 id="thinking-about-interfaces-in-go">Thinking about Interfaces in Go</h1>

<p>This post is going to explain the importance of interfaces, and the concept of programming to abstractions (using the <a href="https://golang.org/" target="_blank">Go</a> programming language), by way of a simple example.</p>

<p>While treading what might seem like familiar ground to some readers, this is a fundamental skill to understand because it enables you to design more flexible and maintable services.</p>

<h2 id="interfaces-in-go">Interfaces in Go</h2>

<p>An &lsquo;interface&rsquo; is a contract which describes <em>behaviour</em> (not <em>data</em>).</p>

<p><a href="https://medium.com/@andreiboar/7-common-interface-mistakes-in-go-1d3f8e58be60" target="_blank">Andrei Boar</a> said&hellip;</p>

<blockquote>
<p>When defining interfaces in Go, you don‚Äôt define what something <em>is</em> but what it <em>provides</em> ‚Äî behavior, not things! That‚Äôs why there‚Äôs no File interface in Go, but a Reader and a Writer: these are behaviors, and File is a thing implementing Reader and Writer.</p>
</blockquote>

<p>&hellip;which is important because this has a direct effect on the naming of an
interface. You name interfaces with an <em>-er</em> at the end to indicate it&rsquo;s a verb
(i.e. this thing <em>does</em> something).</p>

<p>In Go an interface is defined like so:</p>

<pre><code class="language-go">type Fooer interface {
    Bar(s string) (string, error)
}
</code></pre>

<blockquote>
<p><strong>NOTE</strong>: In Go, a capitalised name (method, field etc) is public, lowercase is private.</p>
</blockquote>

<p>If an object in your code implements a <code>Bar</code> function, with the exact same signature (e.g. accepts a string and returns either a string or an error), then that object is said to <em>implement</em> the <code>Fooer</code> interface.</p>

<p>An example of this would be:</p>

<pre><code class="language-go">type thing struct{}

func (l *thing) Bar(s string) (string, error) {
  ...
}
</code></pre>

<p>Now you can define a function that will accept that object, as long as it fulfils the <code>Fooer</code> interface, like so:</p>

<pre><code class="language-go">func doStuffWith(thing Foo)
</code></pre>

<p>This is different to other languages, where you have to <em>explicitly</em> assign an interface type to an object, like with Java:</p>

<pre><code class="language-java">class testClass implements Foo
</code></pre>

<p>Because of this flexibility in how interfaces are &lsquo;applied&rsquo;, it also means that an object could end up implementing <em>multiple</em> interfaces.</p>

<p>For example, imagine we have the following two interfaces:</p>

<pre><code class="language-go">type Fooer interface {
  Bar(s string) (string, error)
}

type Beeper interface {
  Beep(s string) (string, error)
}
</code></pre>

<p>We can define an object that fulfils <em>both</em> interfaces simply by implementing the functions they define:</p>

<pre><code class="language-go">type thing struct{}

func (l *thing) Bar(s string) (string, error) {
  ...
}

func (l *thing) Beep(s string) (string, error) {
  ...
}
</code></pre>

<blockquote>
<p><strong>NOTE</strong>: This is a bit of silly example, and so you&rsquo;ll notice the method signature for each type is effectively the same. Be careful when designing your interfaces, because in this case we could possibly combine these two interfaces into a single (more generic) interface.</p>
</blockquote>

<h2 id="name-your-interface-arguments">Name Your Interface Arguments</h2>

<p>Consider the following interface:</p>

<pre><code class="language-go">type Mover interface {
  Move(context.Context, string, string) error
}
</code></pre>

<p>Do you know what the second and third arguments refer to and how the function will use them?</p>

<p>Now consider this refactored version where the arguments have names associated with them:</p>

<pre><code class="language-go">type Mover interface {
  Move(context.Context, source string, destination string) error
}
</code></pre>

<p>Now <em>that</em> is better, because we can clearly see what the expectations are: the second argument is the &lsquo;source&rsquo; and the third argument is the &lsquo;destination&rsquo;.</p>

<h2 id="keep-interfaces-small">Keep Interfaces Small</h2>

<p>You&rsquo;ll find in the <a href="https://go-proverbs.github.io/" target="_blank">Go Proverbs</a>, the following useful tip:</p>

<blockquote>
<p>The bigger the interface, the weaker the abstraction.</p>
</blockquote>

<p>The reason for this is due to how interfaces are designed in Go and the fact that an object can potentially support multiple interfaces.</p>

<p>By making an interface too big, we reduce an object&rsquo;s ability to support it. Consider the following example:</p>

<pre><code class="language-go">type FooBeeper interface {
  Bar(s string) (string, error)
  Beep(s string) (string, error)
}

type thing struct{}

func (l *thing) Bar(s string) (string, error) {
  ...
}

func (l *thing) Beep(s string) (string, error) {
  ...
}

type differentThing struct{}

func (l *differentThing) Bar(s string) (string, error) {
  ...
}

type anotherThing struct{}

func (l *anotherThing) Beep(s string) (string, error) {
  ...
}
</code></pre>

<p>In the above example we&rsquo;ve defined a <code>FooBeeper</code> interface that requires two methods: <code>Bar</code> and <code>Beep</code>. Now if we look at the various objects we&rsquo;ve defined <code>thing</code>, <code>differentThing</code> and <code>anotherThing</code> we&rsquo;ll find:</p>

<ul>
<li><code>thing</code>: fulfils the <code>FooBeeper</code> interface</li>
<li><code>differentThing</code>: does <em>not</em> fulfil the <code>FooBeeper</code> interface</li>
<li><code>anotherThing</code>: does <em>not</em> fulfil the <code>FooBeeper</code> interface</li>
</ul>

<p>Alternatively, if we were to break the <code>FooBeeper</code> interface up into separate smaller interfaces (like we demonstrated earlier), then in our above example, the <code>differentThing</code> and <code>anotherThing</code> would become more re-usable.</p>

<p>That&rsquo;s ultimately what this Go proverb is suggesting: smaller interfaces allow for greater code reuse.</p>

<h2 id="accept-interfaces-return-concrete-types">Accept Interfaces, Return Concrete Types</h2>

<p>If your function accepts a concrete type then you&rsquo;ve limited the consumers ability to provide different implementations.</p>

<p>Consider a function only accepting the concrete type <code>*os.File</code> instead of the <code>io.Writer</code> interface. Now try swapping out the <code>os.File</code> implementation in a test environment, you&rsquo;ll have a hard time vs mocking this using a struct that has the relevant interface methods.</p>

<p>Unless there is a good reason to, you should return concrete types instead of interfaces. This is because an interface has a tendency to add an unnecessary layer of indirection for consumers of your package (although we&rsquo;ll discover a few valid scenarios where returning an interface is more appropriate).</p>

<p>Below is an example of what I mean by <em>indirection</em>. We have a function <code>foo</code> that returns the interface <code>Fooer</code>, and yet we want to access a field on the underlying type of the interface (which we can see is a <code>S</code> struct type):</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;log&quot;
)

type Fooer interface {
	Bar()
}

type S struct {
	Debug bool
}

func (s S) Bar() {
	fmt.Println(&quot;bar called&quot;)
}

func foo() Fooer {
	return S{true}
}

func main() {
	f := foo()
	fmt.Printf(&quot;Type: %T\n&quot;, f) // main.S
	fmt.Printf(&quot;Representation: %+v\n&quot;, f) // {Debug:true}
	f.Bar()
	fmt.Println(f.Debug) // ERROR: f.Debug undefined (type Fooer has no field or method Debug)
}
</code></pre>

<p>We can see from the above code that we&rsquo;re able to call the <code>Bar</code> method (as it&rsquo;s part of the public interface) but we can&rsquo;t access the <code>Debug</code> field, even though it&rsquo;s declared as a public field.</p>

<p>So how can we access the <code>Debug</code> field? We need to use a <a href="https://go.dev/tour/methods/15" target="_blank">type assertion</a> to get access to the interface&rsquo;s underlying value:</p>

<pre><code class="language-go">s, ok := f.(S)
if !ok {
  log.Fatal(&quot;couldn't coerce f to S&quot;)
}
fmt.Println(s.Debug) // true
</code></pre>

<p>This is the &lsquo;indirection&rsquo; I was referring to, and is a tedious step for a consumer of this code. They wouldn&rsquo;t need to do this if our <code>foo</code> function had returned the concrete <code>S</code> type.</p>

<h2 id="don-t-return-concrete-types">Don&rsquo;t Return Concrete Types</h2>

<p>This is to keep you on your toes üòâ</p>

<p>I want to highlight an important &lsquo;design&rsquo; decision, which is: if your code returns a pointer to some data, then it means once that pointer has been passed around a few different functions, we now have multiple entities that are able to mutate that data.</p>

<p>So be careful about whether you return a value (immutable) vs a pointer (mutable) as it could help reduce confusion with regards to how the data is modified by your program.</p>

<p>Returning an interface in these cases <em>could</em> be an appropriate solution.</p>

<p><strong>By this I mean</strong>: although you might return a pointer to a data structure, by defining an interface around the behaviours attached to that data structure, it means a caller of your function won&rsquo;t be able to access the internal fields of the struct but it <em>can</em> call the methods defined in the returned interface!</p>

<p>Another example might be that your function needs to return a different type depending on a runtime condition (<code>*cough* generics *cough*</code>). If that&rsquo;s the case, then returning an interface could again be an appropriate workaround to the lack of generics in the Go 1.x language.</p>

<p>The following code example highlights the principle:</p>

<pre><code class="language-go">type Itemer interface {
	GetItemValue() string
}

type Item struct {
	ID int
}

type URLItem struct {
	Item
	URL string
}

type TextItem struct {
	Item
	Text string
}

func (ui URLItem) GetItemValue(){
	return ui.URL
}

func (ti TextItem) GetItemValue(){
	return ti.Text
}

func FindItem(ID int) Itemer {
  // returns either a URLItem or a TextItem
}
</code></pre>

<p>The <code>FindItem</code> could be an internal library function that attempts to locate an item via multiple data sources. Depending on which data source the item was found, the type returned will change.</p>

<p>In this instance returning an interface allows the consumer to not have to worry about the change in underlying data types.</p>

<blockquote>
<p><strong>NOTE</strong>: It&rsquo;s possible the returned types could be consolidated into a single generic type struct, which means we can avoid returning an interface, but it depends on the exact scenario/use case.</p>
</blockquote>

<h2 id="use-existing-interfaces">Use Existing Interfaces</h2>

<p>It&rsquo;s important to not &lsquo;reinvent the wheel&rsquo; and to utilise existing interfaces wherever possible (otherwise you&rsquo;ll suffer from a condition known as &lsquo;interface pollution&rsquo;).</p>

<p>The golang toolchain offers a tool called <a href="https://docs.google.com/document/d/1_Y9xCEMj5S-7rv2ooHpZNH15JgRT5iM742gJkw5LtmQ/edit#heading=h.7q1t7o2y7td3" target="_blank">Go Guru</a> which helps you to navigate Go code.</p>

<p>It&rsquo;s a command line tool, but it&rsquo;s designed to be utilised from within an editor (like Atom or Vim etc).</p>

<p>Here is a list of the sub commands available:</p>

<pre><code>callees         show possible targets of selected function call
callers         show possible callers of selected function
callstack       show path from callgraph root to selected function
definition      show declaration of selected identifier
describe        describe selected syntax: definition, methods, etc
freevars        show free variables of selection
implements      show 'implements' relation for selected type or method
peers           show send/receive corresponding to selected channel op
pointsto        show variables the selected pointer may point to
referrers       show all refs to entity denoted by selected identifier
what            show basic information about the selected syntax node
whicherrs       show possible values of the selected error variable
</code></pre>

<p>This can be really useful for identifying (for example) whether a new interface you&rsquo;ve defined is similar to an existing interface.</p>

<p>To demonstrate this, consider the following example&hellip;</p>

<pre><code class="language-go">// this is a duplicate of fmt.Stringer interface
type Stringer interface {
	String() string
}

type testthing struct{}

func (t testthing) String() string {
	return &quot;a test thing&quot;
}
</code></pre>

<p>The <code>Stringer</code> interface I&rsquo;ve defined is actually a duplication of the existing standard library interface <code>fmt.Stringer</code>.</p>

<p>So using Guru via my Vim editor I can see (when I have my cursor over the <code>testthing</code> struct and I call Guru) that this concrete type implements not only <code>stringit</code> but a few other interfaces&hellip;</p>

<pre><code>/main.go:33.6-33.14:                                                 struct type testthing
/usr/local/Cellar/go/1.10.3/libexec/src/fmt/print.go:62.6-62.13:     implements fmt.Stringer
/main.go:29.6-29.13:                                                 implements Stringer
/usr/local/Cellar/go/1.10.3/libexec/src/runtime/error.go:66.6-66.13: implements runtime.stringer
</code></pre>

<p>Now whether you continue to define a new interface is up to you. There are actually quite a few places in the Go standard library where interfaces are duplicated for (what I believe to be) semantic reasoning, but otherwise if you don&rsquo;t need to make an explicit/semantic distinction, then I&rsquo;d opt to reuse an existing interface.</p>

<blockquote>
<p><strong>NOTE</strong>: For more details on how to use Guru, see <a href="https://gist.github.com/Integralist/20ff7427d3df5cc02d5a619ca0cd9695" target="_blank">this gist</a>.</p>
</blockquote>

<h2 id="don-t-force-interfaces">Don&rsquo;t Force Interfaces</h2>

<p>If your code doesn&rsquo;t require interfaces, then don&rsquo;t use them.</p>

<p>No point making the design of your code more complicated for no reason. Consider the following code which returns an interface.</p>

<blockquote>
<p><strong>NOTE</strong>: The following example is modified from a much older post by <a href="https://www.ardanlabs.com/blog/2016/10/avoid-interface-pollution.html" target="_blank">William Kennedy</a>.</p>
</blockquote>

<pre><code class="language-go">package main

import &quot;fmt&quot;

// Server defines a contract for tcp servers.
type Server interface {
	Start()
}

type server struct{}

// NewServer returns an interface value of type Server
func NewServer() Server {
	return &amp;server{}
}

// Start allows the server to begin to accept requests.
func (s *server) Start() {
	fmt.Println(&quot;start called&quot;)
}

func main() {
	s := NewServer()
	fmt.Printf(&quot;%+v (%T)\n&quot;, s, s)
	s.Start()
}
</code></pre>

<p>The use of an interface here is a bit pointless. We should instead just return a pointer to an exported version of the server struct because the user is gaining no benefits from an interface being returned by <code>NewServer</code> (see <a href="#don-t-return-concrete-types">Don&rsquo;t Return Concrete Types</a> for a possible use case for returning interfaces, but the above example is not one of them).</p>

<p>‚ö†Ô∏è There is also an important performance consideration to using interfaces that is often neglected: method calls on an interface type will be using <a href="https://en.wikipedia.org/wiki/Dynamic_dispatch" target="_blank">dynamic dispatch</a> not <a href="https://en.wikipedia.org/wiki/Static_dispatch" target="_blank">static dispatch</a> and in a code hot path that can be a problem because the memory associated with the call can escape to the heap (stack memory is much more efficient). Consider <code>r</code> had an interface type <code>io.Reader</code>. A call to <code>r.Read(b)</code> would result in both the value of <code>r</code> and the backing array of the <code>b</code> byte slice to be allocated onto the heap.</p>

<h2 id="embedding-interfaces">Embedding Interfaces</h2>

<p>Sometimes a code base will define a very large interface. Now we can probably agree it&rsquo;s not a good idea but let&rsquo;s just accept that in the real-world this kind of thing happens.</p>

<p>One place where a large interface can cause problems is with testing.</p>

<p>If a function accepts an interface but in reality only uses one method from the interface, then you might find yourself getting frustrated at the idea of having to implement a mock version of each method!</p>

<p>Well, to avoid that situation try taking advantage of Go&rsquo;s ability to embed an interface into a struct.</p>

<p>By embedding the interface into your struct, you automatically <em>promote</em> all of the methods to the embedding struct. Now, you can pass your mock struct to the function and the compiler will be happy. You now only need to implement the methods you need to assert the test scenario you&rsquo;re trying to validate.</p>

<pre><code class="language-go">type Exampler interface {
	Foo() error
	Bar() error
	Baz() error
	// ...lots more...
}

func example(e Exampler) error {
  err := e.Foo()
  if err != nil {
    return err
  }

  // ...other stuff...

  return nil
}

type mock struct{
  Example // embedded interface
}

// We're only implementing one method, not all three!
func (m *mock) Foo() error {
  return errors.New(&quot;whoops&quot;)
}

func TestExample(t *testing.T) {
    example(&amp;mock{}) // we expect the function to fail due to our mock behaviour
}
</code></pre>

<p>But be aware that because you&rsquo;re not providing a concrete implementation of the interface when instantiating your struct, it means that the value of that embedded field will be <code>nil</code>. This means that if the function you pass your struct into calls any of the interface methods <em>not</em> implemented by your mock struct, then there will be a runtime &lsquo;nil pointer dereference&rsquo; error (but I argue that&rsquo;s a good thing because in a test environment you want to know if your code is calling something for real).</p>

<h2 id="upgrading-interfaces">Upgrading Interfaces</h2>

<p>If you use have an interface that&rsquo;s used by lots of people, how do you add a new method to it without breaking their code? The moment you add a new method to the interface, their existing code that handles the concrete implementation will fail.</p>

<p>Unfortunately there isn&rsquo;t a completely clean solution to this problem. In essence the original interface needs to stay untouched and we need to define a <em>new</em> interface that contains the new behaviour. Then the consumer&rsquo;s of an interface will continue to reference the original interface while using a type assertion within their functions for the new interface.</p>

<p>Below is an example of this problem in action:</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

type Fooer interface {
	bar() string
	baz() string // new method added, which breaks the code
}

func doThing(f Fooer) {
	fmt.Println(&quot;bar:&quot;, f.bar())
}

type point struct {
	X, Y int
}

func (p point) bar() string {
	return fmt.Sprintf(&quot;p=%d, y=%d&quot;, p.X, p.Y)
}

func main() {
	var pt point
	pt.X = 1
	pt.Y = 2

	doThing(pt)
}
</code></pre>

<p>In the above code we can see we have added a new method <code>baz</code> to our <code>Fooer</code> interface which means the concrete implementation <code>pt</code> is no longer satisfying the <code>Fooer</code> interface as it has no <code>baz</code> method.</p>

<blockquote>
<p><strong>NOTE</strong>: I appreciate the example is a bit silly because we could just update the code to support the new interface, but we have to imagine a world where your interface is provided as part of a public package that is consumed by lots of users.</p>
</blockquote>

<p>To solve this problem we need an intermediate interface. The following example demonstrates the process. The steps are&hellip;</p>

<ol>
<li>define a new interface containing the new method</li>
<li>add the method to the concrete type implementation</li>
<li>document the new interface and ask your interface consumers to type assert for it</li>
</ol>

<pre><code class="language-go">package main

import &quot;fmt&quot;

type Fooer interface {
	bar() string
}

type Newfooer interface {
	baz() string
}

// We want a `Fooer` interface type, but if that valid type can also do the new
// behaviour, then we'll execute that behaviour...

func doThing(f Fooer) {
	if nf, ok := f.(Newfooer); ok {
		fmt.Println(&quot;baz:&quot;, nf.baz())
	}
	fmt.Println(&quot;bar:&quot;, f.bar())
}

// Original concrete implementation...

type point struct {
	X, Y int
}

func (p point) bar() string {
	return fmt.Sprintf(&quot;p=%d, y=%d&quot;, p.X, p.Y)
}

// New concrete implementation of `point` struct (has the new method)...

type newpoint struct {
	point
}

func (np newpoint) baz() string {
	return fmt.Sprintf(&quot;np !!! %d, ny !!! %d&quot;, np.X, np.Y)
}

func main() {
	var pt point
	pt.X = 1
	pt.Y = 2

	doThing(pt)

	var npt newpoint
	npt.X = 3
	npt.Y = 4

	doThing(npt)
}
</code></pre>

<blockquote>
<p><strong>NOTE</strong>: Again, the example is a bit silly in that we&rsquo;re handling everything within a single file, whereas in reality the consumer won&rsquo;t have access to the original interface/implementation code like we do here (so just use your imagination üôÇ).</p>
</blockquote>

<p>The output of the above code is as follows:</p>

<pre><code>bar: p=1, y=2
baz: np !!! 3, ny !!! 4
bar: p=3, y=4
</code></pre>

<p>So we can see we called <code>doThing</code> and passed a concrete type that satisfied the <code>Fooer</code> interface and so that function called the <code>bar</code> method it was expecting to exist. Next we called <code>doThing</code> again but passed a different concrete type that not only satisfied the <code>Fooer</code> interface, but the <code>Newfooer</code> interface and within <code>doThing</code> we type assert that the object passed in is not only a <code>Fooer</code> but a <code>Newfooer</code>.</p>

<p>What would this look like in practice then? Well, if the Go standard library wanted to add a new method to the existing (and very popular) <code>net/http</code> package <code>ResponseWriter</code> interface: they would create a new interface with just the new behaviour defined, then they would document its existence and in that documentation they would explain that if your HTTP handler required the new behaviour, then you should type assert for it.</p>

<p>Imagine if the go standard library just updated the <code>ResponseWriter</code> with the new method? Lots and lots of existing HTTP server code would break as the concrete implementation that was passed through would not support that implementation.</p>

<p>In fact this is exactly what the go standard library authors have done with the <a href="https://golang.org/pkg/net/http/#Flusher" target="_blank"><code>Flusher</code></a> and <a href="https://golang.org/pkg/net/http/#Hijacker" target="_blank"><code>Hijacker</code></a> interfaces. The following code demonstrates the use of a type assertion to access the additional behaviour defined by those interfaces:</p>

<pre><code class="language-go">func(w http.ResponseWriter, r *http.Request) {
        io.WriteString(w, &quot;This will arrive before... &quot;)

        if fl, ok := w.(http.Flusher); ok {
                fl.Flush()
                time.Sleep(1 * time.Second)
        }

        io.WriteString(w, &quot;...this bit does.&quot;)
}
</code></pre>

<h2 id="standard-library-interfaces">Standard Library Interfaces</h2>

<p>Imagine we have a function <code>process</code>, whose responsibility is to make a HTTP request and do something with the response data:</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;io/ioutil&quot;
	&quot;net/http&quot;
)

func process(n int) (string, error) {
	url := fmt.Sprintf(&quot;http://httpbin.org/links/%d/0&quot;, n)

	resp, err := http.Get(url)
	if err != nil {
		fmt.Printf(&quot;url get error: %s\n&quot;, err)
		return &quot;&quot;, err
	}

	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		fmt.Printf(&quot;body read error: %s\n&quot;, err)
		return &quot;&quot;, err
	}

	return string(body), nil
}

func main() {
	data, err := process(5)
	if err != nil {
		fmt.Printf(&quot;\ndata processing error: %s\n&quot;, err)
		return
	}
	fmt.Printf(&quot;Success: %v&quot;, data)
}
</code></pre>

<p>We can see our <code>process</code> function accepts an integer, which is interpolated into the URL that is requested. We then use the <code>http.Get</code> function from the <a href="https://golang.org/pkg/net/http/" target="_blank">net/http</a> package to request the URL.</p>

<p>The function then stringify&rsquo;s the response body and returns it. This is sufficient for a basic example, but in the real world this function would likely do lots more processing to the response data.</p>

<p>It may not be immediately obvious but there are already many instances where interfaces are being utilised. Let&rsquo;s break down the code and see what interfaces there are.</p>

<p>The <code>http.Get</code> function returns a pointer to a <code>http.Response</code> struct, and from within that struct we extract the <code>Body</code> field and pass it to <code>ioutil.ReadAll</code>.</p>

<p>The <code>Body</code> field&rsquo;s &lsquo;type&rsquo; is set to the <a href="https://golang.org/src/io/io.go?s=4977:5022#L116" target="_blank"><code>io.ReadCloser</code></a> interface. If we look at that interface we&rsquo;ll see it&rsquo;s made up of <em>nested</em> interface types:</p>

<pre><code class="language-go">type ReadCloser interface {
    Reader
    Closer
}
</code></pre>

<p>If we now look at the <a href="https://golang.org/src/io/io.go?s=3303:3363#L67" target="_blank"><code>io.Reader</code></a> and <a href="https://golang.org/src/io/io.go?s=4043:4083#L88" target="_blank"><code>io.Closer</code></a> interfaces, we&rsquo;ll find:</p>

<pre><code class="language-go">type Reader interface {
    Read(p []byte) (n int, err error)
}

type Closer interface {
    Close() error
}
</code></pre>

<p>This means that for the response body object to be valid, it must support the <code>Read</code> and <code>Close</code> functions defined by these interfaces (the returned object will likely include other functions, but it needs <code>Read</code> and <code>Close</code> at a minimum).</p>

<p>The next thing that happens in the code is that we pass <code>http.Response.Body</code> to an input/output function called <code>ioutil.ReadAll</code>.</p>

<p>If we look at the signature of <code>ioutil.ReadAll</code> we&rsquo;ll see that it accepts a type of <code>io.Reader</code>, which we&rsquo;ve seen already, and so this is another indication of why smaller interfaces enable re-usability.</p>

<p>What the <code>io.Reader</code> interface means for our code is that the input we provide to <code>ioutil.ReadAll</code> must support a <code>Read</code> function, and (because <code>http.Response.Body</code> implements the <code>io.ReadCloser</code> interface) we know it does implement that required function.</p>

<p>So already we&rsquo;ve seen quite a few built-in interfaces being utilised to support the standard library code we&rsquo;re using. More importantly, you&rsquo;ll find the use of these interfaces (<code>io.ReadCloser</code>, <code>io.Reader</code>, <code>io.Closer</code> and others) are used <em>everywhere</em> in the Go codebase (highlighting again how small interfaces enable greater code re-usability).</p>

<h2 id="tight-coupling">Tight Coupling</h2>

<p>Now there&rsquo;s an issue with the above code, specifically the <code>process</code> function, and that is we&rsquo;ve tightly coupled the <code>net/http</code> package to the function.</p>

<p>What this means is that the <code>process</code> function has to intrinsically <em>know</em> about HTTP and dealing with the various methods available to that package.</p>

<p>Also, if we want to test this function we&rsquo;re going to have a harder time because the <code>http.Get</code> call would need to be mocked somehow. We don&rsquo;t want our test suite to have to rely on a stable network connection or the fact that the endpoint being requested might be down for maintenance.</p>

<p>The solution to this problem is to invert the responsibility of the <code>process</code> function, also known as &lsquo;dependency injection&rsquo;. This is the basis of one of the <a href="https://en.wikipedia.org/wiki/SOLID" target="_blank">S.O.L.I.D</a> principles: &lsquo;inversion of control&rsquo;.</p>

<h2 id="dependency-injection">Dependency Injection</h2>

<p>If we call a function, then it is our responsibility to provide it with all the things it needs in order to do its job.</p>

<p>In the case of our <code>process</code> function, it needs to be able to acquire data from somewhere (that could be a file, it could be a remote procedure call, it shouldn&rsquo;t matter). The most important aspect to consider is <em>how</em> it acquires that data.</p>

<p>The <em>how</em> is not the responsibility of the <code>process</code> function, especially if we decide later on that we want to change the implementation from HTTP to GRPC or some other data source.</p>

<p>Meaning, we need to provide that functionality to the <code>process</code> function. Let&rsquo;s see what this might look like in practice:</p>

<blockquote>
<p><strong>NOTE</strong>: This is just a first iteration, and is a poor design because although it shifts the problem slightly, there will still be tight coupling. I&rsquo;ll come back to this code later and refactor away the coupling completely. The reason I&rsquo;ve not done that upfront is because there are learnings to be had from trying to write tests for this code (which we&rsquo;ll see in a minute).</p>
</blockquote>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;io/ioutil&quot;
	&quot;net/http&quot;
)

type Getter interface {
	Get(url string) (*http.Response, error)
}

type httpbin struct{}

func (l *httpbin) Get(url string) (*http.Response, error) {
	resp, err := http.Get(url)
	if err != nil {
		fmt.Printf(&quot;url get error: %s\n&quot;, err)
		return &amp;http.Response{}, err
	}

	return resp, nil
}

func process(n int, g Getter) (string, error) {
	url := fmt.Sprintf(&quot;http:/httpbin.org/links/%d/0&quot;, n)

	resp, err := g.Get(url)
	if err != nil {
		fmt.Printf(&quot;data source get error: %s\n&quot;, err)
		return &quot;&quot;, err
	}

	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		fmt.Printf(&quot;body read error: %s\n&quot;, err)
		return &quot;&quot;, err
	}

	return string(body), nil
}

func main() {
	data, err := process(5, &amp;httpbin{})
	if err != nil {
		fmt.Printf(&quot;\ndata processing error: %s\n&quot;, err)
		return
	}
	fmt.Printf(&quot;\nSuccess: %v\n&quot;, data)
}
</code></pre>

<h2 id="refactoring-considerations">Refactoring Considerations</h2>

<p>Let&rsquo;s start by looking at the interface we&rsquo;ve defined:</p>

<pre><code class="language-go">type Getter interface {
	Get(url string) (*http.Response, error)
}
</code></pre>

<p>We&rsquo;ve not been overly explicit when naming this interface <code>Getter</code>. Its name is quite generic on purpose so as not to imply an underlying implementation bias.</p>

<p>Unfortunately the defined <code>Get</code> method is still too tightly coupled to a specific implementation (i.e. it specifies <code>http.Response</code> as a return type).</p>

<p>Meaning, that although the refactored code is <em>better</em>, it is far from perfect.</p>

<p>Next we define our own object for handling the implementation of the <code>Get</code> method, which internally is going to use <code>http.Get</code> to acquire the data:</p>

<pre><code class="language-go">type httpbin struct{}

func (l *httpbin) Get(url string) (*http.Response, error) {
	resp, err := http.Get(url)
	if err != nil {
		fmt.Printf(&quot;url get error: %s\n&quot;, err)
		return &amp;http.Response{}, err
	}

	return resp, nil
}
</code></pre>

<p>By using this interface as the accepted type in the <code>process</code> function signature, we&rsquo;re going to be able to decouple the function from having to acquire the data, and thus allow testing to become much easier (as we&rsquo;ll see shortly), but the <code>process</code> function is still fundamentally coupled to HTTP as the underlying transport mechanism.</p>

<p>The reason this is a problem is because the <code>process</code> function still <em>knows</em> that the returned object is a <code>http.Response</code> because it has to reference the <code>Body</code> field of the response, which isn&rsquo;t defined on the object we&rsquo;ve injected (meaning the function intrinsically <em>knows</em> of its existence).</p>

<p>How far you take your interface design is up to you. You don&rsquo;t necessarily have to solve all possible concerns at once (unless there really is a need to do so).</p>

<p>Meaning, this refactor <em>could</em> be considered &lsquo;good enough&rsquo; for your use cases. Alternatively your values and standards may differ, and so you need to consider your options for how you might what to design this solution in such a way that it would allow the code to not be so reliant on HTTP as the transport mechanism.</p>

<blockquote>
<p><strong>NOTE</strong>: We&rsquo;ll revisit this code later and consider another refactor that will help clean up this first pass of code decoupling.</p>
</blockquote>

<p>But first, let&rsquo;s look at how we might want to test this initial code refactor (as testing this code allows us to learn some interesting things when it comes to needing to mock interfaces).</p>

<h2 id="testing">Testing</h2>

<p>Below is a simple test suite that demonstrates how we&rsquo;re now able to construct our own object, with a stubbed response, and pass that to the <code>process</code> function:</p>

<pre><code class="language-go">package main

import (
	&quot;bytes&quot;
	&quot;io/ioutil&quot;
	&quot;net/http&quot;
	&quot;testing&quot;
)

type fakeHTTPBin struct{}

func (l *fakeHTTPBin) Get(url string) (*http.Response, error) {
	body := &quot;Hello World&quot;

	resp := &amp;http.Response{
		Body:          ioutil.NopCloser(bytes.NewBufferString(body)),
		ContentLength: int64(len(body)),
		StatusCode:    http.StatusOK,
		Request:       &amp;http.Request{},
	}

	return resp, nil
}

func TestBasics(t *testing.T) {
	expect := &quot;Hello World&quot;
	actual, _ := process(5, &amp;fakeHTTPBin{})

	if actual != expect {
		t.Errorf(&quot;expected %s, actual %s&quot;, expect, actual)
	}
}
</code></pre>

<p>Much like we do in the real implementation, we define a struct (in this case we&rsquo;ve named it more explicitly) <code>fakeHTTPBin</code>.</p>

<p>The difference now, and what allows us to test our code is that we&rsquo;re manually creating a <code>http.Response</code> object with dummy data.</p>

<p>One part of this code that requires some extra explanation would be the value assigned to the response <code>Body</code> field:</p>

<pre><code class="language-go">ioutil.NopCloser(bytes.NewBufferString(body))
</code></pre>

<p>If we remember from earlier:</p>

<blockquote>
<p>The <code>Body</code> field&rsquo;s &lsquo;type&rsquo; is set to the <code>io.ReadCloser</code> interface.</p>
</blockquote>

<p>This means when mocking the <code>Body</code> value we need to return something that has both a <code>Read</code> and <code>Close</code> method. So we&rsquo;ve used <code>ioutil.NopCloser</code> which, if we look at its signature, we see returns an <code>io.ReadCloser</code> interface:</p>

<pre><code class="language-go">func NopCloser(r io.Reader) io.ReadCloser
</code></pre>

<p>The <code>io.ReadCloser</code> interface is exactly what we need (as that interface indicates the returned concrete type will indeed implement the required <code>Read</code> and <code>Close</code> methods).</p>

<p>But to use it we need to provide the <code>NopCloser</code> function something that supports the <code>io.Reader</code> interface.</p>

<p>If we were to provide a simple string like <code>&quot;Hello World&quot;</code>, then this wouldn&rsquo;t implement the required interface. So we wrap the string in a call to <code>bytes.NewBufferString</code>.</p>

<p>The reason we do this is because the returned type is something that supports the <code>io.Reader</code> interface we need.</p>

<p>But that might not be immediately obvious when looking at the signature for <code>bytes.NewBufferString</code>:</p>

<pre><code class="language-go">func NewBufferString(s string) *Buffer
</code></pre>

<p>So yes it accepts a string, but we want an <code>io.Reader</code> as the return type, whereas this function returns a pointer to a <a href="https://golang.org/src/bytes/buffer.go?s=402:817#L7" target="_blank"><code>Buffer</code></a> type?</p>

<p>If we look at the implementation of <code>Buffer</code> though, we will see that it does actually <a href="https://golang.org/src/bytes/buffer.go?s=9564:9614#L287" target="_blank">implement</a> the required <code>Read</code> function necessary to support the <code>io.Reader</code> interface.</p>

<p>Great! Our test can now call the <code>process</code> function and process the mocked dependency and the code/test works as intended.</p>

<blockquote>
<p><strong>NOTE</strong>: Yes, we should probably use something more obvious and replace <code>bytes.NewBufferString</code> with something like <code>bytes.NewReader</code>, <code>strings.NewReader</code>.</p>
</blockquote>

<h2 id="more-flexible-solutions">More flexible solutions?</h2>

<p>OK, so we&rsquo;ve already explained why this implementation might not be the best we could do. Let&rsquo;s now consider an alternative implementation:</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;io/ioutil&quot;
	&quot;net/http&quot;
)

type Getter interface {
	Get(url string) ([]byte, error)
}

type httpbin struct{}

func (l *httpbin) Get(url string) ([]byte, error) {
	resp, err := http.Get(url)
	if err != nil {
		fmt.Printf(&quot;url get error: %s\n&quot;, err)
		return []byte{}, err
	}

	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		fmt.Printf(&quot;body read error: %s\n&quot;, err)
		return []byte{}, err
	}

	return body, nil
}

func process(n int, g Getter) (string, error) {
	url := fmt.Sprintf(&quot;http://httpbin.org/links/%d/0&quot;, n)

	resp, err := g.Get(url)
	if err != nil {
		fmt.Printf(&quot;data source get error: %s\n&quot;, err)
		return &quot;&quot;, err
	}

	return string(resp), nil
}

func main() {
	data, err := process(5, &amp;httpbin{})
	if err != nil {
		fmt.Printf(&quot;\ndata processing error: %s\n&quot;, err)
		return
	}
	fmt.Printf(&quot;\nSuccess: %v\n&quot;, data)
}
</code></pre>

<p>All we&rsquo;ve really done here is move more of the logic related to HTTP up into the <code>httpbin.Get</code> implementation of the <code>Getter</code> interface. We&rsquo;ve also changed the response type from <code>(*http.Response, error)</code> to <code>([]byte, error)</code> to account for these movements.</p>

<p>Now the <code>process</code> function has even <em>less</em> responsibility as far as acquiring data is concerned. This also means our test suite benefits by having a much simpler implementation:</p>

<pre><code class="language-go">package main

import &quot;testing&quot;

type fakeHTTPBin struct{}

func (l *fakeHTTPBin) Get(url string) ([]byte, error) {
	return []byte(&quot;Hello World&quot;), nil
}

func TestBasics(t *testing.T) {
	expect := &quot;Hello World&quot;
	actual, _ := process(5, &amp;fakeHTTPBin{})

	if actual != expect {
		t.Errorf(&quot;expected %s, actual %s&quot;, expect, actual)
	}
}
</code></pre>

<p>Now our <code>fakeHTTPBin.Get</code> only has to return a byte array.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Is there more we can do to improve this code&rsquo;s design? Sure. But we&rsquo;ll leave a new refactor iteration to another post.</p>

<p>Hopefully this has given you a feeling for how interfaces are used in the Go standard library and how you might utilise custom interfaces yourself.</p>

          </section>
        </div>
      </div>
      <!-- Sidebar -->
<div id="sidebar">
  <div class="inner">
    <!-- Search -->
    <!--<section id="search" class="alt">-->
    <!--  <form method="post" action="#">-->
    <!--    <input type="text" name="query" id="query" placeholder="Search" />-->
    <!--  </form>-->
    <!--</section>-->
    <!-- Menu -->
    <nav id="menu">
      <header class="major">
        <h2>Menu</h2>
      </header>
      <ul>
        <li><a href="../../index.html">Home</a></li>
        <!--<li><a href="../resume/index.html">Resume</a></li>-->
				
	<li>
	  <span class="opener">Pages</span>
	  <ul>
		
	<li><a href="../../pages/christmas-movies/index.html">Christmas Movies</a></li>
	
	<li><a href="../../pages/resume/index.html">Resume</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2024</span>
	  <ul>
		
	<li><a href="../../posts/go-concurrency-patterns/index.html">Go Concurrency Patterns</a></li>
	
	<li><a href="../../posts/bitwise-operations-in-go/index.html">Bitwise Operations In Go</a></li>
	
	<li><a href="../../posts/go-typed-nil/index.html">Go Typed Nil</a></li>
	
	<li><a href="../../posts/programming-at-the-edge-with-fastly-compute/index.html">Programming At The Edge With Fastly Compute</a></li>
	
	<li><a href="../../posts/ci-cd-with-terraform-cloud-and-github-actions/index.html">Ci Cd With Terraform Cloud And Github Actions</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2023</span>
	  <ul>
		
	<li><a href="../../posts/openapi/index.html">Openapi</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2022</span>
	  <ul>
		
	<li><a href="../../posts/terraform-build-a-provider/index.html">Terraform Build A Provider</a></li>
	
	<li><a href="../../posts/rust-smart-pointers/index.html">Rust Smart Pointers</a></li>
	
	<li><a href="../../posts/laptop-setup-v2/index.html">Laptop Setup V2</a></li>
	
	<li><a href="../../posts/go-install/index.html">Go Install</a></li>
	
	<li><a href="../../posts/neovim-rust-go/index.html">Neovim Rust Go</a></li>
	
	<li><a href="../../posts/vim-themes/index.html">Vim Themes</a></li>
	
	<li><a href="../../posts/dev-tools/index.html">Dev Tools</a></li>
	
	<li><a href="../../posts/go-style-guide/index.html">Go Style Guide</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2021</span>
	  <ul>
		
	<li><a href="../../posts/vim-advanced/index.html">Vim Advanced</a></li>
	
	<li><a href="../../posts/rust-ownership/index.html">Rust Ownership</a></li>
	
	<li><a href="../../posts/github-actions/index.html">Github Actions</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2020</span>
	  <ul>
		
	<li><a href="../../posts/go-reflection/index.html">Go Reflection</a></li>
	
	<li><a href="../../posts/software-comparison/index.html">Software Comparison</a></li>
	
	<li><a href="../../posts/rate-limiting/index.html">Rate Limiting</a></li>
	
	<li><a href="../../posts/git-internals/index.html">Git Internals</a></li>
	
	<li><a href="../../posts/python-context-managers/index.html">Python Context Managers</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2019</span>
	  <ul>
		
	<li><a href="../../posts/python-generators/index.html">Python Generators</a></li>
	
	<li><a href="../../posts/tox-ini/index.html">Tox Ini</a></li>
	
	<li><a href="../../posts/python-app-dependencies/index.html">Python App Dependencies</a></li>
	
	<li><a href="../../posts/python-asyncio/index.html">Python Asyncio</a></li>
	
	<li><a href="../../posts/go-arrays-and-slices/index.html">Go Arrays And Slices</a></li>
	
	<li><a href="../../posts/anonymity/index.html">Anonymity</a></li>
	
	<li><a href="../../posts/http-caching-guide/index.html">Http Caching Guide</a></li>
	
	<li><a href="../../posts/laptop-setup/index.html">Laptop Setup</a></li>
	
	<li><a href="../../posts/git-multiple-branches/index.html">Git Multiple Branches</a></li>
	
	<li><a href="../../posts/algorithms-in-python/index.html">Algorithms In Python</a></li>
	
	<li><a href="../../posts/remote-working/index.html">Remote Working</a></li>
	
	<li><a href="../../posts/python-mocking/index.html">Python Mocking</a></li>
	
	<li><a href="../../posts/calculating-big-o/index.html">Calculating Big O</a></li>
	
	<li><a href="../../posts/algorithmic-complexity-in-python/index.html">Algorithmic Complexity In Python</a></li>
	
	<li><a href="../../posts/data-types-and-data-structures/index.html">Data Types And Data Structures</a></li>
	
	<li><a href="../../posts/design-python/index.html">Design Python</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2018</span>
	  <ul>
		
	<li><a href="../../posts/js-modern/index.html">Js Modern</a></li>
	
	<li><a href="../../posts/engineer-to-manager/index.html">Engineer To Manager</a></li>
	
	<li><a href="../../posts/interview-techniques/index.html">Interview Techniques</a></li>
	
	<li><a href="../../posts/post-mortems/index.html">Post Mortems</a></li>
	
	<li><a href="../../posts/slackbot-opsbot/index.html">Slackbot Opsbot</a></li>
	
	<li><a href="../../posts/go-interfaces/index.html">Go Interfaces</a></li>
	
	<li><a href="../../posts/multigrain-services/index.html">Multigrain Services</a></li>
	
	<li><a href="../../posts/authentication-with-aws-cognito/index.html">Authentication With Aws Cognito</a></li>
	
	<li><a href="../../posts/a-guide-to-effective-1-1-meetings/index.html">A Guide To Effective 1 1 Meetings</a></li>
	
	<li><a href="../../posts/project-management/index.html">Project Management</a></li>
	
	<li><a href="../../posts/reading-list/index.html">Reading List</a></li>
	
	<li><a href="../../posts/python-security/index.html">Python Security</a></li>
	
	<li><a href="../../posts/static-site-search/index.html">Static Site Search</a></li>
	
	<li><a href="../../posts/interview-topics/index.html">Interview Topics</a></li>
	
	<li><a href="../../posts/go-reverse-proxy/index.html">Go Reverse Proxy</a></li>
	
	<li><a href="../../posts/hashing-encryption-encoding/index.html">Hashing Encryption Encoding</a></li>
	
	<li><a href="../../posts/computers-101/index.html">Computers 101</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2017</span>
	  <ul>
		
	<li><a href="../../posts/statistics-basics/index.html">Statistics Basics</a></li>
	
	<li><a href="../../posts/queue-best-practices/index.html">Queue Best Practices</a></li>
	
	<li><a href="../../posts/monitoring-best-practices/index.html">Monitoring Best Practices</a></li>
	
	<li><a href="../../posts/load-testing-guidelines/index.html">Load Testing Guidelines</a></li>
	
	<li><a href="../../posts/logging-101/index.html">Logging 101</a></li>
	
	<li><a href="../../posts/fastly-varnish/index.html">Fastly Varnish</a></li>
	
	<li><a href="../../posts/profiling-python/index.html">Profiling Python</a></li>
	
	<li><a href="../../posts/profiling-go/index.html">Profiling Go</a></li>
	
	<li><a href="../../posts/dev-environments-within-docker-containers/index.html">Dev Environments Within Docker Containers</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2016</span>
	  <ul>
		
	<li><a href="../../posts/key-architecture/index.html">Key Architecture</a></li>
	
	<li><a href="../../posts/go-hitchhikers-guide/index.html">Go Hitchhikers Guide</a></li>
	
	<li><a href="../../posts/concepts-from-the-c-programming-language/index.html">Concepts From The C Programming Language</a></li>
	
	<li><a href="../../posts/man-pages/index.html">Man Pages</a></li>
	
	<li><a href="../../posts/c-and-syscalls/index.html">C And Syscalls</a></li>
	
	<li><a href="../../posts/bits-and-bytes/index.html">Bits And Bytes</a></li>
	
	<li><a href="../../posts/terminal-password-manager/index.html">Terminal Password Manager</a></li>
	
	<li><a href="../../posts/terminal-utils/index.html">Terminal Utils</a></li>
	
	<li><a href="../../posts/github-pull-request-formatting/index.html">Github Pull Request Formatting</a></li>
	
	<li><a href="../../posts/big-o-for-beginners/index.html">Big O For Beginners</a></li>
	
	<li><a href="../../posts/the-perfect-developer/index.html">The Perfect Developer</a></li>
	
	<li><a href="../../posts/git-merge-strategies/index.html">Git Merge Strategies</a></li>
	
	<li><a href="../../posts/grpc-for-beginners/index.html">Grpc For Beginners</a></li>
	
	<li><a href="../../posts/bash-watchtower/index.html">Bash Watchtower</a></li>
	
	<li><a href="../../posts/rpc-variations-in-go/index.html">Rpc Variations In Go</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2015</span>
	  <ul>
		
	<li><a href="../../posts/go-func-type/index.html">Go Func Type</a></li>
	
	<li><a href="../../posts/github-multiple-ssh/index.html">Github Multiple Ssh</a></li>
	
	<li><a href="../../posts/http2/index.html">Http2</a></li>
	
	<li><a href="../../posts/building-systems-with-make/index.html">Building Systems With Make</a></li>
	
	<li><a href="../../posts/client-cert-authentication/index.html">Client Cert Authentication</a></li>
	
	<li><a href="../../posts/dns-101/index.html">Dns 101</a></li>
	
	<li><a href="../../posts/security-basics/index.html">Security Basics</a></li>
	
	<li><a href="../../posts/docker-nginx/index.html">Docker Nginx</a></li>
	
	<li><a href="../../posts/designing-for-simplicity/index.html">Designing For Simplicity</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2014</span>
	  <ul>
		
	<li><a href="../../posts/concurrency/index.html">Concurrency</a></li>
	
	<li><a href="../../posts/github-workflow/index.html">Github Workflow</a></li>
	
	<li><a href="../../posts/functional-recursive-javascript-programming/index.html">Functional Recursive Javascript Programming</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2013</span>
	  <ul>
		
	<li><a href="../../posts/refactoring-techniques/index.html">Refactoring Techniques</a></li>
	
	<li><a href="../../posts/design-mvcp/index.html">Design Mvcp</a></li>
	
	<li><a href="../../posts/basic-shell-scripting/index.html">Basic Shell Scripting</a></li>
	
	<li><a href="../../posts/clean-coder/index.html">Clean Coder</a></li>
	
	<li><a href="../../posts/message-passing-in-object-oriented-code/index.html">Message Passing In Object Oriented Code</a></li>
	
	<li><a href="../../posts/design-oop/index.html">Design Oop</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2012</span>
	  <ul>
		
	<li><a href="../../posts/git-tips/index.html">Git Tips</a></li>
	
	<li><a href="../../posts/maintainable-css-with-bem/index.html">Maintainable Css With Bem</a></li>
	
	<li><a href="../../posts/host-methods-vs-native-methods/index.html">Host Methods Vs Native Methods</a></li>
	
	<li><a href="../../posts/javascript-101/index.html">Javascript 101</a></li>
	
	  </ul>
	</li>
	
      </ul>
    </nav>
    <!-- Section -->
		<!--
    <section>
      <header class="major">
        <h2>Highlights</h2>
      </header>
      <div class="mini-posts">
        <article>
          <a href="ppv-survivorseries-88.html" class="image"><img src="../images/survivor-88-index.jpg" alt="" /></a>
          <p>Get ready for the ultimate showdown as Survivor Series 1988 brings non-stop tag team action, fierce rivalries, and unforgettable battles between the biggest WWF superstars!</p>
        </article>
        <article>
          <a href="ppv-royalrumble-89.html" class="image"><img src="../images/rumble-89-index.jpg" alt="" /></a>
          <p>Royal Rumble 1989 unleashes chaos with 30 superstars battling for glory in an unforgettable over-the-top-rope showdown!</p>
        </article>
        <article>
          <a href="ppv-summerslam-88.html" class="image"><img src="../images/slam-88-index.jpg" alt="" /></a>
          <p>SummerSlam 1988 delivers explosive action with iconic matchups, as the WWF's biggest stars collide in the hottest event of the summer!</p>
        </article>
      </div>
    </section>
		-->
    <!-- Section -->
    <!--<section>-->
    <!--  <header class="major">-->
    <!--    <h2>Get in touch</h2>-->
    <!--  </header>-->
    <!--  <p>Sed varius enim lorem ullamcorper dolore aliquam aenean ornare velit lacus, ac varius enim lorem ullamcorper dolore. Proin sed aliquam facilisis ante interdum. Sed nulla amet lorem feugiat tempus aliquam.</p>-->
    <!--  <ul class="contact">-->
    <!--    <li class="icon solid fa-envelope"><a href="#">information@untitled.tld</a></li>-->
    <!--    <li class="icon solid fa-phone">(000) 000-0000</li>-->
    <!--    <li class="icon solid fa-home">1234 Somewhere Road #8254<br />-->
    <!--      Nashville, TN 00000-0000</li>-->
    <!--  </ul>-->
    <!--</section>-->
    <!-- Footer -->
    <footer id="footer">
      <p class="copyright">&copy; Integralist. All rights reserved.</p>
      <p class="copyright small">Demo Images: <a href="https://unsplash.com">Unsplash</a>. Design: <a href="https://html5up.net">HTML5 UP</a>.</p>
    </footer>
  </div>
</div>

    </div>
    <!-- Scripts -->
    <script src="../../assets/js/jquery.min.js"></script>
    <script src="../../assets/js/browser.min.js"></script>
    <script src="../../assets/js/breakpoints.min.js"></script>
    <script src="../../assets/js/util.js"></script>
    <script src="../../assets/js/main.js"></script>

		<!-- The following script is for handling the automatic TOC generated by `make build` -->
		<script>
		// Get references to the elements
		const nav = document.querySelector('#main nav');
		const h1 = document.querySelector('#main h1');

		// Move the `nav` element to be underneath the `h1`
		h1.insertAdjacentElement('afterend', nav);

		// Hide the `nav` element by default using inline styles
		nav.style.display = 'none';

		// Create a new `h2` element with the text "TOC"
		const toc = document.createElement('h2');
		toc.textContent = 'TOC';
		toc.className = "toc"

		// Add inline styles to make the `h2` look clickable
		// DISABLED: done with className
		//
		// toc.style.cursor = 'pointer';
		// toc.style.color = 'blue';
		// toc.style.textDecoration = 'underline';

		// Add a click event listener to toggle the visibility of the `nav`
		toc.addEventListener('click', () => {
				nav.style.display = nav.style.display === 'none' ? 'block' : 'none';
		});

		// Insert the `h2` element above the `nav`
		nav.insertAdjacentElement('beforebegin', toc);
		</script>

		<!-- The following script highlights the current page in the side nav -->
		<script>
		// Get the current page's URL path and normalize it
    const currentUrl = window.location.pathname;
    const normalizedCurrentUrl = currentUrl
        .replace(/.*\/(pages|posts)\//, '/$1/') // Ensure leading slash and extract from `pages/` or `posts/`
        .replace(/index\.html$/, ''); // Remove `index.html` suffix

    // Select all menu links
    const links = document.querySelectorAll('#menu ul li a');

    let matchedParentSpan = null;

    links.forEach(link => {
        // Normalize the link's href for comparison
        const normalizedHref = link.getAttribute('href')
            .replace(/^(\.\.\/)+/, '/') // Convert `../../` to `/` for consistency
            .replace(/index\.html$/, ''); // Remove `index.html` suffix

        // Check if the normalized href matches the normalized current URL
        if (normalizedHref === normalizedCurrentUrl) {
            // Add the inline style to the matching link
            link.style.color = 'black';

            // Find the parent span with the class 'opener'
            matchedParentSpan = link.closest('ul').previousElementSibling;
        }
    });

    // If a matching parent span was found, add the 'active' class
    if (matchedParentSpan && matchedParentSpan.classList.contains('opener')) {
        matchedParentSpan.classList.add('active');
    }
		</script>
  </body>
</html>
