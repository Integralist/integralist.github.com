<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, minimal-ui">
        <title>Bash, Vim and Tmux Configuration</title>
        <link rel="stylesheet" href="../styles/github-markdown.css">
        <link rel="stylesheet" href="../styles/prism-default.css">
        <style>
            body {
                min-width: 200px;
                max-width: 790px;
                margin: 0 auto;
                padding: 30px;
            }

            pre[class*="language-"] {
              border: 1px dashed #AAA;
              margin-bottom: 1em;
            }
        </style>
    </head>
    <body>
        <article class="markdown-body">

<h1>Bash, Vim and Tmux Configuration</h1>

<ul>
<li><a href="#1">Introduction</a></li>
<li><a href="#2">Bash</a></li>
<li><a href="#9">Vim</a></li>
<li><a href="#10">Tmux</a></li>
</ul>

<div id="1"></div>

<h2>Introduction</h2>

<p>One of the key components to a happy development workflow is to ensure your tools work hard for you, are efficient and also fun to use (although sadly that latter point is sorely underappreciated as a deciding factor into what tools you choose). </p>

<p>This is where configuring your own setup to suit your individual needs becomes essential.</p>

<p>Now although you and I may differ as to what we like, there will inevitably be some common tools and solutions that we&#39;ll use and build upon. So what I present here today are are my tools. My configuration and enhancements of those core tools and what I feel to be &#39;good enough&#39; to suit my needs.</p>

<p>Feel free to take whatever you like and leave the rest.</p>

<p>So what will I be covering? Good question, the running order of things will be: </p>

<ul>
<li>Bash</li>
<li>Vim</li>
<li>Tmux</li>
</ul>

<p>I&#39;ll be going over my terminal/shell configurations, as well as my current Vim and tmux setup. So let&#39;s get started...</p>

<blockquote>
<p>Note: it shouldn&#39;t matter too much, but I&#39;m running Mac OS X</p>
</blockquote>

<div id="2"></div>

<h2>Bash</h2>

<p>The reason for using Bash over another shell, such as <a href="http://www.zsh.org/">Zsh</a> (which I used to use), is primarily its ubiquitousness. I find that whenever I&#39;m writing shell scripts I&#39;ll end up using a feature that isn&#39;t supported in Bash. </p>

<p>Obviously this is fine if you&#39;re writing shell scripts for your own machine, but I sometimes write scripts for other environments (e.g. continuous integration systems) and they will mostly be running Bash only.</p>

<p>The reasons other people prefer shells like Zsh or Fish (or whatever) is that you get additional features much more easily. But as you&#39;ll see shortly, I&#39;ve configured my Bash environment to provide some of these features, and OK maybe sometimes it&#39;s not as slick as other shells; but this is the first - of possibly many - situations where I&#39;m happy with the setup and feel it&#39;s &quot;good enough&quot; to suit my needs, but you might disagree (c&#39;est la vie).</p>

<p>I&#39;ve decided to break this section down into sub parts to make easier to digest:</p>

<ul>
<li><a href="#3">Install terminal theme</a></li>
<li><a href="#4">Install a newer version of Bash</a></li>
<li><a href="#5">Configure <code>~/.bash_profile</code></a></li>
<li><a href="#6">Configure <code>~/.bashrc</code></a></li>
<li><a href="#7">Configure <code>~/.inputrc</code></a></li>
<li><a href="#8">Other dotfiles?</a></li>
</ul>

<div id="3"></div>

<h3>Install terminal theme</h3>

<p>Now although not strictly anything to do with the shell, I thought it was worth mentioning that I have a few different Terminal themes that I use and choose from. You can find a few of those themes here:</p>

<p><a href="https://github.com/Integralist/dotfiles/tree/master/Terminal-Themes">github.com/integralist/dotfiles</a></p>

<blockquote>
<p>Note: currently using Smyck</p>
</blockquote>

<p>To install them, download the <code>.terminal</code> file you want and double click on it.</p>

<div id="4"></div>

<h3>Install a newer version of Bash</h3>

<p>I like to install a newer version of Bash via <a href="http://brew.sh/">Homebrew</a>.</p>

<p>For example, execute the following command to see your current Bash version:</p>

<pre><code class="language-bash">/bin/bash --version
</code></pre>

<p>When you do, you&#39;ll likely find Mac OS X comes with a much older version of Bash than you&#39;d expect.</p>

<p>For me I see version <code>3.2.57</code>.</p>

<p>So first things first, I want to install a newer version of Bash:</p>

<pre><code class="language-bash">brew install bash
</code></pre>

<p>Next add the location of this new Bash shell to our system&#39;s list of known shells:</p>

<pre><code class="language-bash">echo /usr/local/bin/bash | sudo tee -a /etc/shells
</code></pre>

<p>Finally, let&#39;s tell our system to permanently change to the new Bash shell:</p>

<pre><code class="language-bash">chsh -s /usr/local/bin/bash
</code></pre>

<p>OK, at this point if you open a new terminal you&#39;ll be using the new Bash shell you&#39;ve downloaded:</p>

<pre><code class="language-bash">bash --version
</code></pre>

<p>You&#39;ll notice I didn&#39;t specify the full path, I just used <code>bash</code> and the terminal was able to locate the new installation. Doing this for me tells me the new version of Bash is <code>4.3.42</code>.</p>

<div id="5"></div>

<h3>Configure <code>~/.bash_profile</code></h3>

<p>In order for the terminal to pick up my actual user configuration for Bash I needed to modify the file <code>~/.bash_profile</code>. The specific change I add to this file is as follows:</p>

<pre><code class="language-bash">if [ -f $HOME/.bashrc ]; then
  source ~/.bashrc
  cd .
fi
</code></pre>

<p>What this will do is check if there is a <code>~/.bashrc</code> file, and if so &#39;source&#39; it into the currently running shell.</p>

<blockquote>
<p>Note: <code>cd .</code> isn&#39;t necessary, I just like using it<br>
e.g. each new shell will reset the location back to <code>$HOME</code></p>
</blockquote>

<p>One other thing I add to <code>~/.bash_profile</code> is the following snippet of code:</p>

<pre><code class="language-bash">if [ -f $(brew --prefix)/etc/bash_completion ]; then
  source $(brew --prefix)/etc/bash_completion
fi
</code></pre>

<p>What this does is load an auto completion script (similar to what you&#39;ll find in other shells) so you can type part of a comand, then press <code>&lt;Tab&gt;</code> and have the shell autocomplete the rest of the command for you (as well as other types of autocompletion).</p>

<p>The script itself is provided by Homebrew. Hence you&#39;ll see we tell the script to look inside the Homebrew source directory (e.g. <code>$(brew --prefix)</code>), which typically will be something like <code>/usr/local</code>.</p>

<div id="6"></div>

<h3>Configure <code>~/.bashrc</code></h3>

<p>The <code>~/.bashrc</code> file is the main container of our configuration. It&#39;ll determine things like the appearance of the shell&#39;s prompt, keybindings for moving the cursor around, how we handle the shell&#39;s history and many other things.</p>

<p>I&#39;m going to just leave this whole file here and let the comments speak for themselves...</p>

<blockquote>
<p>Note: Google is your friend for any Bash voodoo you&#39;re unsure on</p>
</blockquote>

<pre><code class="language-bash"># download from https://github.com/git/git/blob/master/contrib/completion/git-prompt.sh
source ~/.git-prompt.sh

# tells Readline to perform filename completion in a case-insensitive fashion
bind &quot;set completion-ignore-case on&quot;

# filename matching during completion 
# will treat hyphens and underscores as equivalent
bind &quot;set completion-map-case on&quot;

# will get Readline to display all possible matches 
# for an ambiguous pattern at the 
# first &lt;Tab&gt; press instead of at the second
bind &quot;set show-all-if-ambiguous on&quot;

# no bell sound on error
bind &quot;set bell-style none&quot;

# enable vi like bindings
# http://blog.sanctum.geek.nz/vi-mode-in-bash/
set -o vi

# append to the history file, don&#39;t overwrite it
shopt -s histappend

# save multi-line commands as one command
shopt -s cmdhist

# no need to type cd (works for .. but not -, although alias -- -=&#39;cd -&#39; fixes it)
shopt -s autocd 2&gt;/dev/null

# autocorrect minor spelling errors
shopt -s dirspell 2&gt;/dev/null
shopt -s cdspell 2&gt;/dev/null

# check windows size if windows is resized
shopt -s checkwinsize 2&gt;/dev/null

# use extra globing features. See man bash, search extglob.
shopt -s extglob 2&gt;/dev/null

# include .files when globbing.
shopt -s dotglob 2&gt;/dev/null

# specify other paths to look inside of when autocompleting
CDPATH=&quot;.:~/Projects&quot;

# custom environment variables
export DROPBOX=&quot;$HOME/Dropbox&quot;
export GITHUB_USER=&quot;integralist&quot;
export CERT_PATH=&quot;$HOME/.pki&quot;

# application configuration
export GREP_OPTIONS=&quot;--color=auto&quot;
export GREP_COLOR=&quot;1;32&quot;
export MANPAGER=&quot;less -X&quot; # Don&#39;t clear the screen after quitting a manual page
export DOCKER_TLS_VERIFY=1
export GOPATH=$HOME/Projects/golang
export PATH=$HOME/Projects/golang/bin/:$HOME/dotvim/voom:$PATH
export EDITOR=&quot;vim&quot;

# record each line as it gets issued
export PROMPT_COMMAND=&#39;history -a&#39;

# set a larger history
export HISTSIZE=500000
export HISTFILESIZE=100000

# avoid duplicate entries
export HISTCONTROL=&quot;erasedups:ignoreboth&quot;

# don&#39;t record some commands
export HISTIGNORE=&quot;&amp;:[ ]*:exit:ls:bg:fg:history&quot;

# useful timestamp format
export HISTTIMEFORMAT=&#39;%F %T &#39;

# git specific configurations
export GIT_PS1_SHOWCOLORHINTS=true
export GIT_PS1_SHOWDIRTYSTATE=true     # * for unstage changes (+ staged but uncommitted changes)
export GIT_PS1_SHOWSTASHSTATE=true     # $ for stashed changes
export GIT_PS1_SHOWUNTRACKEDFILES=true # % for untracked files
export GIT_PS1_SHOWUPSTREAM=&quot;auto&quot;     # &gt; for local commits on HEAD not pushed to upstream
                                       # &lt; for commits on upstream not merged with HEAD
                                       # = HEAD points to same commit as upstream

# Colored man pages
export LESS_TERMCAP_mb=$&#39;\E[01;31m&#39;
export LESS_TERMCAP_md=$&#39;\E[01;31m&#39;
export LESS_TERMCAP_me=$&#39;\E[0m&#39;
export LESS_TERMCAP_se=$&#39;\E[0m&#39;
export LESS_TERMCAP_so=$&#39;\E[01;44;33m&#39;
export LESS_TERMCAP_ue=$&#39;\E[0m&#39;
export LESS_TERMCAP_us=$&#39;\E[01;32m&#39;

# force colours
force_color_prompt=yes

# use colour prompt
color_prompt=yes

# display number of backgrounded processes/jobs
num_jobs=$(jobs | wc -l)
if [ $num_jobs -eq 0 ]; then
  num_jobs=&quot;&quot;
else
  num_jobs=&quot; (\j)&quot;
fi

function prompt_right() {
  # need the correct number of spaces after \A to allow for 00:00 time display
  # echo -e &quot;\e[0;36m\A   \e[0m&quot;
  echo -e &quot;&quot;
}
function prompt_left() {
  # __git_ps1 function sourced from ~/.git-prompt.sh
  echo -e &quot;\e[33m\]\u. \[\e[37m\]\w\[\e[00m\]$num_jobs\e[31m\]$(__git_ps1)\e[00m\] \e[0;32m\A\e[0m&quot;
}

# the prompt will look something like:
# &lt;user&gt; &lt;current_path&gt; &lt;git_branch&gt; &lt;current_time&gt;
function prompt() {
    compensate=11
    PS1=$(printf &quot;%*s\r%s\n\$ &quot; &quot;$(($(tput cols)+${compensate}))&quot; &quot;$(prompt_right)&quot; &quot;$(prompt_left)&quot;)
}

# override builtin cd command so it resets command prompt when changing directories
function cd {
  builtin cd &quot;$@&quot;
  RET=$?

  PROMPT_COMMAND=prompt

  # After each command, append to the history file and reread it
  export PROMPT_COMMAND=&quot;${PROMPT_COMMAND:+$PROMPT_COMMAND$&#39;\n&#39;}history -a; history -c; history -r&quot;

  return $RET
}

# run a Rubocop Docker container
# https://github.com/bbatsov/rubocop
function rubo() {
  docker run \
    --cpu-shares 1024 \
    --rm=true \
    --volume $(pwd):/app \
    bbcnews/rubocop-config --format simple --fail-level F | grep &#39;^F:\|==&#39;
}

# list all dotfiles
alias dotfiles=&quot;ls -a | grep &#39;^\.&#39; | grep --invert-match &#39;\.DS_Store\|\.$&#39;&quot;

# get the latest git commit hash
alias getcommit=&quot;git log -1 | cut -d &#39; &#39; -f 2 | head -n 1 | pbcopy&quot;

# generate a ssh key pair
alias sshkey=&quot;ssh-keygen -t rsa -b 4096 -C &#39;foobar@example.com&#39;&quot;

# simpler than typing irssi
alias irc=&quot;irssi&quot;

# more descriptive ls and ll commands
alias ls=&quot;ls -GpF&quot;
alias ll=&quot;ls -laGpF&quot;

# make it easier to update the current shell with new changes
alias r=&quot;source ~/.bashrc&quot;

# some basic git shortcuts
alias cm=&quot;git checkout master&quot;
alias c-=&quot;git checkout -&quot;

# use rbenv for managing my Ruby versions
# https://github.com/rbenv/rbenv
eval &quot;$(rbenv init -)&quot;

# use Docker Machine to manage my containers
eval &quot;$(docker-machine env dev)&quot;
</code></pre>

<p>All things considered, this covers a lot of ground for me. There&#39;s just one other piece I like to utilise...</p>

<div id="7"></div>

<h3>Configure <code>~/.inputrc</code></h3>

<p>In the <code>~/.inputrc</code> file I have two lines of configuration only:</p>

<pre><code class="language-bash">TAB: menu-complete
&quot;\e[Z&quot;: &quot;\e-1\C-i&quot;
</code></pre>

<p>In short, what this gives you is the ability to press <code>&lt;C-n&gt;</code> and <code>&lt;C-p&gt;</code> to tab back and forth through any ambigious autocompletion suggestions that you may be presented with.</p>

<div id="8"></div>

<h3>Other dotfiles?</h3>

<p>My <code>$HOME</code> directory is littered with miscellaneous dotfiles such as:</p>

<ul>
<li><code>.agignore</code></li>
<li><code>.gitignore</code></li>
<li><code>.gitignore_global</code></li>
<li><code>.rspec</code></li>
</ul>

<p>...and many many more (inc dot folders such as <code>.git</code>, <code>.ssh</code> and <code>.irssi</code> etc)</p>

<p>I&#39;m not going to bother to document them all here though.</p>

<div id="9"></div>

<h2>Vim</h2>

<p>I&#39;ve written a book about Vim (<a href="http://www.amazon.co.uk/Pro-Vim-Mark-McDonnell/dp/1484202511/ref=sr_1_1?ie=UTF8&amp;qid=1417554324&amp;sr=8-1&amp;keywords=pro+Vim">Pro Vim</a>). I&#39;ve also written about it on my own site quite a few times so I won&#39;t waste time explaining it to any one. </p>

<p>So I&#39;ll assume you&#39;re already a Vim user and are just interested in my set-up.</p>

<p>One key aspect of using Vim are plugins and so any serious Vim user will need a way to manage their plugins. In my book I cover the in&#39;s and out&#39;s of <a href="https://github.com/tpope/vim-pathogen">Pathogen</a> and since then I moved back to <a href="https://github.com/VundleVim/Vundle.vim">Vundle</a> as I wanted an abstraction to help me better manage my growing list of plugins.</p>

<p>I&#39;ve since now moved over to <a href="https://github.com/airblade/voom">Voom</a> which is a simple Bash script that has a dependency on Pathogen (itself ~300 lines of VimL code). This is, to me at least, a vast improvement on the ~1k lines of VimL for Vundle and I get a simple <code>voom</code> command I can use to install/delete/update my plugins via the use of a plugin manifest file.</p>

<p>The Voom plugin manifest file is <code>~/dotvim/plugin</code> and, for me, has the following content that defines the plugins I like to use (the configuration of these plugins can be found within the <code>~/.vimrc</code> file, which I&#39;ll show to you shortly):</p>

<pre><code class="language-bash">chriskempson/vim-tomorrow-theme
ekalinin/Dockerfile.vim
ervandew/supertab
fatih/vim-go
godlygeek/tabular
guns/vim-clojure-highlight
guns/vim-clojure-static
guns/vim-sexp
kana/vim-textobj-user
kien/ctrlp.vim
kien/rainbow_parentheses.vim
m-kat/aws-vim
mileszs/ack.vim
nelstrom/vim-textobj-rubyblock
othree/html5.vim
plasticboy/vim-markdown
scrooloose/syntastic
sheerun/vim-polyglot
Shougo/unite.vim
Shougo/vimfiler.vim
tpope/vim-commentary
tpope/vim-endwise
tpope/vim-fireplace
tpope/vim-leiningen
tpope/vim-repeat
tpope/vim-sexp-mappings-for-regular-people
tpope/vim-surround
vim-scripts/Gist.vim
vim-scripts/camelcasemotion
</code></pre>

<blockquote>
<p>Note: <code>voom edit</code> will open the file for you</p>
</blockquote>

<p>Right. Let&#39;s now look at getting Vim setup. Below is a break-down of &#39;from nothing, to something&#39;:</p>

<pre><code class="language-bash">cd ~/
mkdir -p dotvim/{autoload,bundle}
touch dotvim/plugins
ln -nfs ~/dotvim ~/.vim
curl -LSso ~/dotvim/autoload/pathogen.vim https://raw.github.com/tpope/vim-pathogen/master/autoload/pathogen.vim
</code></pre>

<p>The above snippet of code creates a <code>dotvim</code> directory and then downloads Pathogen into it. We symlink the directory to <code>~/.vim</code> so when we start up Vim it&#39;ll actually pick up the <code>~/dotvim</code> directory.</p>

<p>From here we need to create a <code>~/.vimrc</code> configuration file and add the following content to it:</p>

<pre><code class="language-bash">execute pathogen#infect()
syntax on
filetype plugin indent on
</code></pre>

<p>This simply gets Pathogen running whenever Vim starts up.</p>

<p>Now we need to get the Voom plugin manager installed. To do that you&#39;ll need to run the following command:</p>

<pre><code class="language-bash">git clone git@github.com:airblade/voom.git ~/dotvim/voom
</code></pre>

<p>As you can see we stick Voom into a <code>~/dotvim/voom</code> directory, which has a script you&#39;ll need to add into your <code>$PATH</code> in order to gain access to the <code>voom</code> command. So you may have noticed earlier in our <code>.bashrc</code> file we had the following setting:</p>

<pre><code class="language-bash">export PATH=$HOME/Projects/golang/bin/:$HOME/dotvim/voom:$PATH
</code></pre>

<blockquote>
<p>Note: for NeoVim support<br>
<code>ln -nfs ~/dotvim ~/.nvim</code></p>
</blockquote>

<p>The configuration for these plugins are placed into my<code>~/.vimrc</code> file (shown below) along with all my other Vim settings. Again, I won&#39;t bother to detail every single item in my <code>~/.vimrc</code>; hopefully the comments will suffice. Otherwise Google anything you&#39;re unsure about:</p>

<pre><code class="language-ini">&quot; Use the system clipboard
set clipboard+=unnamed

&quot; Switch syntax highlighting on
syntax on

&quot; Don&#39;t worry about trying to support old school Vi features
set nocompatible

&quot; No backup files
set nobackup

&quot; No write backup
set nowritebackup

&quot; No swap file
set noswapfile

&quot; Command history
set history=100

&quot; Always show cursor
set ruler

&quot; Show incomplete commands
set showcmd

&quot; Incremental searching (search as you type)
set incsearch

&quot; Highlight search matches
set hlsearch

&quot; Ignore case in search
set smartcase

&quot; Make sure any searches /searchPhrase doesn&#39;t need the \c escape character
set ignorecase

&quot; A buffer is marked as ‘hidden’ if it has unsaved changes, and it is not currently loaded in a window
&quot; If you try and quit Vim while there are hidden buffers, you will raise an error:
&quot; E162: No write since last change for buffer “a.txt”
set hidden

&quot; Turn word wrap off
set nowrap

&quot; Allow backspace to delete end of line, indent and start of line characters
set backspace=indent,eol,start

&quot; Convert tabs to spaces
set expandtab

&quot; Set tab size in spaces (this is for manual indenting)
set tabstop=2

&quot; The number of spaces inserted for a tab (used for auto indenting)
set shiftwidth=2

&quot; Turn on line numbers
set number

&quot; Highlight tailing whitespace
set list listchars=tab:\ \ ,trail:·

&quot; Get rid of the delay when pressing O (for example)
&quot; http://stackoverflow.com/questions/2158516/vim-delay-before-o-opens-a-new-line
set timeout timeoutlen=1000 ttimeoutlen=100

&quot; Always show status bar
set laststatus=2

&quot; Set the status line to something useful
set statusline=%f\ %m\ %=L:%l/%L\ C:%c\ (%p%%)

&quot; UTF encoding
set encoding=utf-8

&quot; Autoload files that have changed outside of vim
set autoread

&quot; Better splits (new windows appear below and to the right)
set splitbelow
set splitright

&quot; Highlight the current line
set cursorline

&quot; Ensure Vim doesn&#39;t beep at you every time you make a mistype
set visualbell

&quot; Visual autocomplete for command menu (e.g. :e ~/path/to/file)
set wildmenu

&quot; Redraw only when we need to (i.e. don&#39;t redraw when executing a macro)
set lazyredraw

&quot; Highlight a matching [{()}] when cursor is placed on start/end character
set showmatch

&quot; Set built-in file system explorer to use layout similar to the NERDTree plugin
&quot; P opens file in previously focused window
&quot; o opens file in new horizontal split window
&quot; v opens file in new vertical split window
&quot; t opens file in new tab split window
let g:netrw_liststyle=3

execute pathogen#infect()
filetype plugin indent on

&quot; set background=dark
colorscheme Tomorrow-Night-Eighties

&quot; vim-go
let g:go_fmt_command = &quot;goimports&quot;
let g:go_metalinter_autosave = 1
let g:go_metalinter_autosave_enabled = [&#39;vet&#39;, &#39;golint&#39;]
let g:go_metalinter_enabled = [&#39;vet&#39;, &#39;golint&#39;, &#39;errcheck&#39;]

&quot; tabular
map &lt;Leader&gt;e :Tabularize /=&lt;CR&gt;
map &lt;Leader&gt;c :Tabularize /:&lt;CR&gt;
map &lt;Leader&gt;es :Tabularize /=\zs&lt;CR&gt;
map &lt;Leader&gt;cs :Tabularize /:\zs&lt;CR&gt;

&quot; ctrlp
map &lt;leader&gt;t &lt;C-p&gt;
map &lt;leader&gt;y :CtrlPBuffer&lt;CR&gt;
let g:ctrlp_show_hidden=1
let g:ctrlp_working_path_mode=0
let g:ctrlp_max_height=30
let g:ctrlp_arg_map = 1 &quot; Override &lt;C-o&gt; to provide options for how to open files
set wildignore+=*/.git/*,*/.hg/*,*/.svn/*.,*/.DS_Store &quot; Files matched are ignored when expanding wildcards
let g:ctrlp_user_command = &#39;ag %s -l --nocolor -g &quot;&quot;&#39; &quot; Use Ag for searching instead of VimScript (might not work with ctrlp_show_hidden and ctrlp_custom_ignore)
let g:ctrlp_custom_ignore = &#39;\v[\/]((node_modules)|\.(git|svn|grunt|sass-cache))$&#39; &quot; Directories to ignore when fuzzy finding

&quot; ack
let g:ackprg = &#39;ag --nogroup --nocolor --column&#39;

&quot; vim-textobj-rubyblock
runtime macros/matchit.vim

&quot; vim-commentary
map &lt;leader&gt;&lt;leader&gt;&lt;leader&gt; gcc

&quot; gist
let g:github_user = $GITHUB_USER
let g:gist_detect_filetype = 1
let g:gist_open_browser_after_post = 1

&quot; camelcase
map &lt;silent&gt; w &lt;Plug&gt;CamelCaseMotion_w
map &lt;silent&gt; b &lt;Plug&gt;CamelCaseMotion_b
map &lt;silent&gt; e &lt;Plug&gt;CamelCaseMotion_e
sunmap w
sunmap b
sunmap e

&quot; NeoVim shortcut for quick terminal exit
:silent! tnoremap &lt;Esc&gt; &lt;C-\&gt;&lt;C-n&gt;

fun! StripTrailingWhitespace()
  &quot; Don&#39;t strip on these filetypes
  if &amp;ft =~ &#39;markdown&#39;
    return
  endif
  %s/\s\+$//e
endfun
autocmd BufWritePre * call StripTrailingWhitespace()

autocmd Filetype gitcommit setlocal spell textwidth=72
autocmd Filetype markdown setlocal wrap linebreak nolist textwidth=0 wrapmargin=0 &quot; http://vim.wikia.com/wiki/Word_wrap_without_line_breaks
autocmd FileType sh,cucumber,ruby,yaml,zsh,vim setlocal shiftwidth=2 tabstop=2 expandtab

&quot; Specify syntax highlighting for specific files
autocmd Bufread,BufNewFile *.spv set filetype=php
autocmd Bufread,BufNewFile *.md set filetype=markdown &quot; Vim interprets .md as &#39;modula2&#39; otherwise, see :set filetype?

&quot; Rainbow parenthesis always on!
autocmd VimEnter * if exists(&#39;:RainbowParenthesesToggle&#39;) | exe &quot;:RainbowParenthesesToggleAll&quot; | endif

&quot; Change colourscheme when diffing
fun! SetDiffColours()
  highlight DiffAdd    cterm=bold ctermfg=white ctermbg=DarkGreen
  highlight DiffDelete cterm=bold ctermfg=white ctermbg=DarkGrey
  highlight DiffChange cterm=bold ctermfg=white ctermbg=DarkBlue
  highlight DiffText   cterm=bold ctermfg=white ctermbg=DarkRed
endfun
autocmd FilterWritePre * call SetDiffColours()

&quot; Map § key to :nohlsearch (or :noh for short)
map § :nohlsearch&lt;CR&gt;
</code></pre>

<p>If you need to support NeoVim then you&#39;ll want to create a <code>~/.nvimrc</code> file and give it one line of content:</p>

<pre><code class="language-bash">source ~/.vimrc
</code></pre>

<div id="10"></div>

<h2>Tmux</h2>

<p>As far as tmux is concerned, my <code>~/.tmux.conf</code> is relatively short/concise compared to my other configuration files and to other config files I&#39;ve seen shared online. </p>

<p>I no longer bother to style the tmux panel, I prefer minimalism nowadays. This means my tmux settings generally revolve around key binding abstractions (although some minor tweaks here and there).</p>

<p>So one last time, just to repeat myself, I don&#39;t go into detail as to what these configurations mean; if the comments don&#39;t give you the answer you need, then a cursory Google should reveal all you need:</p>

<pre><code class="language-bash"># Remap prefix
unbind C-b
set -g prefix C-Space

# Quick key for moving back to the previous window
bind-key L last-window

# Vim style bindings for pane movement
bind-key -r h select-pane -L
bind-key -r j select-pane -D
bind-key -r k select-pane -U
bind-key -r l select-pane -R

# Fix issue with tmux repeating -r the arrow directions (meaning when you switch panes you can accidentally jump back to the other pane again)
bind-key Up    select-pane -U
bind-key Down  select-pane -D
bind-key Left  select-pane -L
bind-key Right select-pane -R

# Make resizing panes easier
bind-key &lt; resize-pane -L 5
bind-key &gt; resize-pane -R 5
bind-key + resize-pane -U 5
bind-key - resize-pane -D 5
bind-key = select-layout even-vertical
bind-key | select-layout even-horizontal

# Reload tmux config
bind-key r source-file ~/.tmux.conf

# Ensure terminal starts with its own colour scheme (helps Vim/Neovim themes to not break)
set -g default-terminal &quot;screen-256color&quot;

# Enable UTF8 support
set-window-option -g utf8 on

# Use Vi style key bindings to move around copy mode
setw -g mode-keys vi

# Make sure messages (using display-message) are displayed for long enough to read
set-option -g display-time 2000

# Remove delay when pressing esc in Vim
set -sg escape-time 0

# Fix issue with copying from within a tmux session and wanting to paste outside of it
set -g default-command &quot;reattach-to-user-namespace -l &#39;/bin/zsh&#39;&quot;

# Setup `v` and `y` operators to start and yank selections (like Vim)
bind-key -t vi-copy &#39;v&#39; begin-selection
bind-key -t vi-copy &#39;y&#39; copy-pipe &quot;reattach-to-user-namespace pbcopy&quot; # pbcopy is only available for Mac (not Linux)

# Prevent tmux from renaming the tab when processes change
set-option -g allow-rename off

# Set base index value to one (as apposed to zero)
set -g base-index 1

# Increase scrollback lines
set -g history-limit 30000

# Renumber windows automatically after removing a window
# Prevents my OCD and means I don&#39;t have to manually run {move|swap}-window
set-option -g renumber-windows on
</code></pre>

            <hr>
            <h2>Links</h2>
            <ul>
                <li><a href="../index.html">Home</a></li>
                <li><a href="../posts/about.html">About Me</a></li>
                <li><a href="https://github.com/integralist">GitHub</a></li>
                <li><a href="https://twitter.com/integralist">Twitter</a></li>
                <li><a href="http://www.integralist.co.uk/resume">Resume</a></li>
            </ul>
        </article>
        <script src="../scripts/prism.js"></script>
        <script>
            var _gaq=[['_setAccount','UA-33159515-1'],['_trackPageview']];
            (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
            g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
            s.parentNode.insertBefore(g,s)}(document,'script'));
        </script>
    </body>
</html>
