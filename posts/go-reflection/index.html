<!DOCTYPE HTML>
<!--
	Editorial by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
  <head>
    <title>Integralist</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="../../assets/css/main.css" />
  </head>
  <body class="is-preload">
    <!-- Wrapper -->
    <div id="wrapper">
      <!-- Main -->
      <div id="main">
        <div class="inner">
          <!-- Header -->
					<header id="header">
						<a href="../../index.html" class="logo"><strong>Home</strong></a>
							<ul class="icons">
							<!--<li><a href="https://x.com/integralist" class="icon brands fa-twitter" target="blank"><span class="label">Twitter</span></a></li>-->
							<!--<li><a href="https://instagram.com/wwfsuperstarsofwrestling" class="icon brands fa-instagram" target="blank"><span class="label">Instagram</span></a></li>-->
						</ul>
					</header>

          <!-- Content -->
          <section>
						<!--
            <header class="main">
              <h1>Royal Rumble 1989</h1>
              <p>A Bizarre Spectacle Where the Madness Multiplies</p>
            </header>
            <span class="image main"><img src="../images/rumble-89.jpg" alt="" /></span>
						-->
						<nav>

<ul>
<li><a href="#reflection-in-go">Reflection in Go</a>
<ul>
<li><a href="#what-is-reflection">What is reflection?</a></li>

<li><a href="#understanding-interfaces-in-go">Understanding Interfaces in Go</a></li>

<li><a href="#why-do-we-need-reflection">Why do we need Reflection?</a></li>

<li><a href="#the-building-blocks-of-reflection">The building blocks of Reflection</a></li>

<li><a href="#package-walk-through-go-flags">Package Walk-through: Go-Flags</a></li>

<li><a href="#explaining-how-go-flags-uses-reflection">Explaining how go-flags uses Reflection</a></li>

<li><a href="#conclusion">Conclusion</a></li>
</ul></li>
</ul>

</nav>

<h1 id="reflection-in-go">Reflection in Go</h1>

<p>I&rsquo;m going to walk you through how to understand reflection in Go using the <a href="https://golang.org/pkg/reflect/" target="_blank"><code>reflect</code></a> package. We&rsquo;ll do this by looking at an open-source package I created called <a href="https://github.com/integralist/go-flags" target="_blank"><code>go-flags</code></a> that utilizes reflection <em>heavily</em>.</p>

<p>The use of reflection is often frowned upon because it side steps the &lsquo;compile time&rsquo; type safety we get in Go. So I&rsquo;ll also explain how we can still ensure a level of type safety even at runtime.</p>

<h2 id="what-is-reflection">What is reflection?</h2>

<blockquote>
<p>Reflection in computing is the ability of a program to examine its own structure, particularly through types; it&rsquo;s a form of metaprogramming. It&rsquo;s also a great source of confusion.<br>
&ndash; <a href="https://blog.golang.org/laws-of-reflection" target="_blank">The Laws of Reflection</a></p>
</blockquote>

<p>The above quote comes from the opening of the Go Blog post <a href="https://blog.golang.org/laws-of-reflection" target="_blank">The Laws of Reflection</a> and I <em>strongly</em> recommend you read it, as it breaks down how types and interfaces work in Go (which is a prerequisite to understanding reflection) before leading into how reflection itself works.</p>

<p>There will be a summarized version of that information here, but ultimately what differentiates their post from mine is that I&rsquo;ll be discussing examples that are more practical and based on a <em>real</em> project (e.g. <a href="https://github.com/integralist/go-flags" target="_blank"><code>go-flags</code></a>).</p>

<h2 id="understanding-interfaces-in-go">Understanding Interfaces in Go</h2>

<p>In Go an &lsquo;interface type&rsquo; is a collection of methods which can be defined like so:</p>

<pre><code class="language-go">type Foo interface {
	Bar(s string)
	Baz(i int)
}
</code></pre>

<p>If you define a variable to be of type <code>Foo</code>, then you&rsquo;re saying the value that is assigned to the variable can be <em>any</em> type that implements the methods as defined by the <code>Foo</code> interface.</p>

<p>Conceptually the variable containing the assigned value can be thought of as a tuple that contains the underlying concrete value and the concrete type.</p>

<p>This is best demonstrated in an example. Below we create an interface type <code>Foo</code>, and then we define a struct type that will implement that interface. We&rsquo;ll assign an instance of the struct to a variable defined as being an interface type of <code>Foo</code> and we&rsquo;ll inspect the code at runtime using the <code>reflect</code> package to see what it can tell us about the variable and what it contains:</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

type Foo interface {
	Bar(s string)
	Baz(i int)
}

type T struct{
	s string
	i int
}

func (t T) Bar(s string) {
	//
}

func (t T) Baz(i int) {
	//
}

func main() {
	var f Foo
	f = T{&quot;testing&quot;, 123}

	fmt.Printf(&quot;(%+v, %+v)\n&quot;, reflect.ValueOf(f), reflect.TypeOf(f))
}
</code></pre>

<p>The output of the above program is:</p>

<pre><code class="language-go">({s:testing i:123}, main.T)
</code></pre>

<p>OK, so we can see that the &lsquo;value&rsquo; assigned to the <code>f</code> variable (of interface type <code>Foo</code>) is a struct with the relevant fields assigned with the appropriate value types. We can also see that the &lsquo;type&rsquo; of the value is <code>main.T</code>, which is correct and expected.</p>

<p>So this clearly demonstrates that although we&rsquo;ve stated the variable <code>f</code> should hold an interface type of <code>Foo</code>, it&rsquo;s actually holding a different type entirely.</p>

<p>This probably sounds like common sense (and as such not that interesting) but if you really think about it, that&rsquo;s incredible. We&rsquo;ve not explicitly declared the <code>T</code> struct as implementing the <code>Foo</code> interface.</p>

<p>Instead the fact it does implement the interface, and doing so is being <em>dynamically</em> understood by the compiler is a super powerful feature.</p>

<h2 id="why-do-we-need-reflection">Why do we need Reflection?</h2>

<p>You need reflection whenever dealing with information that wasn&rsquo;t known at the time of the program being written. One such example might be that you need to populate a struct with configuration data that comes from a external file.</p>

<p>There are many other examples, and the one I&rsquo;ll be using today is similar in that I wanted to populate a struct with values provided by a user at runtime, specifically CLI flag values.</p>

<h2 id="the-building-blocks-of-reflection">The building blocks of Reflection</h2>

<p>So let&rsquo;s consider what are probably the two <em>primary</em> reflection methods people learn about first when dealing with reflection (these were used in our example code earlier):</p>

<ul>
<li><code>reflect.ValueOf()</code>: returns a <code>reflect.Value</code>.</li>
<li><code>reflect.TypeOf()</code>: returns a <code>reflect.Type</code>.</li>
</ul>

<p>Both returned types have a bunch of methods associated with them that are unique to the purpose of those types. So for example, you want a <code>reflect.Value</code> if you&rsquo;re interested in querying the concrete value, where as <code>reflect.Type</code> is more useful when you need to know information about the specific type.</p>

<p>So the use case for getting back a <code>reflect.Type</code> vs <code>reflect.Value</code> depends on what you&rsquo;re trying to ascertain at runtime.</p>

<p>Once you have either a <code>reflect.Value</code> or a <code>reflect.Type</code>, then you can start digging further down into the data that is exposed via these types.</p>

<p>This is where exploring a real-world use case can be handy, as it helps to clarify <em>why</em> certain methods on these objects are called (compared to using a more <em>contrived</em> example).</p>

<h2 id="package-walk-through-go-flags">Package Walk-through: Go-Flags</h2>

<p>If you&rsquo;ve ever written a CLI program in Go you&rsquo;ll inevitably use its <a href="https://golang.org/pkg/flag/" target="_blank"><code>flag</code></a> package. Most people find this package unintuitive and in some cases just downright difficult to work with or to build nice patterns of use from.</p>

<p>This leads people to build their own abstraction patterns on top of the standard library, but from my experience the majority (if not <em>all</em>) of third-party flag packages are convoluted and confusing to work with. The user experience feels very poor IMHO.</p>

<blockquote>
<p><strong>Note</strong>: I&rsquo;m not knocking these packages. They all do very complex things, and solve real problems, and are written by much smarter people than myself. But it doesn&rsquo;t change the fact that rarely do they come across as &lsquo;simple&rsquo; and &lsquo;easy to use&rsquo;.</p>
</blockquote>

<p>I wanted to solve the problem of handling flags and commands for a CLI based program in a simple way, that didn&rsquo;t require me to construct a whole bunch of boilerplate code and have to negotiate lots of types.</p>

<p>In essence I wanted to define a &lsquo;schema&rsquo; of what flags and commands (and flags for those commands) that I was expecting, and to have a package magically populate that struct with the values provided by a user of my program.</p>

<p>This is where utilizing reflection was the only real solution to my problem (if I indeed wanted the user experience to be as simple as possible).</p>

<p>So thus <a href="https://github.com/integralist/go-flags" target="_blank"><code>go-flags</code></a> was born.</p>

<p>Here&rsquo;s an example of how you would use it:</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;os&quot;

	&quot;github.com/integralist/go-flags/flags&quot;
)

type Schema struct {
	Debug   bool   `short:&quot;d&quot; usage:&quot;enable debug level logs&quot;`
	Number  int    `short:&quot;n&quot; usage:&quot;a number field&quot;`
	Message string `short:&quot;m&quot; usage:&quot;a message field&quot;`
	Foo     struct {
		AAA string `short:&quot;a&quot; usage:&quot;does A&quot;`
		BBB string `short:&quot;b&quot; usage:&quot;does B&quot;`
	}
	Bar struct {
		CCC bool `short:&quot;c&quot; usage:&quot;does C&quot;`
	}
}

func main() {
	var s Schema

	err := flags.Parse(&amp;s)
	if err != nil {
		fmt.Printf(&quot;error parsing schema: %v\n&quot;, err)
		os.Exit(1)
	}
}
</code></pre>

<p>This is very simple and concise from a user&rsquo;s perspective.</p>

<p>We can see that there are a bunch of top-level, non command specific, flags defined:</p>

<ul>
<li><code>-d/-debug</code></li>
<li><code>-n/-number</code></li>
<li><code>-m/-message</code></li>
</ul>

<p>You&rsquo;ll notice that we utilize <a href="https://golang.org/ref/spec#Struct_types" target="_blank">struct tags</a> (the backticks that follow the struct field&rsquo;s type) for defining the &lsquo;short&rsquo; flag (while the field name itself is defining the &lsquo;long&rsquo; flag variation) as well as defining the &lsquo;usage&rsquo; description for each flag.</p>

<p>We can also see that we&rsquo;ve defined two separate commands (<code>Foo</code> and <code>Bar</code>), and each command has its own set of flags:</p>

<ul>
<li><code>foo</code>: <code>-a/-aaa</code> (<code>string</code>), <code>-b/-bbb</code> (<code>string</code>).</li>
<li><code>bar</code>: <code>-c/-ccc</code> (<code>bool</code>).</li>
</ul>

<p>An example of how a user might then run this program would be:</p>

<pre><code class="language-bash">my_cli_app -debug -n 123 -m &quot;something here&quot; foo -a beepboop -b 666
</code></pre>

<h2 id="explaining-how-go-flags-uses-reflection">Explaining how go-flags uses Reflection</h2>

<p>So how exactly does <a href="https://github.com/integralist/go-flags" target="_blank"><code>go-flags</code></a> achieve this magic using reflection?</p>

<p>Let&rsquo;s step through the code and find out&hellip;</p>

<blockquote>
<p><strong>Note</strong>: I&rsquo;m not an expert on the <code>reflect</code> package, nor was a lot of time spent on this package outside getting it functional, so there&rsquo;s likely many improvements that can be made to the code.</p>
</blockquote>

<p>We&rsquo;ll start with the <a href="https://github.com/Integralist/go-flags/blob/4704c0e/flags/flags.go#L22" target="_blank"><code>Parse()</code></a> function. Here we can see that the function accepts an argument of type <code>interface{}</code> which is the empty interface.</p>

<p>The reason for this is because we want the schema for the flags to be defined by the consumer of this package, and so at runtime we have no idea what that value will look like (hence the use of <code>interface{}</code> to mean: we&rsquo;ll take any type).</p>

<p>Once we&rsquo;ve got this unknown value we&rsquo;ll execute the following code to get at the actual value:</p>

<pre><code class="language-go">v := reflect.Indirect(reflect.ValueOf(s))
</code></pre>

<p>We can see the familiar <code>reflect.ValueOf()</code> but we have also wrapped it in a call to <code>reflect.Indirect()</code>, so why do that? Well, the <code>Indirect()</code> method will dereference the struct pointer to the struct concrete value!</p>

<p>It&rsquo;s also safe to use <code>Indirect()</code> because if you give it a non-pointer value it&rsquo;ll just return the value from <code>reflect.ValueOf()</code>. Don&rsquo;t worry, in just a moment we&rsquo;ll do some validation of the given argument to ensure the user has followed our package instructions and indeed given us a pointer to a struct containing their flag schema.</p>

<p>Next we acquire a <code>reflect.Type</code> type from the given argument:</p>

<pre><code class="language-go">st := v.Type()
</code></pre>

<p>We get the type structure from the <code>reflect.Value</code> type returned from calling <code>reflect.Indirect()</code>, and we do this because later on we&rsquo;ll pass it into a function called <a href="https://github.com/Integralist/go-flags/blob/4704c0e/flags/flags.go#L160" target="_blank"><code>IterFields</code></a> which iterates over the user&rsquo;s schema struct. We pass it into that function because within there we&rsquo;ll try to get the struct&rsquo;s individual fields as a <code>reflect.StructField</code> (I&rsquo;ll explain why we want that later).</p>

<p>Now it&rsquo;s at this point we do some runtime type validation:</p>

<pre><code class="language-go">if v.Kind() != reflect.Struct {
  return ErrWrongType
}
</code></pre>

<p>We&rsquo;re expecting a struct and there&rsquo;s no point trying to go any further with something that&rsquo;s <em>not</em> a struct, so we short-circuit the program if we&rsquo;re given anything unexpected.</p>

<p>OK, at this point of our package we have a few stages that involve, among many things, iterating the given struct (we use a custom iterator function called <code>IterFields</code> and we pass it a callback function to execute for each &lsquo;field&rsquo; in the given struct).</p>

<p><strong>Here are the stages at a high-level:</strong></p>

<ol>
<li>iterate over the top level fields of the user provided struct, and dynamically create flags.</li>
<li>parse the flag values the user of the CLI program have provided (using the flags our package has now dynamically generated).</li>
<li>iterate over the top level fields of the user provided struct, and populate the fields with the parsed flag values.</li>
<li>identify the command the user provided when running the CLI program (e.g. <code>foo</code> or <code>bar</code>).</li>
<li>parse the flag values the user provided after specifying the command.</li>
<li>dynamically create a <code>flag.FlagSet</code> for the command.</li>
<li>parse the flagset values the user provided (using the flagset our package has now dynamically generated).</li>
<li>iterate over the command fields of the user provided struct, and populate the fields with the parsed flagset values.</li>
</ol>

<p>Now we understand the general steps taken, we can dig into each of those and understand what reflection work needs to be carried out.</p>

<p>I won&rsquo;t be discussing the general code logic, just picking out the bits related to reflection. So if you want to understand the full go-flags implementation, then I recommend you read through the code base in its entirety after finishing this post.</p>

<blockquote>
<p><strong>Note</strong>: if I was working with Go 2.0 then I&rsquo;d have access to generics and parts of this code could be reduced/simplified. Hello future readers who are lucky enough to have Go 2.0.</p>
</blockquote>

<p>As the majority of these steps are related to iterating over the user provided struct, let&rsquo;s start with the <code>IterFields</code> function that enables that.</p>

<p>First thing we do in <code>IterFields()</code> is we call <code>.NumField()</code> on the <code>reflect.Value</code>, which gives us back the number of fields the struct contains.</p>

<p>This will panic if the <code>reflect.Kind()</code> is not a <code>reflect.Struct</code> type, hence why at the beginning of our <code>Parse()</code> function we do that validation there.</p>

<p>We could have moved the check for a struct down into the <code>IterFields()</code> function but then we&rsquo;d end up doing extra unnecessary logic processing only to have to just stop the program any way (so best to short circuit the code as soon as possible).</p>

<p>Once we have the number of struct fields, we&rsquo;ll create a loop for that number and we&rsquo;ll use the incrementing <code>i</code> value to access each individual struct field by calling <code>.Field()</code> on the <code>v</code> variable&rsquo;s <code>reflect.Value</code> type.</p>

<blockquote>
<p><strong>Note</strong>: you&rsquo;ll find that when you call methods on a <code>reflect.Value</code> type you&rsquo;ll likely end up with &hellip;another <code>reflect.Value</code> type!</p>
</blockquote>

<pre><code class="language-go">for i := 0; i &lt; v.NumField(); i++ {
  field := v.Field(i)

  ...
}
</code></pre>

<p>Next we call the <code>.Field()</code> method again but this time on the <code>reflect.Type</code> type. The reason we do this is because (as I mentioned earlier) we want a <code>reflect.StructField</code> type (which is what the <code>.Field()</code> call will give us) so we can inspect it later on in the callback function and parse out the &lsquo;tags&rsquo; assigned to the current struct field.</p>

<p>We have at this point a if/else condition which I&rsquo;m going to skip over the <code>if</code> block briefly and move onto discussing the <code>else</code> block which states:</p>

<pre><code class="language-go">if !recurse &amp;&amp; field.CanSet() {
	callback(field, sf)
}
</code></pre>

<p>You&rsquo;ll see we call <code>.CanSet()</code> on the <code>field</code> variable which (as noted earlier) is actually a <code>reflect.Value</code> type. The reason we do this is because one of the given callback functions will attempt to set a value onto the struct field and that is only valid if the struct field is public (i.e. <em>exported</em>) otherwise it would panic.</p>

<p>Let&rsquo;s jump back up to the <code>if</code> statement, in there we&rsquo;re checking the condition:</p>

<pre><code class="language-go">if field.Kind() == reflect.Struct {
  ...
}
</code></pre>

<p>This is a similar check to what we did at the start of the <code>Parse()</code> function, so why are we doing it again? Well, this time (as we iterate over the user&rsquo;s schema struct and look at each field) we might discover one of the fields is itself a struct! So we want to also iterate over the nested struct&rsquo;s fields looking for flag information.</p>

<p>All the code within this <code>if</code> block is effectively the same as what came before it with regards to getting access to the underlying struct &lsquo;value&rsquo; that is assigned to the current struct&rsquo;s field, and then looping over that nested structs own fields.</p>

<p>We could have done this with recursion but then it makes the <code>IterFields()</code> function more complex and as I was designing go-flags to work with only one level of nesting supported it wasn&rsquo;t worth the effort to implementing a strict recursive function.</p>

<p>That said, there is one aspect of the <code>if</code> block we should look at which is the <em>nested</em> <code>if</code> block. The nested <code>if</code> block is what actually does the looping over the nested struct&rsquo;s fields, and it does this by first getting at the nested struct concrete value (as I mentioned a moment ago).</p>

<p>To get at that struct value we do:</p>

<pre><code class="language-go">reflect.TypeOf(field.Interface())
</code></pre>

<p>OK, so this needs some explaining! Firstly, we call <code>.Interface()</code> on the <code>field</code> variable (which is a <code>reflect.Value</code> type) and then we pass that &lsquo;result&rsquo; to <code>reflect.TypeOf()</code>.</p>

<p>The <code>.Interface()</code> method will get the underlying concrete value as an empty interface (i.e. <code>interface{}</code>) type, and so that&rsquo;s what we pass to <code>reflect.TypeOf()</code>.</p>

<p>The reason we use <code>.Interface()</code> first is because if we had just passed the <code>field</code> variable into <code>reflect.TypeOf()</code>, then we would have gotten <code>reflect.Value</code> as the type (and that&rsquo;s no use to us! we want the struct type).</p>

<p>So why did we need the struct type? Well, after we start iterating over the nested struct&rsquo;s fields, we again need to get a <code>reflect.StructField</code> so that when we execute the given callback function it&rsquo;ll be able to parse any &lsquo;tags&rsquo; found on the nested struct fields.</p>

<p>At this point in time we&rsquo;ve explained some key bits as far as looping <em>safely</em> over the user&rsquo;s struct, so let&rsquo;s go back to what we do in some of the &lsquo;callback&rsquo; functions that get executed for each struct field.</p>

<p>One thing we do is access the struct field&rsquo;s tags, and we do this by calling <code>.Tag.Get()</code> on the <code>reflect.StructField</code> type. So in go-flags we ask users to add struct tags like so:</p>

<pre><code class="language-go">short:&quot;...&quot; usage:&quot;...&quot;
</code></pre>

<p>That&rsquo;s two tags &lsquo;short&rsquo; and &lsquo;usage&rsquo;. So if I want the &lsquo;short&rsquo; tag I&rsquo;d call <code>.Tag.Get(&quot;short&quot;)</code> and if I want the &lsquo;usage&rsquo; tag I&rsquo;d call <code>.Tag.Get(&quot;usage&quot;)</code>. Nice and simple.</p>

<p>When it comes to setting the field values we have to check the kind of the field (remember this is a <code>reflect.Value</code> type). The following switch statement demonstrates this:</p>

<pre><code class="language-go">switch field.Kind() {
case reflect.Bool:
	if b, ok := getter.Get().(bool); ok {
		field.Set(reflect.ValueOf(b))
	}
case reflect.Int:
	if i, ok := getter.Get().(int); ok {
		field.Set(reflect.ValueOf(i))
	}
case reflect.String:
	if s, ok := getter.Get().(string); ok {
		field.Set(reflect.ValueOf(s))
	}
}
</code></pre>

<p>The call to <code>.Kind()</code> returns a <code>reflect.Kind</code> type, which is an integer iota that maps constants to a numerical value for easier comparison. Hence each case is a check against some of those constants like <code>reflect.Bool</code>, <code>reflect.Int</code> and <code>reflect.String</code>.</p>

<p>Once we know what type the field is we type assert the flag value to the relevant type and then call <code>.Set()</code> on the field. You&rsquo;ll notice that we can&rsquo;t just pass the value into the <code>.Set()</code> method as we need to provide an argument of type <code>reflect.Value</code>.</p>

<p>To fix that we call <code>reflect.ValueOf()</code> and pass it the value we&rsquo;re trying to set, and then pass that resulting <code>reflect.Value</code> type into <code>.Set()</code>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Well, that&rsquo;s it! There is <em>sooooo</em> much more to reflection than what I have had time to describe in this post, but hopefully this has been enough to help you in the future if you ever stumble across a need for reflection.</p>

<p>One thing I would say before I go is: avoid reflection wherever possible. It&rsquo;s a nightmare to work with and although we can code defensively and get back some runtime safety, that&rsquo;s still no comparison to compile time safety. There&rsquo;s also a performance cost to runtime reflection that can&rsquo;t be ignored.</p>

<p>So do please think twice before reaching for reflection.</p>

          </section>
        </div>
      </div>
      <!-- Sidebar -->
<div id="sidebar">
  <div class="inner">
    <!-- Search -->
    <!--<section id="search" class="alt">-->
    <!--  <form method="post" action="#">-->
    <!--    <input type="text" name="query" id="query" placeholder="Search" />-->
    <!--  </form>-->
    <!--</section>-->
    <!-- Menu -->
    <nav id="menu">
      <header class="major">
        <h2>Menu</h2>
      </header>
      <ul>
        <li><a href="../../index.html">Home</a></li>
        <!--<li><a href="../resume/index.html">Resume</a></li>-->
				
	<li>
	  <span class="opener">Pages</span>
	  <ul>
		
	<li><a href="../../pages/christmas-movies/index.html">Christmas Movies</a></li>
	
	<li><a href="../../pages/resume/index.html">Resume</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2024</span>
	  <ul>
		
	<li><a href="../../posts/go-concurrency-patterns/index.html">Go Concurrency Patterns</a></li>
	
	<li><a href="../../posts/bitwise-operations-in-go/index.html">Bitwise Operations In Go</a></li>
	
	<li><a href="../../posts/go-typed-nil/index.html">Go Typed Nil</a></li>
	
	<li><a href="../../posts/programming-at-the-edge-with-fastly-compute/index.html">Programming At The Edge With Fastly Compute</a></li>
	
	<li><a href="../../posts/ci-cd-with-terraform-cloud-and-github-actions/index.html">Ci Cd With Terraform Cloud And Github Actions</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2023</span>
	  <ul>
		
	<li><a href="../../posts/openapi/index.html">Openapi</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2022</span>
	  <ul>
		
	<li><a href="../../posts/terraform-build-a-provider/index.html">Terraform Build A Provider</a></li>
	
	<li><a href="../../posts/rust-smart-pointers/index.html">Rust Smart Pointers</a></li>
	
	<li><a href="../../posts/laptop-setup-v2/index.html">Laptop Setup V2</a></li>
	
	<li><a href="../../posts/go-install/index.html">Go Install</a></li>
	
	<li><a href="../../posts/neovim-rust-go/index.html">Neovim Rust Go</a></li>
	
	<li><a href="../../posts/vim-themes/index.html">Vim Themes</a></li>
	
	<li><a href="../../posts/dev-tools/index.html">Dev Tools</a></li>
	
	<li><a href="../../posts/go-style-guide/index.html">Go Style Guide</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2021</span>
	  <ul>
		
	<li><a href="../../posts/vim-advanced/index.html">Vim Advanced</a></li>
	
	<li><a href="../../posts/rust-ownership/index.html">Rust Ownership</a></li>
	
	<li><a href="../../posts/github-actions/index.html">Github Actions</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2020</span>
	  <ul>
		
	<li><a href="../../posts/go-reflection/index.html">Go Reflection</a></li>
	
	<li><a href="../../posts/software-comparison/index.html">Software Comparison</a></li>
	
	<li><a href="../../posts/rate-limiting/index.html">Rate Limiting</a></li>
	
	<li><a href="../../posts/git-internals/index.html">Git Internals</a></li>
	
	<li><a href="../../posts/python-context-managers/index.html">Python Context Managers</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2019</span>
	  <ul>
		
	<li><a href="../../posts/python-generators/index.html">Python Generators</a></li>
	
	<li><a href="../../posts/tox-ini/index.html">Tox Ini</a></li>
	
	<li><a href="../../posts/python-app-dependencies/index.html">Python App Dependencies</a></li>
	
	<li><a href="../../posts/python-asyncio/index.html">Python Asyncio</a></li>
	
	<li><a href="../../posts/go-arrays-and-slices/index.html">Go Arrays And Slices</a></li>
	
	<li><a href="../../posts/anonymity/index.html">Anonymity</a></li>
	
	<li><a href="../../posts/http-caching-guide/index.html">Http Caching Guide</a></li>
	
	<li><a href="../../posts/laptop-setup/index.html">Laptop Setup</a></li>
	
	<li><a href="../../posts/git-multiple-branches/index.html">Git Multiple Branches</a></li>
	
	<li><a href="../../posts/algorithms-in-python/index.html">Algorithms In Python</a></li>
	
	<li><a href="../../posts/remote-working/index.html">Remote Working</a></li>
	
	<li><a href="../../posts/python-mocking/index.html">Python Mocking</a></li>
	
	<li><a href="../../posts/calculating-big-o/index.html">Calculating Big O</a></li>
	
	<li><a href="../../posts/algorithmic-complexity-in-python/index.html">Algorithmic Complexity In Python</a></li>
	
	<li><a href="../../posts/data-types-and-data-structures/index.html">Data Types And Data Structures</a></li>
	
	<li><a href="../../posts/design-python/index.html">Design Python</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2018</span>
	  <ul>
		
	<li><a href="../../posts/js-modern/index.html">Js Modern</a></li>
	
	<li><a href="../../posts/engineer-to-manager/index.html">Engineer To Manager</a></li>
	
	<li><a href="../../posts/interview-techniques/index.html">Interview Techniques</a></li>
	
	<li><a href="../../posts/post-mortems/index.html">Post Mortems</a></li>
	
	<li><a href="../../posts/slackbot-opsbot/index.html">Slackbot Opsbot</a></li>
	
	<li><a href="../../posts/go-interfaces/index.html">Go Interfaces</a></li>
	
	<li><a href="../../posts/multigrain-services/index.html">Multigrain Services</a></li>
	
	<li><a href="../../posts/authentication-with-aws-cognito/index.html">Authentication With Aws Cognito</a></li>
	
	<li><a href="../../posts/a-guide-to-effective-1-1-meetings/index.html">A Guide To Effective 1 1 Meetings</a></li>
	
	<li><a href="../../posts/project-management/index.html">Project Management</a></li>
	
	<li><a href="../../posts/reading-list/index.html">Reading List</a></li>
	
	<li><a href="../../posts/python-security/index.html">Python Security</a></li>
	
	<li><a href="../../posts/static-site-search/index.html">Static Site Search</a></li>
	
	<li><a href="../../posts/interview-topics/index.html">Interview Topics</a></li>
	
	<li><a href="../../posts/go-reverse-proxy/index.html">Go Reverse Proxy</a></li>
	
	<li><a href="../../posts/hashing-encryption-encoding/index.html">Hashing Encryption Encoding</a></li>
	
	<li><a href="../../posts/computers-101/index.html">Computers 101</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2017</span>
	  <ul>
		
	<li><a href="../../posts/statistics-basics/index.html">Statistics Basics</a></li>
	
	<li><a href="../../posts/queue-best-practices/index.html">Queue Best Practices</a></li>
	
	<li><a href="../../posts/monitoring-best-practices/index.html">Monitoring Best Practices</a></li>
	
	<li><a href="../../posts/load-testing-guidelines/index.html">Load Testing Guidelines</a></li>
	
	<li><a href="../../posts/logging-101/index.html">Logging 101</a></li>
	
	<li><a href="../../posts/fastly-varnish/index.html">Fastly Varnish</a></li>
	
	<li><a href="../../posts/profiling-python/index.html">Profiling Python</a></li>
	
	<li><a href="../../posts/profiling-go/index.html">Profiling Go</a></li>
	
	<li><a href="../../posts/dev-environments-within-docker-containers/index.html">Dev Environments Within Docker Containers</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2016</span>
	  <ul>
		
	<li><a href="../../posts/key-architecture/index.html">Key Architecture</a></li>
	
	<li><a href="../../posts/go-hitchhikers-guide/index.html">Go Hitchhikers Guide</a></li>
	
	<li><a href="../../posts/concepts-from-the-c-programming-language/index.html">Concepts From The C Programming Language</a></li>
	
	<li><a href="../../posts/man-pages/index.html">Man Pages</a></li>
	
	<li><a href="../../posts/c-and-syscalls/index.html">C And Syscalls</a></li>
	
	<li><a href="../../posts/bits-and-bytes/index.html">Bits And Bytes</a></li>
	
	<li><a href="../../posts/terminal-password-manager/index.html">Terminal Password Manager</a></li>
	
	<li><a href="../../posts/terminal-utils/index.html">Terminal Utils</a></li>
	
	<li><a href="../../posts/github-pull-request-formatting/index.html">Github Pull Request Formatting</a></li>
	
	<li><a href="../../posts/big-o-for-beginners/index.html">Big O For Beginners</a></li>
	
	<li><a href="../../posts/the-perfect-developer/index.html">The Perfect Developer</a></li>
	
	<li><a href="../../posts/git-merge-strategies/index.html">Git Merge Strategies</a></li>
	
	<li><a href="../../posts/grpc-for-beginners/index.html">Grpc For Beginners</a></li>
	
	<li><a href="../../posts/bash-watchtower/index.html">Bash Watchtower</a></li>
	
	<li><a href="../../posts/rpc-variations-in-go/index.html">Rpc Variations In Go</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2015</span>
	  <ul>
		
	<li><a href="../../posts/go-func-type/index.html">Go Func Type</a></li>
	
	<li><a href="../../posts/github-multiple-ssh/index.html">Github Multiple Ssh</a></li>
	
	<li><a href="../../posts/http2/index.html">Http2</a></li>
	
	<li><a href="../../posts/building-systems-with-make/index.html">Building Systems With Make</a></li>
	
	<li><a href="../../posts/client-cert-authentication/index.html">Client Cert Authentication</a></li>
	
	<li><a href="../../posts/dns-101/index.html">Dns 101</a></li>
	
	<li><a href="../../posts/security-basics/index.html">Security Basics</a></li>
	
	<li><a href="../../posts/docker-nginx/index.html">Docker Nginx</a></li>
	
	<li><a href="../../posts/designing-for-simplicity/index.html">Designing For Simplicity</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2014</span>
	  <ul>
		
	<li><a href="../../posts/concurrency/index.html">Concurrency</a></li>
	
	<li><a href="../../posts/github-workflow/index.html">Github Workflow</a></li>
	
	<li><a href="../../posts/functional-recursive-javascript-programming/index.html">Functional Recursive Javascript Programming</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2013</span>
	  <ul>
		
	<li><a href="../../posts/refactoring-techniques/index.html">Refactoring Techniques</a></li>
	
	<li><a href="../../posts/design-mvcp/index.html">Design Mvcp</a></li>
	
	<li><a href="../../posts/basic-shell-scripting/index.html">Basic Shell Scripting</a></li>
	
	<li><a href="../../posts/clean-coder/index.html">Clean Coder</a></li>
	
	<li><a href="../../posts/message-passing-in-object-oriented-code/index.html">Message Passing In Object Oriented Code</a></li>
	
	<li><a href="../../posts/design-oop/index.html">Design Oop</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2012</span>
	  <ul>
		
	<li><a href="../../posts/git-tips/index.html">Git Tips</a></li>
	
	<li><a href="../../posts/maintainable-css-with-bem/index.html">Maintainable Css With Bem</a></li>
	
	<li><a href="../../posts/host-methods-vs-native-methods/index.html">Host Methods Vs Native Methods</a></li>
	
	<li><a href="../../posts/javascript-101/index.html">Javascript 101</a></li>
	
	  </ul>
	</li>
	
      </ul>
    </nav>
    <!-- Section -->
		<!--
    <section>
      <header class="major">
        <h2>Highlights</h2>
      </header>
      <div class="mini-posts">
        <article>
          <a href="ppv-survivorseries-88.html" class="image"><img src="../images/survivor-88-index.jpg" alt="" /></a>
          <p>Get ready for the ultimate showdown as Survivor Series 1988 brings non-stop tag team action, fierce rivalries, and unforgettable battles between the biggest WWF superstars!</p>
        </article>
        <article>
          <a href="ppv-royalrumble-89.html" class="image"><img src="../images/rumble-89-index.jpg" alt="" /></a>
          <p>Royal Rumble 1989 unleashes chaos with 30 superstars battling for glory in an unforgettable over-the-top-rope showdown!</p>
        </article>
        <article>
          <a href="ppv-summerslam-88.html" class="image"><img src="../images/slam-88-index.jpg" alt="" /></a>
          <p>SummerSlam 1988 delivers explosive action with iconic matchups, as the WWF's biggest stars collide in the hottest event of the summer!</p>
        </article>
      </div>
    </section>
		-->
    <!-- Section -->
    <!--<section>-->
    <!--  <header class="major">-->
    <!--    <h2>Get in touch</h2>-->
    <!--  </header>-->
    <!--  <p>Sed varius enim lorem ullamcorper dolore aliquam aenean ornare velit lacus, ac varius enim lorem ullamcorper dolore. Proin sed aliquam facilisis ante interdum. Sed nulla amet lorem feugiat tempus aliquam.</p>-->
    <!--  <ul class="contact">-->
    <!--    <li class="icon solid fa-envelope"><a href="#">information@untitled.tld</a></li>-->
    <!--    <li class="icon solid fa-phone">(000) 000-0000</li>-->
    <!--    <li class="icon solid fa-home">1234 Somewhere Road #8254<br />-->
    <!--      Nashville, TN 00000-0000</li>-->
    <!--  </ul>-->
    <!--</section>-->
    <!-- Footer -->
    <footer id="footer">
      <p class="copyright">&copy; Integralist. All rights reserved.</p>
      <p class="copyright small">Demo Images: <a href="https://unsplash.com">Unsplash</a>. Design: <a href="https://html5up.net">HTML5 UP</a>.</p>
    </footer>
  </div>
</div>

    </div>
    <!-- Scripts -->
    <script src="../../assets/js/jquery.min.js"></script>
    <script src="../../assets/js/browser.min.js"></script>
    <script src="../../assets/js/breakpoints.min.js"></script>
    <script src="../../assets/js/util.js"></script>
    <script src="../../assets/js/main.js"></script>

		<!-- The following script is for handling the automatic TOC generated by `make build` -->
		<script>
		// Get references to the elements
		const nav = document.querySelector('#main nav');
		const h1 = document.querySelector('#main h1');

		// Move the `nav` element to be underneath the `h1`
		h1.insertAdjacentElement('afterend', nav);

		// Hide the `nav` element by default using inline styles
		nav.style.display = 'none';

		// Create a new `h2` element with the text "TOC"
		const toc = document.createElement('h2');
		toc.textContent = 'TOC';
		toc.className = "toc"

		// Add inline styles to make the `h2` look clickable
		// DISABLED: done with className
		//
		// toc.style.cursor = 'pointer';
		// toc.style.color = 'blue';
		// toc.style.textDecoration = 'underline';

		// Add a click event listener to toggle the visibility of the `nav`
		toc.addEventListener('click', () => {
				nav.style.display = nav.style.display === 'none' ? 'block' : 'none';
		});

		// Insert the `h2` element above the `nav`
		nav.insertAdjacentElement('beforebegin', toc);
		</script>

		<!-- The following script highlights the current page in the side nav -->
		<script>
		// Get the current page's URL path and normalize it
    const currentUrl = window.location.pathname;
    const normalizedCurrentUrl = currentUrl
        .replace(/.*\/(pages|posts)\//, '/$1/') // Ensure leading slash and extract from `pages/` or `posts/`
        .replace(/index\.html$/, ''); // Remove `index.html` suffix

    // Select all menu links
    const links = document.querySelectorAll('#menu ul li a');

    let matchedParentSpan = null;

    links.forEach(link => {
        // Normalize the link's href for comparison
        const normalizedHref = link.getAttribute('href')
            .replace(/^(\.\.\/)+/, '/') // Convert `../../` to `/` for consistency
            .replace(/index\.html$/, ''); // Remove `index.html` suffix

        // Check if the normalized href matches the normalized current URL
        if (normalizedHref === normalizedCurrentUrl) {
            // Add the inline style to the matching link
            link.style.color = 'black';

            // Find the parent span with the class 'opener'
            matchedParentSpan = link.closest('ul').previousElementSibling;
        }
    });

    // If a matching parent span was found, add the 'active' class
    if (matchedParentSpan && matchedParentSpan.classList.contains('opener')) {
        matchedParentSpan.classList.add('active');
    }
		</script>
  </body>
</html>
