<!DOCTYPE HTML>
<!--
	Editorial by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
  <head>
    <title>Integralist</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="../../assets/css/main.css" />
  </head>
  <body class="is-preload">
    <!-- Wrapper -->
    <div id="wrapper">
      <!-- Main -->
      <div id="main">
        <div class="inner">
          <!-- Header -->
					<header id="header">
						<a href="../../index.html" class="logo"><strong>Home</strong></a>
							<ul class="icons">
							<!--<li><a href="https://x.com/integralist" class="icon brands fa-twitter" target="blank"><span class="label">Twitter</span></a></li>-->
							<!--<li><a href="https://instagram.com/wwfsuperstarsofwrestling" class="icon brands fa-instagram" target="blank"><span class="label">Instagram</span></a></li>-->
						</ul>
					</header>

          <!-- Content -->
          <section>
						<!--
            <header class="main">
              <h1>Royal Rumble 1989</h1>
              <p>A Bizarre Spectacle Where the Madness Multiplies</p>
            </header>
            <span class="image main"><img src="../images/rumble-89.jpg" alt="" /></span>
						-->
						<nav>

<ul>
<li><a href="#rust-ownership-borrowing-and-lifetimes">Rust Ownership, Borrowing, and Lifetimes</a>
<ul>
<li><a href="#stack-memory">Stack Memory</a></li>

<li><a href="#heap-memory">Heap Memory</a></li>

<li><a href="#ownership">Ownership</a></li>

<li><a href="#borrowing">Borrowing</a>
<ul>
<li><a href="#gotchas">Gotchas</a></li>
</ul></li>

<li><a href="#lifetimes">Lifetimes</a></li>

<li><a href="#conclusion">Conclusion</a></li>
</ul></li>
</ul>

</nav>

<h1 id="rust-ownership-borrowing-and-lifetimes">Rust Ownership, Borrowing, and Lifetimes</h1>

<p>I&rsquo;ve been learning <a href="https://www.rust-lang.org/" target="_blank">Rust</a> recently. This will probably be my <em>third</em> (lazy) attempt to learn the language. The reason I&rsquo;ve failed previously is simply because I had no reason to learn it.</p>

<p>Other than the memory safety aspects, which I like a lot, I don&rsquo;t actually like the <em>design</em> of the language at all (but that&rsquo;s a conversation for another day).</p>

<p>This time around I want to learn the language as it&rsquo;s pertinent to my job. A few months ago I started working for <a href="https://www.fastly.com/" target="_blank">Fastly</a> as a Staff Software Engineer in their Developer Relations team, and their powerful <a href="https://www.fastly.com/products/edge-compute/features" target="_blank">Compute@Edge</a> platform has strong support for Rust.</p>

<p>I want to start building things on the Compute@Edge platform, so here I am giving Rust another go (at least until <a href="https://tinygo.org/" target="_blank">TinyGo</a> support matures).</p>

<p>So I know from prior experience the real learning curve involved with this language is going to be its memory management model, which is broken down into three sections:</p>

<ol>
<li><a href="https://doc.rust-lang.org/stable/book/ch04-00-understanding-ownership.html" target="_blank">Ownership</a></li>
<li><a href="https://doc.rust-lang.org/stable/book/ch04-02-references-and-borrowing.html" target="_blank">Borrowing</a></li>
<li><a href="https://doc.rust-lang.org/stable/book/ch10-03-lifetime-syntax.html" target="_blank">Lifetimes</a></li>
</ol>

<p>Understanding the first section (ownership) requires an understanding of &lsquo;stack&rsquo; vs &lsquo;heap&rsquo; memory, which you may be unfamiliar with depending on your programming experience and if you&rsquo;ve used only high-level programming languages. So here&rsquo;s a quick rundown&hellip;</p>

<h2 id="stack-memory">Stack Memory</h2>

<p>The stack is memory that is available to your program at runtime. Data that is assigned to variables or passed as arguments to function calls are allocated onto the stack in a &lsquo;Last In, First Out&rsquo; (LIFO) model, much like a stack of plates.</p>

<p>The only type of data that can be stored on the stack is data that has a known and fixed size. All other &lsquo;unknown&rsquo; data must go onto the heap.</p>

<p>The stack is very fast to access data because the data is close together, unlike heap memory, and also because the data that is stored is literal (i.e. primitive types like string literals, booleans, integers etc) it means the data itself can be hard coded into the compiled Rust binary.</p>

<blockquote>
<p><strong>NOTE</strong>: Rust primitive/scalar types (int, bool, float, char, string literal etc) are stored in stack memory.</p>
</blockquote>

<h2 id="heap-memory">Heap Memory</h2>

<p>The heap is memory that is also available to your program at runtime but is much slower to access than stack memory. This is because it requires a &lsquo;pointer&rsquo; to locate the stored data, of which the storage area is large and very unorganized.</p>

<p>The heap is for memory that grows or has unknown size (such as when accepting user input, you don&rsquo;t know what data will be provided), and it will be allocated onto the heap by a &lsquo;memory allocator&rsquo; that needs to first find a space in the heap large enough to hold the data, and then return a pointer to that space in the heap.</p>

<blockquote>
<p><strong>NOTE</strong>: Rust complex types (String, Box etc.) are stored into heap memory.</p>
</blockquote>

<h2 id="ownership">Ownership</h2>

<p>The rules for ownership are quite simple:</p>

<ul>
<li>Data is assigned to a variable.</li>
<li>The variable becomes the &lsquo;owner&rsquo; of the data.</li>
<li>There can only be one owner at a time.</li>
<li>When the owner goes out of scope, the data will be dropped.</li>
</ul>

<p>Primitive types are popped from stack memory automatically when they go out of scope (e.g. when a function block ends), while complex types must implement a <code>drop</code> function which Rust will call when out of scope (to explicitly deallocate the heap memory).</p>

<p>So here are some of the gotchas that trip people up:</p>

<ul>
<li>Primitive types are <em>copied</em> (because it&rsquo;s cheap to copy stack memory).</li>
<li>Primitive types have a <code>Copy</code> trait that enable this behaviour.</li>
<li>Complex types <em>move</em> ownership.</li>
<li>Complex types do not have a <code>Copy</code> trait.</li>
</ul>

<p>As an example, consider the following code, which compiles correctly because we&rsquo;re dealing with primitives and so the <code>println!()</code> macro used is safely able to reference both the variable <code>a</code> and <code>b</code>.</p>

<pre><code class="language-rust">fn main() {
    let a = 123;
    let b = a;
    
    println!(&quot;a: {}, b: {}&quot;, a, b); // a: 123, b: 123
}
</code></pre>

<p>Now consider a similar example which <em>doesn&rsquo;t</em> work because we&rsquo;re dealing with a complex type (<code>String</code>). The value assigned to <code>a</code> is <em>moved</em> to <code>b</code>. The <code>b</code> variable has now become the new <em>owner</em> of the data, and this means <code>a</code> is not allowed to be used again (e.g. we can&rsquo;t reference it in <code>println!()</code>).</p>

<pre><code class="language-rust">fn main() {
    let a = String::from(&quot;foo&quot;);
    let b = a;
    
    println!(&quot;a: {}, b: {}&quot;, a, b); // COMPILER ERROR
}
</code></pre>

<p>This will generate the following compiler error:</p>

<pre><code class="language-rust">error[E0382]: borrow of moved value: `a`
 --&gt; src/main.rs:5:30
  |
2 |     let a = String::from(&quot;foo&quot;);
  |         - move occurs because `a` has type `String`, which does not implement the `Copy` trait
3 |     let b = a;
  |             - value moved here
4 |     
5 |     println!(&quot;a: {}, b: {}&quot;, a, b);
  |                              ^ value borrowed here after move
</code></pre>

<p>The only solution here is to manually <em>copy</em> the value using the <a href="https://doc.rust-lang.org/alloc/string/struct.String.html#impl-Clone" target="_blank"><code>.clone()</code></a> method of the <code>String</code> type, which means <code>b</code> no longer becomes the new owner of the data (the data itself is duplicated and so it&rsquo;s <em>new</em> data that <code>b</code> is the owner of):</p>

<pre><code class="language-rust">fn main() {
    let a = String::from(&quot;foo&quot;);
    let b = a.clone();
    
    println!(&quot;a: {}, b: {}&quot;, a, b); // a: foo, b: foo
}
</code></pre>

<p>Using <code>clone()</code> will duplicate the heap memory, which isn&rsquo;t cheap. This forces the programmer to opt into this more expensive behaviour, and is a performance/design decision most users of high-level programming languages don&rsquo;t often have to think about.</p>

<p>It&rsquo;s important to realise that passing a variable to a function will either move or copy (just as assignment does), and that even a function&rsquo;s return value can transfer ownership in the same way. So for example, returning a complex type will move ownership to the caller (and the variable the returned value is assigned to becomes the new owner).</p>

<p>In that scenario the complex type&rsquo;s <code>drop</code> function is <em>not</em> called, as would normally be the case if a variable went out of scope at the end of a function (even if the original variable/owner was created within the function) as the compiler is able to determine that the value shouldn&rsquo;t be dropped and instead is being <em>moved</em> to a new owner somewhere else in your program.</p>

<h2 id="borrowing">Borrowing</h2>

<p>The concept of borrowing is designed to make dealing with ownership changes easier. It does this by avoiding the <em>moving</em> of owners. The way it does this is by letting your program provide a &lsquo;reference&rsquo; to the data. This means the receiver of the reference (e.g. a function, struct field or a variable etc) can use the value temporarily without taking ownership of it.</p>

<p>To pass a reference instead of passing over ownership, all you have to do is prefix your variable with an ampersand:</p>

<pre><code class="language-rust">fn main() {
    let s = String::from(&quot;foo&quot;);
    
    borrow(&amp;s) // pass a 'reference' to s
}

fn borrow(s: &amp;String) { // accept a 'reference type'
    println!(&quot;s: {}&quot;, s);
}
</code></pre>

<p>In the above example, the <code>s</code> argument variable of the <code>borrow</code> function will be created on the stack, and will <em>point</em> to data in heap memory. When the <code>borrow</code> function finishes and the <code>s</code> variable is popped off the stack it won&rsquo;t delete any data because it never owned the data that <code>s</code> was pointing to.</p>

<p>The next thing you&rsquo;ll likely want to do in your programs is to have functions that borrow data to be able to <em>mutate</em> it. That&rsquo;s simple enough by using the <a href="https://doc.rust-lang.org/std/keyword.mut.html" target="_blank"><code>mut</code></a> keyword.</p>

<p>Notice in the below example code we not only define the <code>main</code> function&rsquo;s <code>s</code> variable to be mutable but we also have to change the reference in the call to <code>borrow()</code> as well as the <code>borrow</code> function&rsquo;s signature to accept a mutable reference.</p>

<p>Also notice that after borrowing the value, we call <code>take_ownership()</code> and we don&rsquo;t pass a &lsquo;reference&rsquo;, meaning the function is the new owner of the data that was belonging to <code>s</code>:</p>

<pre><code class="language-rust">fn main() {
    let mut s = String::from(&quot;foo&quot;);
    
    println!(&quot;s: {}&quot;, s); // s: foo
    
    borrow(&amp;mut s);
    
    println!(&quot;s: {}&quot;, s); // s: foobar
    
    take_ownership(s);
    
    println!(&quot;s: {}&quot;, s); // COMPILER ERROR (ownership of s was moved)
}

fn borrow(s: &amp;mut String) {
    s.push_str(&quot;bar&quot;);
}

fn take_ownership(s: String) {
    println!(&quot;s: {}&quot;, s); // s: foobar
}
</code></pre>

<p>It&rsquo;s also important at this point to understand that defining a variable as being &lsquo;mutable&rsquo; and passing a &lsquo;mutable reference&rsquo; are two different things. You can see in the below example code that we have said <code>s</code> is mutable and then we pass it as an immutable reference to <code>borrow_no_mut()</code> and then as a mutable reference to <code>borrow_with_mut()</code>:</p>

<pre><code class="language-rust">fn main() {
    let mut s = String::from(&quot;foo&quot;);
    
    borrow_no_mut(&amp;s);
    borrow_with_mut(&amp;mut s);
    
    println!(&quot;s: {}&quot;, s) // foobar
}

fn borrow_no_mut(s: &amp;String) {
    println!(&quot;s: {}&quot;, s) // foo
}

fn borrow_with_mut(s: &amp;mut String) {
    s.push_str(&quot;bar&quot;);
}
</code></pre>

<h3 id="gotchas">Gotchas</h3>

<ul>
<li>You can&rsquo;t take a reference and then modify the original variable&rsquo;s value.</li>
</ul>

<p>Here&rsquo;s an example that doesn&rsquo;t compile:</p>

<pre><code class="language-rust">fn main() {
    let mut x;
    x = 42;
    let y = &amp;x;
    x = 43;
    println!(&quot;{:?}&quot;, y);
}
</code></pre>

<p>In the above example we define <code>x</code> and assign the value <code>42</code>. Next we define <code>y</code> and take a reference to <code>x</code> (i.e. we &lsquo;borrow&rsquo; it). Lastly we try to reassign a new value to <code>x</code> while still holding a reference to it, which isn&rsquo;t allowed because it would potentially invalidate the reference.</p>

<p>This would result in the following compiler error:</p>

<pre><code class="language-bash">$ cargo run
   Compiling chapter1 v0.1.0 (/Users/integralist/Code/rust/rust-for-rustaceans/chapter1)
warning: value assigned to `x` is never read
 --&gt; src/main.rs:5:5
  |
5 |     x = 43;
  |     ^
  |
  = note: `#[warn(unused_assignments)]` on by default
  = help: maybe it is overwritten before being read?

error[E0506]: cannot assign to `x` because it is borrowed
 --&gt; src/main.rs:5:5
  |
4 |     let y = &amp;x;
  |             -- borrow of `x` occurs here
5 |     x = 43;
  |     ^^^^^^ assignment to borrowed `x` occurs here
6 |     println!(&quot;{:?}&quot;, y);
  |                      - borrow later used here

For more information about this error, try `rustc --explain E0506`.
warning: `chapter1` (bin &quot;chapter1&quot;) generated 1 warning
error: could not compile `chapter1` due to previous error; 1 warning emitted
</code></pre>

<p>To solve this problem you need <code>y</code> to fall out of scope (or alternatively create a function so that when the function is called with a reference the reference drops out of scope at the end). This can be done using block scope syntax like so:</p>

<pre><code class="language-rust">fn main() {
    let mut x;
    x = 42;
    {
        let y = &amp;x;
        println!(&quot;{:?}&quot;, y); // 42
    }
    x = 43;
    println!(&quot;{:?}&quot;, x); // 43
}
</code></pre>

<p>Another <em>gotcha</em>:</p>

<ul>
<li>You can have only <strong>one</strong> mutable reference (i.e. this prevents data races).</li>
</ul>

<p>&hellip;<em>unless</em>! the scope allows for it.</p>

<p>So here is an example where it <em>isn&rsquo;t</em> allowed:</p>

<pre><code class="language-rust">fn main() {
    let mut s = String::from(&quot;foo&quot;);
    
    let a = &amp;mut s;
    
    borrow(a);
    
    let b = &amp;mut s;
    
    borrow(b);
    
    println!(&quot;a: {}&quot;, a); // COMPILER ERROR
    println!(&quot;b: {}&quot;, b);
}

fn borrow(s: &amp;mut String) {
    s.push_str(&quot;bar&quot;);
}
</code></pre>

<p>To make this example work we need the scope rules to allow for it, which means moving the first mutable reference assignment into its own block where the end of the newly defined block&rsquo;s scope will cause <code>a</code> to be dropped:</p>

<pre><code class="language-rust">fn main() {
    let mut s = String::from(&quot;foo&quot;);
    
    {
        let a = &amp;mut s;
        borrow(a);
        println!(&quot;a: {}&quot;, a); // foobar
    } // &lt;-- a is dropped
    
    let b = &amp;mut s;
    borrow(b);
    println!(&quot;b: {}&quot;, b); // foobarbar
}

fn borrow(s: &amp;mut String) {
    s.push_str(&quot;bar&quot;);
}
</code></pre>

<p>Another <em>gotcha</em>:</p>

<ul>
<li>You cannot have a mutable reference <em>and</em> an immutable reference.</li>
</ul>

<p>Here&rsquo;s an example where the compiler complains:</p>

<pre><code class="language-rust">fn main() {
    let mut s = String::from(&quot;foo&quot;);
    
    let a = &amp;s;     // immutable reference
    let b = &amp;mut s; // mutable reference
    
    borrow(b);
    
    println!(&quot;a: {}&quot;, a); // COMPILER ERROR
    println!(&quot;b: {}&quot;, b);
}

fn borrow(s: &amp;mut String) {
    s.push_str(&quot;bar&quot;);
}
</code></pre>

<p>Multiple immutable references are safe because you&rsquo;re only able to <em>read</em> the data and not mutate it, but you cannot have an immutable reference while also holding a mutable reference because this otherwise could change the value of the immutable reference (and that would be unexpected for the part of the program using the immutable reference).</p>

<p>The only way this would be allowed is if the immutable reference goes out of scope before the mutable reference(s) were assigned:</p>

<pre><code class="language-rust">fn main() {
    let mut s = String::from(&quot;foo&quot;);
    
    {
        let a = &amp;s;
        println!(&quot;a: {}&quot;, a); // foo
    } // &lt;-- immutable reference `a` is dropped
    
    let b = &amp;mut s;
    borrow(b);
    println!(&quot;b: {}&quot;, b); // foobar
}

fn borrow(s: &amp;mut String) {
    s.push_str(&quot;bar&quot;);
}
</code></pre>

<p>One last gotcha:</p>

<ul>
<li>You can&rsquo;t return a function defined variable as a reference.</li>
</ul>

<p>Here&rsquo;s what that might look like:</p>

<pre><code class="language-rust">fn main() {
    let r = return_ref();
    println!(&quot;r: {}&quot;, r); // foo
}

fn return_ref&lt;'a&gt;() -&gt; &amp;'a String {
    let s = String::from(&quot;foo&quot;);
    return &amp;s; // COMPILER ERROR
}
</code></pre>

<blockquote>
<p><strong>NOTE</strong>: the <code>&lt;'a&gt;</code> and <code>&amp;'a</code> syntax will be explained in the next section called &ldquo;Lifetimes&rdquo;.</p>
</blockquote>

<p>The above code will cause the following compiler error:</p>

<pre><code class="language-bash">error[E0515]: cannot return reference to local variable `s`
 --&gt; src/main.rs:8:12
  |
8 |     return &amp;s; // COMPILER ERROR
  |            ^^ returns a reference to data owned by the current function
</code></pre>

<p>If you look at the compiler explanation for the error (<code>rustc --explain E0515</code>) it describes the reason, and the solution:</p>

<blockquote>
<p>Local variables, function parameters and temporaries are all dropped before the end of the function body. So a reference to them cannot be returned. Consider returning an owned value instead.</p>
</blockquote>

<p>So the solution to this problem is to &lsquo;move&rsquo; ownership of the data to whoever is calling the function, like so:</p>

<pre><code class="language-rust">fn main() {
    let r = return_ref();
    println!(&quot;r: {}&quot;, r); // foo
}

fn return_ref() -&gt; String {
    let s = String::from(&quot;foo&quot;);
    return s;
}
</code></pre>

<p>In the above example the <code>r</code> variable is now the new owner of the data.</p>

<h2 id="lifetimes">Lifetimes</h2>

<p>Lifetimes are tightly coupled to &lsquo;references&rsquo;.</p>

<p>A &lsquo;lifetime&rsquo; is how long a reference lives for, and the compiler wants to be sure that any reference that is currently active doesn&rsquo;t refer to data that no longer exists (i.e. a &lsquo;dangling pointer&rsquo;).</p>

<p>The compiler needs a way to track a reference so it can be sure the reference lives long enough for no errors to occur. To achieve this goal, the Rust compiler uses a &ldquo;borrow checker&rdquo; to validate a reference&rsquo;s lifetime.</p>

<p>So how do we identify the lifetime of a reference? Well, it begins when the reference is created and it ends when the reference is <em>last used</em> (you might have expected it to be when the reference was dropped/out of scope, which would be incorrect).</p>

<p>What does a lifetime look like? It&rsquo;s just an annotation that has a specific naming convention: <code>'&lt;T&gt;</code> where <code>&lt;T&gt;</code> is a letter like <code>'a</code> or <code>'b</code>. The letters don&rsquo;t mean anything special, they&rsquo;re just a way for the compiler to track a reference.</p>

<p>The Rust online book has a good example of this, where they define a function that accepts two arguments <code>x</code> and <code>y</code> (both of type <code>&amp;str</code>, i.e. a string literal) and depending on the length of the given strings you&rsquo;ll get back either the <code>x</code> or <code>y</code> string.</p>

<p>Without the lifetime feature this would be a problem for the compiler because it wouldn&rsquo;t be able to statically determine which variable (<code>x</code> or <code>y</code>) is going to be returned. That can only be determined at <em>runtime</em> not compile time.</p>

<p>The below code example highlights how defining a single lifetime called <code>'a</code> and assigning it to both arguments (and to the return value) allows the compiler to track these references and ensure they both live long enough to prevent any errors at runtime.</p>

<pre><code class="language-rust">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre>

<p>The above code states all the references in the signature must have the same lifetime, and it tells the borrow checker it should reject any values that don&rsquo;t adhere to these constraints.</p>

<p>This means that if either of the arguments <code>x</code> or <code>y</code> don&rsquo;t live long enough to be used safely, the compiler will let you know about it.</p>

<p>Here is an example that demonstrates the potential error when the code is poorly designed:</p>

<pre><code class="language-rust">fn main() {
    let string1 = String::from(&quot;a very long string&quot;);
    let result;
    {
        let string2 = String::from(&quot;short string&quot;);
        result = longest(string1.as_str(), string2.as_str());
    }
    println!(&quot;The longest string is {}&quot;, result);
}

fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre>

<p>The above code will cause the following compiler error:</p>

<pre><code class="language-bash">error[E0597]: `string2` does not live long enough
 --&gt; src/main.rs:6:44
  |
6 |         result = longest(string1.as_str(), string2.as_str());
  |                                            ^^^^^^^ borrowed value does not live long enough
7 |     }
  |     - `string2` dropped here while still borrowed
8 |     println!(&quot;The longest string is {}&quot;, result);
  |                                          ------ borrow later used here
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>Although I&rsquo;m very new to these concepts that Rust defines, I get the feeling that although understanding them at a high-level (as I&rsquo;ve described them in this post) is reasonably easy. Being able to fully appreciate them and more importantly getting <em>comfortable</em> with them is just something that&rsquo;s going to take time.</p>

<p>Let me know if this helped you. Reach out to me on twitter.</p>

          </section>
        </div>
      </div>
      <!-- Sidebar -->
<div id="sidebar">
  <div class="inner">
    <!-- Search -->
    <!--<section id="search" class="alt">-->
    <!--  <form method="post" action="#">-->
    <!--    <input type="text" name="query" id="query" placeholder="Search" />-->
    <!--  </form>-->
    <!--</section>-->
    <!-- Menu -->
    <nav id="menu">
      <header class="major">
        <h2>Menu</h2>
      </header>
      <ul>
        <li><a href="../../index.html">Home</a></li>
        <!--<li><a href="../resume/index.html">Resume</a></li>-->
				
	<li>
	  <span class="opener">Pages</span>
	  <ul>
		
	<li><a href="../../pages/christmas-movies/index.html">Christmas Movies</a></li>
	
	<li><a href="../../pages/resume/index.html">Resume</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2024</span>
	  <ul>
		
	<li><a href="../../posts/go-concurrency-patterns/index.html">Go Concurrency Patterns</a></li>
	
	<li><a href="../../posts/bitwise-operations-in-go/index.html">Bitwise Operations In Go</a></li>
	
	<li><a href="../../posts/go-typed-nil/index.html">Go Typed Nil</a></li>
	
	<li><a href="../../posts/programming-at-the-edge-with-fastly-compute/index.html">Programming At The Edge With Fastly Compute</a></li>
	
	<li><a href="../../posts/ci-cd-with-terraform-cloud-and-github-actions/index.html">Ci Cd With Terraform Cloud And Github Actions</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2023</span>
	  <ul>
		
	<li><a href="../../posts/openapi/index.html">Openapi</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2022</span>
	  <ul>
		
	<li><a href="../../posts/terraform-build-a-provider/index.html">Terraform Build A Provider</a></li>
	
	<li><a href="../../posts/rust-smart-pointers/index.html">Rust Smart Pointers</a></li>
	
	<li><a href="../../posts/laptop-setup-v2/index.html">Laptop Setup V2</a></li>
	
	<li><a href="../../posts/go-install/index.html">Go Install</a></li>
	
	<li><a href="../../posts/neovim-rust-go/index.html">Neovim Rust Go</a></li>
	
	<li><a href="../../posts/vim-themes/index.html">Vim Themes</a></li>
	
	<li><a href="../../posts/dev-tools/index.html">Dev Tools</a></li>
	
	<li><a href="../../posts/go-style-guide/index.html">Go Style Guide</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2021</span>
	  <ul>
		
	<li><a href="../../posts/vim-advanced/index.html">Vim Advanced</a></li>
	
	<li><a href="../../posts/rust-ownership/index.html">Rust Ownership</a></li>
	
	<li><a href="../../posts/github-actions/index.html">Github Actions</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2020</span>
	  <ul>
		
	<li><a href="../../posts/go-reflection/index.html">Go Reflection</a></li>
	
	<li><a href="../../posts/software-comparison/index.html">Software Comparison</a></li>
	
	<li><a href="../../posts/rate-limiting/index.html">Rate Limiting</a></li>
	
	<li><a href="../../posts/git-internals/index.html">Git Internals</a></li>
	
	<li><a href="../../posts/python-context-managers/index.html">Python Context Managers</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2019</span>
	  <ul>
		
	<li><a href="../../posts/python-generators/index.html">Python Generators</a></li>
	
	<li><a href="../../posts/tox-ini/index.html">Tox Ini</a></li>
	
	<li><a href="../../posts/python-app-dependencies/index.html">Python App Dependencies</a></li>
	
	<li><a href="../../posts/python-asyncio/index.html">Python Asyncio</a></li>
	
	<li><a href="../../posts/go-arrays-and-slices/index.html">Go Arrays And Slices</a></li>
	
	<li><a href="../../posts/anonymity/index.html">Anonymity</a></li>
	
	<li><a href="../../posts/http-caching-guide/index.html">Http Caching Guide</a></li>
	
	<li><a href="../../posts/laptop-setup/index.html">Laptop Setup</a></li>
	
	<li><a href="../../posts/git-multiple-branches/index.html">Git Multiple Branches</a></li>
	
	<li><a href="../../posts/algorithms-in-python/index.html">Algorithms In Python</a></li>
	
	<li><a href="../../posts/remote-working/index.html">Remote Working</a></li>
	
	<li><a href="../../posts/python-mocking/index.html">Python Mocking</a></li>
	
	<li><a href="../../posts/calculating-big-o/index.html">Calculating Big O</a></li>
	
	<li><a href="../../posts/algorithmic-complexity-in-python/index.html">Algorithmic Complexity In Python</a></li>
	
	<li><a href="../../posts/data-types-and-data-structures/index.html">Data Types And Data Structures</a></li>
	
	<li><a href="../../posts/design-python/index.html">Design Python</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2018</span>
	  <ul>
		
	<li><a href="../../posts/js-modern/index.html">Js Modern</a></li>
	
	<li><a href="../../posts/engineer-to-manager/index.html">Engineer To Manager</a></li>
	
	<li><a href="../../posts/interview-techniques/index.html">Interview Techniques</a></li>
	
	<li><a href="../../posts/post-mortems/index.html">Post Mortems</a></li>
	
	<li><a href="../../posts/slackbot-opsbot/index.html">Slackbot Opsbot</a></li>
	
	<li><a href="../../posts/go-interfaces/index.html">Go Interfaces</a></li>
	
	<li><a href="../../posts/multigrain-services/index.html">Multigrain Services</a></li>
	
	<li><a href="../../posts/authentication-with-aws-cognito/index.html">Authentication With Aws Cognito</a></li>
	
	<li><a href="../../posts/a-guide-to-effective-1-1-meetings/index.html">A Guide To Effective 1 1 Meetings</a></li>
	
	<li><a href="../../posts/project-management/index.html">Project Management</a></li>
	
	<li><a href="../../posts/reading-list/index.html">Reading List</a></li>
	
	<li><a href="../../posts/python-security/index.html">Python Security</a></li>
	
	<li><a href="../../posts/static-site-search/index.html">Static Site Search</a></li>
	
	<li><a href="../../posts/interview-topics/index.html">Interview Topics</a></li>
	
	<li><a href="../../posts/go-reverse-proxy/index.html">Go Reverse Proxy</a></li>
	
	<li><a href="../../posts/hashing-encryption-encoding/index.html">Hashing Encryption Encoding</a></li>
	
	<li><a href="../../posts/computers-101/index.html">Computers 101</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2017</span>
	  <ul>
		
	<li><a href="../../posts/statistics-basics/index.html">Statistics Basics</a></li>
	
	<li><a href="../../posts/queue-best-practices/index.html">Queue Best Practices</a></li>
	
	<li><a href="../../posts/monitoring-best-practices/index.html">Monitoring Best Practices</a></li>
	
	<li><a href="../../posts/load-testing-guidelines/index.html">Load Testing Guidelines</a></li>
	
	<li><a href="../../posts/logging-101/index.html">Logging 101</a></li>
	
	<li><a href="../../posts/fastly-varnish/index.html">Fastly Varnish</a></li>
	
	<li><a href="../../posts/profiling-python/index.html">Profiling Python</a></li>
	
	<li><a href="../../posts/profiling-go/index.html">Profiling Go</a></li>
	
	<li><a href="../../posts/dev-environments-within-docker-containers/index.html">Dev Environments Within Docker Containers</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2016</span>
	  <ul>
		
	<li><a href="../../posts/key-architecture/index.html">Key Architecture</a></li>
	
	<li><a href="../../posts/go-hitchhikers-guide/index.html">Go Hitchhikers Guide</a></li>
	
	<li><a href="../../posts/concepts-from-the-c-programming-language/index.html">Concepts From The C Programming Language</a></li>
	
	<li><a href="../../posts/man-pages/index.html">Man Pages</a></li>
	
	<li><a href="../../posts/c-and-syscalls/index.html">C And Syscalls</a></li>
	
	<li><a href="../../posts/bits-and-bytes/index.html">Bits And Bytes</a></li>
	
	<li><a href="../../posts/terminal-password-manager/index.html">Terminal Password Manager</a></li>
	
	<li><a href="../../posts/terminal-utils/index.html">Terminal Utils</a></li>
	
	<li><a href="../../posts/github-pull-request-formatting/index.html">Github Pull Request Formatting</a></li>
	
	<li><a href="../../posts/big-o-for-beginners/index.html">Big O For Beginners</a></li>
	
	<li><a href="../../posts/the-perfect-developer/index.html">The Perfect Developer</a></li>
	
	<li><a href="../../posts/git-merge-strategies/index.html">Git Merge Strategies</a></li>
	
	<li><a href="../../posts/grpc-for-beginners/index.html">Grpc For Beginners</a></li>
	
	<li><a href="../../posts/bash-watchtower/index.html">Bash Watchtower</a></li>
	
	<li><a href="../../posts/rpc-variations-in-go/index.html">Rpc Variations In Go</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2015</span>
	  <ul>
		
	<li><a href="../../posts/go-func-type/index.html">Go Func Type</a></li>
	
	<li><a href="../../posts/github-multiple-ssh/index.html">Github Multiple Ssh</a></li>
	
	<li><a href="../../posts/http2/index.html">Http2</a></li>
	
	<li><a href="../../posts/building-systems-with-make/index.html">Building Systems With Make</a></li>
	
	<li><a href="../../posts/client-cert-authentication/index.html">Client Cert Authentication</a></li>
	
	<li><a href="../../posts/dns-101/index.html">Dns 101</a></li>
	
	<li><a href="../../posts/security-basics/index.html">Security Basics</a></li>
	
	<li><a href="../../posts/docker-nginx/index.html">Docker Nginx</a></li>
	
	<li><a href="../../posts/designing-for-simplicity/index.html">Designing For Simplicity</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2014</span>
	  <ul>
		
	<li><a href="../../posts/concurrency/index.html">Concurrency</a></li>
	
	<li><a href="../../posts/github-workflow/index.html">Github Workflow</a></li>
	
	<li><a href="../../posts/functional-recursive-javascript-programming/index.html">Functional Recursive Javascript Programming</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2013</span>
	  <ul>
		
	<li><a href="../../posts/refactoring-techniques/index.html">Refactoring Techniques</a></li>
	
	<li><a href="../../posts/design-mvcp/index.html">Design Mvcp</a></li>
	
	<li><a href="../../posts/basic-shell-scripting/index.html">Basic Shell Scripting</a></li>
	
	<li><a href="../../posts/clean-coder/index.html">Clean Coder</a></li>
	
	<li><a href="../../posts/message-passing-in-object-oriented-code/index.html">Message Passing In Object Oriented Code</a></li>
	
	<li><a href="../../posts/design-oop/index.html">Design Oop</a></li>
	
	  </ul>
	</li>
	
	<li>
	  <span class="opener">2012</span>
	  <ul>
		
	<li><a href="../../posts/git-tips/index.html">Git Tips</a></li>
	
	<li><a href="../../posts/maintainable-css-with-bem/index.html">Maintainable Css With Bem</a></li>
	
	<li><a href="../../posts/host-methods-vs-native-methods/index.html">Host Methods Vs Native Methods</a></li>
	
	<li><a href="../../posts/javascript-101/index.html">Javascript 101</a></li>
	
	  </ul>
	</li>
	
      </ul>
    </nav>
    <!-- Section -->
		<!--
    <section>
      <header class="major">
        <h2>Highlights</h2>
      </header>
      <div class="mini-posts">
        <article>
          <a href="ppv-survivorseries-88.html" class="image"><img src="../images/survivor-88-index.jpg" alt="" /></a>
          <p>Get ready for the ultimate showdown as Survivor Series 1988 brings non-stop tag team action, fierce rivalries, and unforgettable battles between the biggest WWF superstars!</p>
        </article>
        <article>
          <a href="ppv-royalrumble-89.html" class="image"><img src="../images/rumble-89-index.jpg" alt="" /></a>
          <p>Royal Rumble 1989 unleashes chaos with 30 superstars battling for glory in an unforgettable over-the-top-rope showdown!</p>
        </article>
        <article>
          <a href="ppv-summerslam-88.html" class="image"><img src="../images/slam-88-index.jpg" alt="" /></a>
          <p>SummerSlam 1988 delivers explosive action with iconic matchups, as the WWF's biggest stars collide in the hottest event of the summer!</p>
        </article>
      </div>
    </section>
		-->
    <!-- Section -->
    <!--<section>-->
    <!--  <header class="major">-->
    <!--    <h2>Get in touch</h2>-->
    <!--  </header>-->
    <!--  <p>Sed varius enim lorem ullamcorper dolore aliquam aenean ornare velit lacus, ac varius enim lorem ullamcorper dolore. Proin sed aliquam facilisis ante interdum. Sed nulla amet lorem feugiat tempus aliquam.</p>-->
    <!--  <ul class="contact">-->
    <!--    <li class="icon solid fa-envelope"><a href="#">information@untitled.tld</a></li>-->
    <!--    <li class="icon solid fa-phone">(000) 000-0000</li>-->
    <!--    <li class="icon solid fa-home">1234 Somewhere Road #8254<br />-->
    <!--      Nashville, TN 00000-0000</li>-->
    <!--  </ul>-->
    <!--</section>-->
    <!-- Footer -->
    <footer id="footer">
      <p class="copyright">&copy; Integralist. All rights reserved.</p>
      <p class="copyright small">Demo Images: <a href="https://unsplash.com">Unsplash</a>. Design: <a href="https://html5up.net">HTML5 UP</a>.</p>
    </footer>
  </div>
</div>

    </div>
    <!-- Scripts -->
    <script src="../../assets/js/jquery.min.js"></script>
    <script src="../../assets/js/browser.min.js"></script>
    <script src="../../assets/js/breakpoints.min.js"></script>
    <script src="../../assets/js/util.js"></script>
    <script src="../../assets/js/main.js"></script>

		<!-- The following script is for handling the automatic TOC generated by `make build` -->
		<script>
		// Get references to the elements
		const nav = document.querySelector('#main nav');
		const h1 = document.querySelector('#main h1');

		// Move the `nav` element to be underneath the `h1`
		h1.insertAdjacentElement('afterend', nav);

		// Hide the `nav` element by default using inline styles
		nav.style.display = 'none';

		// Create a new `h2` element with the text "TOC"
		const toc = document.createElement('h2');
		toc.textContent = 'TOC';
		toc.className = "toc"

		// Add inline styles to make the `h2` look clickable
		// DISABLED: done with className
		//
		// toc.style.cursor = 'pointer';
		// toc.style.color = 'blue';
		// toc.style.textDecoration = 'underline';

		// Add a click event listener to toggle the visibility of the `nav`
		toc.addEventListener('click', () => {
				nav.style.display = nav.style.display === 'none' ? 'block' : 'none';
		});

		// Insert the `h2` element above the `nav`
		nav.insertAdjacentElement('beforebegin', toc);
		</script>

		<!-- The following script highlights the current page in the side nav -->
		<script>
		// Get the current page's URL path and normalize it
    const currentUrl = window.location.pathname;
    const normalizedCurrentUrl = currentUrl
        .replace(/.*\/(pages|posts)\//, '/$1/') // Ensure leading slash and extract from `pages/` or `posts/`
        .replace(/index\.html$/, ''); // Remove `index.html` suffix

    // Select all menu links
    const links = document.querySelectorAll('#menu ul li a');

    let matchedParentSpan = null;

    links.forEach(link => {
        // Normalize the link's href for comparison
        const normalizedHref = link.getAttribute('href')
            .replace(/^(\.\.\/)+/, '/') // Convert `../../` to `/` for consistency
            .replace(/index\.html$/, ''); // Remove `index.html` suffix

        // Check if the normalized href matches the normalized current URL
        if (normalizedHref === normalizedCurrentUrl) {
            // Add the inline style to the matching link
            link.style.color = 'black';

            // Find the parent span with the class 'opener'
            matchedParentSpan = link.closest('ul').previousElementSibling;
        }
    });

    // If a matching parent span was found, add the 'active' class
    if (matchedParentSpan && matchedParentSpan.classList.contains('opener')) {
        matchedParentSpan.classList.add('active');
    }
		</script>
  </body>
</html>
