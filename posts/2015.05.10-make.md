# Build Systems using Make

- [Introduction](#1)
- [Hello World Example](#2)
- [Terminology](#3)
- [Automatic variables](#4)
- [Commands](#5)
- [Targets as Prerequisites](#6)
- [Accessing targets](#7)
- [Parsing targets and prerequisites](#8)
- [Dynamic targets](#9)
- [Dereferencing (Variables and Macros)](#10)
- [Functions](#11)
- [Conventions](#12)
- [Includes](#13)
- [Conclusion](#14)

<div id="1"></div>
## Introduction 

Most developers use a build tool of some sort nowadays. I'm not refering to Continuous Integration software like [Jenkins CI](http://jenkins-ci.org/) per se (which is a very popular build system), but more so the lower level software it uses to actually acquire dependencies and construct your applications with.

There is a dizzying array of options to choose from:

- [Apache Ant](http://ant.apache.org/) (XML based)
- [Rake](http://docs.seattlerb.org/rake/) (Ruby based)
- [Grunt](http://gruntjs.com/) (JS based)
- [Gulp](http://gulpjs.com/) (JS based)
- [Broccoli](https://github.com/broccolijs/broccoli) (JS based)
- [NPM](https://www.npmjs.com/) (JS based)
- Good ole shell scripts (no real orchestration around it)

The build tool I want to look at in more detail here though is the grandaddy of them all: [Make](http://www.gnu.org/software/make/). 

Originally designed back in 1976, it is the leading build utility for Unix, Linux and Mac OSX. So chances are most computers you login to will already have it installed and available to use. That is a big plus in my opinion and really reduces the set-up entry point (which for other tools listed above can be tedious and error prone - with the exception of shell scripts, as the shell is something inherently available for all systems).

My hope is for you to see that Make is an automation/orchestration tool that can be used in place of other modern build tools, and will help to strengthen your understanding and ability to utilise the terminal/shell environment (which is a big plus in my book and will open up many avenues of technical progression).

I couldn't hope to cover every aspect of what Make offers, so please don't mistakenly consider this post as anything even remotely exhaustive. Whole books have been written on the topic of Make and writing Makefiles so I'll leave it up to the reader to investigate further beyond this post if I've managed to kindle your interest.

Let me start by referencing the official website for their definition of what Make is and does:

> [GNU Make](http://www.gnu.org/software/make/) is a tool which controls the generation of executables and other non-source files of a program from the program's source files

Make relies on a `Makefile` being defined and which consists of a set of instructions for building your software. If you've used another build system, such as [GruntJS](http://gruntjs.com), you'll notice that most of them use a naming convention taken from Make (e.g. `Gruntfile`).

The point of a Makefile (in the traditional sense) is to build a program; although Make can be used to run any kind of task and so it isn't limitied to compiling software. Much like how other JavaScript based build tools aren't limited to building JavaScript applications, they can handle most tasks you wish to run (maybe compiling CSS or optimising images etc).

You'll find Make is widely distributed and is likely already on your computer. For example, I'm running a Macintosh laptop running OS X and if I run the following command:

<!--language-bash-->

    make --version

I get back the following response:

<!--language-bash-->

    GNU Make 3.81
    Copyright (C) 2006  Free Software Foundation, Inc.
    This is free software; see the source for copying conditions.
    There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A
    PARTICULAR PURPOSE.

    This program built for i386-apple-darwin11.3.0

Which means I already have the `make` command available and I can start writing my Makefile right away.

<div id="2"></div>
## Hello World Example

Let's start with the most common example (that I've found any way): compiling a C program. Now you don't have to be a C programmer to follow along (I'm not one!); I've picked this as it's the quintessential example for demonstrating how Make works. 

First, let's ensure you have a compiler available. Again, I'm on a Macintosh laptop running OS X and it comes preinstalled with the C compiler command `gcc`. You can tell if you have it installed by running the following command:

<!--language-bash-->

    gcc --version

Which for me returns the following response:

<!--language-bash-->

    Configured with: --prefix=/Applications/Xcode.app/Contents/Developer/usr --with-gxx-include-dir=/usr/include/c++/4.2.1
    Apple LLVM version 6.1.0 (clang-602.0.49) (based on LLVM 3.6.0svn)
    Target: x86_64-apple-darwin14.1.0
    Thread model: posix

Forgetting Make for a moment, let's understand how to compile a C programming file into a binary we can execute. The following code snippet demonstrates how to print some text to your screen:

<!--language-c-->

    /* hello.c: display a message on the screen */

    #include <stdio.h>

    main()
    {
        printf("hello, world\n");
    }

If we wanted to compile this into a binary, we would execute the following shell command:

<!--language-bash-->

    gcc hello.c -o hello

> Note: you might get a warning message displayed; don't worry about that as the binary should still get generated without a problem

Once the file has been compiled into a binary, I can run the following shell command:

<!--language-bash-->

    ./hello

This executes the compiled binary and subsequently prints out to my screen the text `hello, world`.

Great, so how do we take this example further and "automate" the compilation process (which will get more complicated as our application grows in size and features) using the Make utility?

First we need to create a `Makefile`. Below is the contents of the Makefile I'm going to use to demonstrate how Make works (I'll explain the structure of the file in the next section):

<!--language-makefile-->

    hello: hello.c
        gcc hello.c -o hello

> Note: if you're copying and pasting the above Makefile content then be sure to change the four spaces before the second line `gcc hellow.c -o hello` to be a single tab. Makefiles use tabs for indentation and so if you use spaces instead you'll notice things don't work - I mention this now because my blog replaces tabs with spaces as a convention; but when coding, my editor automatically picks up I'm in a Makefile and keeps the tab as a tab so it's not a problem. It's only an issue for the Makefile code samples used on my site

To run the above Makefile, we would need to use the `make` shell command. This by itself will run the first "target" it finds (this is also referred to as the "default target") which in the above example Makefile is `hello:`. You can also be more explicit and specify the exact target you want to execute by providing the name of the target to the `make` command, like so: 

<!--language-bash-->

    make hello

Executing the above command is the same as if we had run `gcc hello.c -o hello`. Using Make in this instance means it's easier to remember the Make commands over some very long an unwieldy shell commands, but also that the Makefile acts as a documented file that can now be committed into version control so we have a record of the compilation step. Both these points become even more important as the compilation/build steps become more and more complicated; which they will do as your application/software system naturally grows and evolves.

> Note: if your Makefile is in a different directory you can pass its location to the `make` command using the `-f` flag like so: `make -f <makefile>`

Make is also quite smart in that if you try to rebuild a file that has already been created then it will tell you there is nothing it needs to do. It's able to do this with the help of the target's dependencies (I'll explain what that means later on when we discuss the different parts of a make command). To see an example of this in action, run `make hello` and then do it again; the response will be something like:

<!--language-bash-->

    make: 'hello' is up to date

This demonstrates that, in this scenario at least, how Make will prevent you from needlessly processing data and running commands it doesn't need to. That's a nice performance win! Other build tools don't appear to be as intuitive in this respect and make you work hard at not shooting yourself in the foot (e.g. when you accidentally run expensive tasks that don't actually need to run). Sure you can work around it, but like I say, you have to work harder at it.

The standard idiom for writing Makefiles is to have the default command (your entry point) at the top of the file and have Make process the commands "top-down". You don't *have* to do this though (as you'll see, I've not done so in some of my examples throughout this post) and you're free to put your rules in whatever order makes sense to you. But be aware that when you call the Make command, you'll want to specify the specific target if it's not the default.

<div id="3"></div>
## Terminology

There are three key phrases you need to be aware of when talking about a Makefile:

- Rules
- Targets
- Prerequisites

The following snippet demonstrates the basic structure of a Makefile: 

<!--language-makefile-->

target: prereq1 prereq2
    commands

You can see we have a single "target" (this is what we reference when running the command `make {target}`), a set of dependencies (i.e. prerequisites) and a command to execute (e.g. `gcc hello.c -o hello`). This entire structure is collectively referred to as a "rule" and a Makefile is typically made up of multiple rules.

### Prerequisites

Prerequisites are the dependencies for the target (i.e. the target cannot be built successfully without the dependencies first being available). In the previous "hello world" example, we specified the physical file `hello.c` as a dependency; because if that file didn't exist then we couldn't compile it into a binary (although a dependency can be another "target" from within the Makefile as we'll see shortly).

We can test this by first deleting the `hello` binary already created after running `make hello` (run `rm hello` to delete it), and then by moving the `hello.c` file into a sub folder called `source-files`. Your folder structure should now look something like:

<!--language-bash-->

    .
    ├── Makefile
    ├── source-files
    │   └── hello.c

From here we can now run `make hello` again, which should respond with:

<!--language-bash-->

    make: *** No rule to make target `hello.c', needed by `hello'.  Stop.

The above error message effectively is telling us that the Makefile has indicated `hello.c` as being a dependency, but it was unable to locate that dependency in the current directory. To fix that issue we can modify the Makefile so the dependency we specify is correctly pointed (using a relative path) to the file we are relying on, like so:

<!--language-makefile-->

    hello: ./source-files/hello.c
        gcc ./source-files/hello.c -o hello

### How Make decides what to do

How and why Make decides what to do when you run `make {target}` is very important as it'll help you understand the performance implications of certain tasks. The rule of thumb for Make is pretty simple:

If the target (or any of its prerequisite files) are out of date or missing, then the commands for that target will be executed.

> Note: if you want to see what Make will execute without it actually doing anything, then run the Make command as you normally would but ensure you include the `-n` flag. This will cause Make to print out all commands that would be executed (including commands collated from any specified prerequistives)

<div id="4"></div>
## Automatic variables

This is great, in the previous example we have a working Makefile that compiles our C programming file into a working binary. Although it demonstrates how we can reference a dependency using a relative path, it also feels like we've got some duplication here? 

As good developers we like our code to be DRY (Don't Repeat Yourself), so let's clean up this rule by utilising some special variables that Make provides (also referred to as "automatic variables"). Specifically for the problem we want to solve, we'll be using the `$<` automatic variable.

When the `hello` target is run, the `$<` variable will reference the first prerequisite in the list, which will simplify the example and save you from having to repeat yourself. The following example demonstrates what this looks like:

<!--language-makefile-->

    hello: ./source-files/hello.c
        gcc $< -o hello

So this is good because we've removed a hardcoded value and made our code slighly more flexible. But what happens if we have multiple dependencies? 

Assume we have three files `foo.txt`, `bar.txt` and `baz.txt`. We can use a combination of the `$^` variable (which gives us all the dependencies/prerequisites as a list) and a small bit of standard [Bash shell](http://en.wikipedia.org/wiki/Bash_%28Unix_shell%29) code (Make commands are ultimately 'structured shell scripts' with extra syntactical sugar) to loop over the provided dependency list. 

The following example demonstrates how this could be written:

<!--language-makefile-->

    list: foo.txt bar.txt baz.txt
        for i in $^; do echo "Dependency: $$i"; done

Executing `make list` would result in the following response:

<!--language-bash-->

    for i in foo.txt bar.txt baz.txt; do echo "Dependency: $i"; done
    Dependency: foo.txt
    Dependency: bar.txt
    Dependency: baz.txt

> Note: because Makefiles have their own special syntax, the use of `$` will conflict when writing our shell script (which also has its own special syntax around `$`). This means if we want to use the dollar character and not have it be Makefile specific, then we have to escape it using another dollar. So rather than writing `$i` - which works fine within the context of a normal shell script - we've had to write `$$i` instead

We'll see a few different automatic variables throughout this post, but in the meantime checkout the below list quick reference for some of the more useful ones:

- `$<`: first prerequisite
- `$^`: list of prerequisites
- `$?`: list of prerequisites that have changed
- `$@`: target name
- `$*`: the value of a target placeholder

<div id="5"></div>
## Commands

It's worth being aware that each "command" provided inside the overall "rule", is considered a separate shell context. Meaning if you export a shell environment variable in one command, it wont be available within the next command (as once the first command has finished, a fresh shell is spawned for the next command and so on).

You'll also notice that when running Make it will print out the command instructions *before* executing them. This can be disabled in one of three ways. You can either run Make with the `-s` flag, which will "silence" any output; or you can use the `@` syntax before the command itself, like so:

<!--language-makefile-->

    list: foo.txt bar.txt baz.txt
        @for i in $^; do echo "Dependency: $$i"; done

The third way to silence output is to use the `.SILENCE` flag. The following snippet demonstrates how to silence three targets `foo`, `bar` and `baz`:

<!--language-makefile-->

    .SILENT: foo bar baz

> Note: silencing the output unfortunately also means silencing any errors!

Much like shell scripting, if you have a command that is more complicated than what can feasibly fit on a single line, then - for the sake of readability if nothing else - you'll want to write it across multiple lines and escape the line breaks using the `\` character; as the following example demonstrates:

<!--language-makefile-->

    list: foo.txt bar.txt baz.txt
        for i in $^; do \
            echo "Dependency: $$i"; \
        done

<div id="6"></div>
## Targets as Prerequisites

So far we've used physical files that already existed as our prerequisites. But what if you need to dynamically create the files first (via other targets)? Well Make allows you to specify targets as depedencies, so that's not a problem. Let's see how this works in the following example:

<!--language-makefile-->

    foo:
        @echo foo > foo-file.txt

    bar:
        @echo bar > bar-file.txt

    baz: foo bar
        @echo baz | cat - foo-file.txt bar-file.txt > baz-file.txt

What we have are three targets `foo`, `bar` and `baz`. The first two have no dependencies of their own and all they do is generate a new txt file. The last target `baz` specifies the other two targets as its dependencies. So when we run `make baz` we should see no output (as we've used the special `@` syntax to silence any output) but we should find we have the following files created:

- `foo-file.txt`
- `bar-file.txt`
- `baz-file.txt`

The last file in the list should contain not only a line that displays `baz` but also two other lines comprised of the contents of the other files. So running `cat baz-file.txt` should print:

<!--language-bash-->

    baz
    foo
    bar

> Note: if you've not seen it used before, the `-` in the `cat` command is telling it to expect input from stdin (the `echo` command writes to stdout and that is piped `|` over to the `cat` command as stdin)

<div id="7"></div>
## Accessing targets

In the above example, I was generating a file based upon the contents of two other targets (which themselves dynamically generated some files). There was a slight bit of repetition that could have been cleaned up if we used another automatic variable provided by Make; specifically `$@`. 

The `$@` variable is a reference to the target name, so let's see how we can use this with our previous example:

<!--language-makefile-->

    foo:
        @echo $@ > "$@-file.txt"

    bar:
        @echo $@ > "$@-file.txt"

    baz: foo bar
        @echo $@ | cat - foo-file.txt bar-file.txt > "$@-file.txt"

In the above example we've saved ourselves from typing `foo`, `bar` and `baz` a few times but we've not eradicated it completely as we still have to reference `foo` and `bar` as prerequisites; as well as referencing them from within the `baz` command itself.

With regards to the `baz` command, we could use `$^` along with some shell scripting to clean that up so we're again not relying on hardcoded values. The following example shows how to achieve that:

<!--language-makefile-->

    foo:
        @echo $@ > "$@-file.txt"

    bar:
        @echo $@ > "$@-file.txt"

    baz: foo bar
        @files=$$(echo $^ | sed -E 's/([a-z]+)/\1-file.txt/g'); echo $@ | cat - $$files > "$@-file.txt"

Oh boy, OK. So yes we've removed some more hardcoded values, but unless you're supremely confident with shell scripting then I'm guessing the above refactor wont make much sense to you.

Effectively we're using `$^` to get the list of dependencies (in this case `foo bar`), and we're piping that over to the `sed` command (using extended regular expressions `-E` to make things easier) and subsequently replacing `foo bar` with `foo-file.txt bar-file.txt`. We do all of that within a sub process `$()` which is special syntax for the shell and so we have to escape the dollar sign within the Makefile, which turns it into `$$()`. The values returned from the sub process (i.e. `foo-file.txt bar-file.txt`) are then stored in a variable called `files` and we reference that variable in place of the original hardcoded values. Did you get all that?

On top of that, we *still* have duplication - i.e. the `foo` and `bar` referenced within the prerequisites area - that has to be hardcoded unless we're going to use Make or some other form of shell scripting to dynamically generate the actual `Makefile` itself; which for even me is a step too far in this case.

What does this ultimately tell us? That sometimes the effort to DRY out your code isn't always worth it. Simplicity is the key. The reason I went to all this trouble is because it allowed me to demonstrate how to really stretch what Make can do for you if you have enough shell scripting knowledge.

<div id="8"></div>
## Parsing targets and prerequisites

There are many different automatic variables available for Make and we'll see a few more of them as we go along. But as we've already discussed `$@` and `$<`, it's worth noting that you are also able to parse out the specific directory and filename details for both the first dependency as well as the target, by using the syntax `$(<D)`/`$(<F)` for the prerequisite and `$(@D)`/`$(@F)` for the target. 

Using the following snippet as an example (you would run it with `make foo/bar/baz.txt`):

<!--language-makefile-->

    bing/bop.txt:
        @# do nothing

    foo/bar/baz.txt: bing/bop.txt
        @echo $(@D)
        @echo $(@F)
        @echo -------
        @echo $(<D)
        @echo $(<F)

The above example would output first the directory structure and then the file name which has been parsed from the target, and after that the directory structure and file name parsed from the prerequisite:

<!--language-bash-->

    foo/bar
    baz.txt
    -------
    bing
    bop.txt

Depending on your requirements this can be quite a powerful tool to help you construct more complex commands.

> Note: if you're interested in knowing where your `make` binary is located then you can use the built-in `MAKE` special variable in your command: `@echo $(MAKE)`

<div id="9"></div>
## Dynamic targets

Targets can dynamically match mulitiple unknown values and allow for abstracting away common functionality, such as generating files that have similar names (to give an overly simplified example).

To do this we need to take advantage of the placeholder syntax `%` (and its corresponding `$*` syntax). The following example demonstrates the basic structure:

<!--language-bash-->

    dynamic-%:
        @echo "Placeholder value: $* and target value: $@"

If you run the target using `make dynamic-foo` then you'll get the following response (notice that the dynamic aspect of the command `foo` is captured in the placeholder):

<!--language-bash-->

    Placeholder value: foo and target value: dynamic-foo

<div id="10"></div>
## Dereferencing (Variables and Macros)

Make provides the multi-purpose utility `$()`, which is used to dereference values. The values can be functions (of which Make has many built-in functions and we'll take a quick glance at some of them later on). Let's consider a simple example where we deference a variable that is defined outside of the rule:

<!--language-makefile-->

    some_var := abc

    print_var:
        @echo $(some_var)

Notice in the above example we defined the variable using the `:=` syntax (where as with most languages you would assign a value to a variable using `=`). Make also supports `=` as an alternative assignment operator but its use is specifically for situations where you want/need to take advantage of recursive dereferencing. Let's see what that means in practice by reviewing the following example:  

<!--language-makefile-->

    foo = $(bar)
    bar = $(baz)
    baz = qux value here

    recursive:
        @echo $(foo)

The above example returns `qux value here` and demonstrates how the `foo` variable recursively evaluated all other values thanks to the use of the `=` operator. 

If we tried this using `foo := $(bar)` instead then the `recursive` target would have printed out an empty line instead as it uses a straight forward "simple expansion" algorithm which means its right hand side value is expanded immediately (i.e. expanded at declaration time). With this example, Make doesn't recursively expand the values back to `bar` and subsequently back to `baz` to find the final value of `qux value here`. 

There are also other types of assigment you can use, such as "conditional variable" `?=`. What that will do is assign a value to the defined variable only if it doesn't already have a value defined. For example:

<!--language-makefile-->

    assignment = foo
    assignment ?= bar

    conditional_assignment:
        @echo $(assignment)

If we run `make conditional_assignment`, then we'll see the value `foo` printed. The value `bar` isn't assigned as a value was already defined.

One other assignment type worth considering is `+=`, which works pretty much as you would expect it to if you're a programmer (as it's an operator that appears in many different languages). Effectively it appends the value onto the variable, keeping the original value as well. For example:

<!--language-makefile-->

    hello_world = hello
    hello_world += world

    say_hello:
        @echo $(hello_world)

The above example prints `hello world`, as it has appended `world` onto the existing value `hello`. Interestingly Make automatically puts in a space as well between the values assigned (notice the value printed wasn't `helloworld`).

One last thing I want to cover is the use of Macros in Make. A Macro is a collection of commands that are expanded and excuted when dereferenced. It's a lot like a function, in that it groups behaviour. The following example demonstrates how it works:

<!--language-makefile-->

    define do_lots_of_things
      echo Hi there
      echo I do lots of things
      echo So it\'s best I do this in this Macro
    endef

    stuff:
        @$(do_lots_of_things)

When we execute `make stuff` we see all the different messages printed to the screen. We can reuse this Macro in many different target rules if we wanted as well (which is really the whole point of them).

> Note: notice that I had to escape the use of the single quote `'`. This was done because without it the command would fail due to a syntax error in Make

<div id="11"></div>
## Functions

As mentioned in the previous section, we stated that the `$()` utility worked to dereference a value, but also it could handle a number of built-in functions. Although some of the functions could be replaced with standard shell commands.

> Note: for a full list, please visit https://www.gnu.org/software/make/manual/html_node/Functions.html

### Filter

So let's take a look at some interesting functions Make provides. The first one I like the look of is `filter`:

<!--language-makefile-->

    filter: foo.txt bar.txt baz.txt
        @echo $(filter ba%.txt, $^)

In the above rule we use the `filter` function which takes as its first argument the pattern you want to try to match and the text you want to search within. So in our example the text to be searched is the list of prerequisites (using `$^` which we've already seen). The pattern we're hoping to match uses the `%` placeholder wildcard value and it is saying: "return only files that begin with `ba` and end in `.txt`". This results in `bar.txt baz.txt` that is printed.

### Shell

Outside of a target you can have a variable dynamically pull data from the shell environment by using the `v := $(shell <command>)` pattern. 

> Note: ecause we're using the `shell` function, we use `:=` for simple expansion over `=` which would allow for recursive dereferencing and could cause problems depending on what your Makefile and shell script is doing

In the following example we use the `shell` function to calculate the result of adding 1 and 1 together. We then deference that value from within our target:

<!--language-makefile-->

    calculation := $(shell echo $$((1 + 1)))
    shelled_value:
        @echo $(calculation)

> Note: in the shell, to do arithmetic (and other such things) we need to use the expression utility `$((...))` so don't make the mistake of thinking it's a syntax special to Make, because it's not

### Eval

In the following snippet we are using the `eval` function to create a Makefile variable dynamically at runtime:

<!--language-makefile-->

    dyn_eval:
        $(eval FOOBAR:=$(shell echo 123))
        @echo $(FOOBAR)

We use the previously seen `shell` function to return a dynamically generated value (in this case `123`) and we assign that to a variable FOOBAR. But to allow us to access FOOBAR from other commands within this target, as well as other unrelated targets, we use `eval` to create the variable globally. Finally, we use `$()` to dereference the variable.

### Files

The following technique allows us to carry out simple substitutions, by swapping the matched text before the `=` with the text that follows it. The defined pattern is then applied to the variable being dereferenced:

<!--language-makefile-->

    files = foo.txt bar.txt baz.txt
    change_ext:
        @echo $(files:.txt=.doc)

There are many functions and techniques to help you extend the capabilities within Make and so I would highly recommend you have a read through the functions listed in the GNU Make manual linked to above.

### User defined functions

You've already seen the use of macros via the syntax `define`. User defined functions work exactly the same way but you call them differently to macros (you'll use the Make built-in `call` function), and this is so that you can pass arguments to the definition. This is best demonstrated with an example:

<!--language-makefile-->

    define foo
      @echo "I was called with the argument:$1"
    endef

    call_foo:
        $(call foo, "hello!")

The above example would be executed like so `make call_foo` and would result in the following output:

<!--language-bash-->

    I was called with the argument: hello!

> Note: earlier we noticed that Make would include a space when using the `+=` operator. The same happens with function arguments and so when creating the string that is printed I didn't include a space after the `:` but the output shows a space thanks to Make

You can pass as many arguments as you like to a function and it'll be accessible numerically (e.g. `$1`, `$2`, `$3` and so on). You can also call other functions from within a function and pass on the arguments, or pass different arguments using the `$(call function_name)` syntax.

<div id="12"></div>
## Conventions

There are some well known conventions and idioms used by the Make community, and a few of the most prominent ones are detailed in this section.

The first is the inclusion of a `clean` target which should be used to remove any files created by your Makefile. This is to allow the user to clean up after your tasks have executed (or if things have gone haywire). Typically the default target will'll specify `clean` as a prerequisite so as to clear your workspace before starting a fresh build.

The second is to have a `help` target which `echo`'s each of the targets within the file and explains its purpose. As demonstrated below:

<!--language-makefile-->

    help:
        @echo foo: does foo stuff
        @echo bar: does bar stuff
        @echo baz: does baz stuff

> Note: you could use some clever shell scripting along with Makefile comments to dynamically generate the printed commands and their descriptions (e.g. read in the Makefile source and parse out the meta data/comments as part of a sub shell `$(shell ...)`)

The third is to include a reference to a "special target" called `.PHONY` at either the top or bottom of your Makefile followed by a list of target names. The purpose of `.PHONY` is to prevent conflicts with files within your current project directory that coincidentally match the name of your Makefile targets. 

To clarify what this means in practical terms: Make has a convention where by you would define a target's name as matching the name of the file the commands will ultimately create (because although Make is useful for general purpose tasks; it was originally designed for creating application files). Make will associate a target with any file that matches its name and will intelligently monitor the dependencies for the target to see if it's OK to re-execute the target's command to regenerate the file.

Typically a target such as `clean` wont have any dependencies (not all the time mind you, but most of the time it wont because the purpose of `clean` is to remove generated files; it shouldn't depend on any other files in order to complete that action). If a target has no dependencies then Make will always run the associated commands (remember, Make can intelligently avoid running certain commands if it knows the dependencies haven't changed at all). 

By specifying `clean` as being a "phony" target, it means if there was ever a file called `clean` added to your project then we could avoid confusion occuring as to how Make should handle running the target. The following demonstrates how it is used (it assumes you have a file - with no file extension - called `clean` in your main project directory):

<!--language-makefile-->

    .PHONY: clean

    clean:
        @echo "I'll do something like remove all files"

In the above example running `make clean` will display the message "I'll do something like remove all files". But if you remove the `.PHONY: clean` and re-run the target (using `make clean`) you'll now find because we have a `clean` file in our main project directory - and no dependencies for that target - that Make will mistakenly think there is nothing left to do and so it displays the message:

<!--language-bash-->

    make: `clean' is up to date.

> Note: like with automatic variables, there are many different special targets (so far we've seen `.PHONY` and `.SILENT`. One that's worth further investigation is `.DELETE_ON_ERROR` which indicates to Make that if any of the commands for your target rule fails then delete the associated target file in your project. See https://www.gnu.org/software/make/manual/html_node/Special-Targets.html for a full list

<div id="13"></div>
## Includes

Make allows you to import more Make specific functionality via its `include` statement. If you create a file with a `.mk` extension then that file's Make related code can be included into your running Makefile. The following example demonstrates how it works:

<!--language-makefile-->

    include foo.mk # assuming you have a `foo.mk` file in your project directory

    included_stuff:
        @echo $(my_included_foo)

The above example relies on a `foo.mk` file containing the following Make contents:

<!--language-makefile-->

    my_included_foo := hi from the foo include

So when we run `make included_stuff` we see `hi from the foo include` printed out.

> Note: the `include` statement can also be written with a hyphen prefix like so `-include`, which means if there is an error loading the specified file then that error is ignored

<div id="14"></div>
## Conclusion

OK, so we've barely even scratched the surface of what's possible using Make, but hopefully this introduction has peaked your interest in learning more by either reading the GNU Make manual or picking up a book on the subject. I myself am only beginning this journey of using Make as way to replace existing build tools I've been using. 

It's been part of my journey to rediscover origin Unix tools that have stood the test of time (for good reason) rather than picking up the new shiny thing which is nothing more than a slightly modernised abstraction that's been built for people who want to avoid the terminal/shell environment (somewhere I have become much more comfortable working the past couple of years).
