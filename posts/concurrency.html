<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, minimal-ui">
        <title>Thread Safe Concurrency</title>
        <link rel="stylesheet" href="../styles/github-markdown.css">
        <link rel="stylesheet" href="../styles/prism-twilight.css">
        <style>
            body {
                min-width: 200px;
                max-width: 790px;
                margin: 0 auto;
                padding: 30px;
            }
        </style>
    </head>
    <body>
        <article class="markdown-body">

<h1>Thread Safe Concurrency</h1>

<ul>
<li><a href="#1">Introduction</a>

<ul>
<li><a href="#2">Shared Memory</a></li>
<li><a href="#3">Message Passing</a></li>
</ul></li>
<li><a href="#4">Various options</a></li>
<li><a href="#5">Mutexes/Semaphores</a>

<ul>
<li><a href="#5-1">Atomic operations</a></li>
</ul></li>
<li><a href="#6">STM</a>

<ul>
<li><a href="#6-1">Clojure example</a></li>
<li><a href="#6-1-1">Quick Clojure Concurrency Detour</a></li>
<li><a href="#6-2">JRuby example</a></li>
</ul></li>
<li><a href="#7">Actors</a>

<ul>
<li><a href="#7-1">Transactions and Actors?</a></li>
<li><a href="#7-2">Actors in Clojure</a></li>
<li><a href="#7-3">Differences between Agents and Erlang Actors</a></li>
<li><a href="#7-4">Limitations</a></li>
</ul></li>
<li><a href="#8">CSP</a></li>
<li><a href="#9">Threads</a>

<ul>
<li><a href="#9-1">CPU vs I/O</a></li>
<li><a href="#9-2">Calculating the number of Threads</a></li>
<li><a href="#9-3">Even workload distribution</a></li>
</ul></li>
<li><a href="#10">Conclusion</a></li>
</ul>

<div id="1"></div>

<h2>Introduction</h2>

<p>Concurrency is a difficult concept. Regardless of programming language or idiom that you use, the practice of programming a &quot;thread-safe&quot; application can be harder than you think.</p>

<p>There are two fundamental models of concurrency:</p>

<ol>
<li>Shared Memory</li>
<li>Message Passing</li>
</ol>

<p>In the first, we have concepts such as Threads, Locks and Mutexes. In the latter we have patterns such as Actors and CSP, which rely on the mantra of...</p>

<blockquote>
<p>&quot;don&#39;t communicate by sharing memory; share memory by communicating&quot;</p>
</blockquote>

<div id="2"></div>

<h3>Shared Memory</h3>

<p>The following diagram is an extremely simplistic view of how CPUs, Processes and Threads interact but should help us to better understand why code can become <strong>NON</strong> thread-safe (as far as the &quot;Shared Memory&quot; model is concerned; we&#39;ll see shortly that the &quot;message passing&quot; model side steps this issue):</p>

<p><a href="../images/cpu-processes-and-threads.png">
    <img src="../images/cpu-processes-and-threads.png">
</a></p>

<p>...for those of you who cannot see the image, effectively a process can spawn multiple threads and each thread belonging to a specific process shares the memory related to the process.</p>

<p>Meaning if your software process creates two threads, then both threads have access to the same memory space and thus can manipulate the same chunk of memory (and by memory, I&#39;m specifically referring to data the application creates/has access to).</p>

<p>This means, if your software creates some mutable data (e.g. in Ruby this could look something like <code>foo = &quot;bar&quot;</code> - a <code>foo</code> variable that holds the String value <code>bar</code>) and you want to modify the value of the variable, then multiple threads could manipulate the value in an unexpected order and subsequently cause a difficult to locate bug.</p>

<p>Any time you create a new Thread and within that Thread you modify a mutable piece of data you should be concerned about how &quot;thread-safe&quot; that data is.</p>

<blockquote>
<p>Note: if you&#39;re also utilising immutable data structures (as found in more functional languages, but also languages such as Go where they &quot;pass by value&quot; rather than &quot;pass by reference&quot;) then this also makes code less prone to thread-safety concerns (but that&#39;s a discussion for another day)</p>
</blockquote>

<div id="3"></div>

<h3>Message Passing</h3>

<p>The message passing model relies on no data being shared, but rather communication between processes happening via either a message bus or by piping messages down a channel (depending on which style is implemented in your programming language of choice).</p>

<p>As well as avoiding the issue of data being shared, it also avoids the issue of trying to recover from failures (which thread/process is the correct one); which is a hard problem to reason about.</p>

<div id="4"></div>

<h2>Various options</h2>

<p>There are four main types of solutions to the problem of thread-safe concurrency:</p>

<ol>
<li>Mutexes/Semaphores</li>
<li>Software Transactional Memory (STM)</li>
<li>The &quot;Actors&quot; pattern</li>
<li>Communicating Sequential Processes (CSP)</li>
</ol>

<p>Let&#39;s investigate each of these in turn:</p>

<div id="5"></div>

<h2>Mutexes/Semaphores</h2>

<p>We&#39;ll be discussing specifically &quot;mutexes&quot; rather than &quot;semaphores&quot; (they have very similar purposes - in that they control access to specific data - although a mutex offers some additional guarantees which we won&#39;t go into here).</p>

<p>When using a mutex, you can &quot;lock&quot; a piece of data so only that specific Thread has access to the data. When done manipulating the data you can &quot;unlock&quot; it, thus allowing another Thread to use a mutex to &quot;lock&quot; the data so it can make its own changes.</p>

<p>Let&#39;s take a look at an example (in Ruby):</p>

<pre><code class="language-ruby"># imagine `data` is some shared state

def update
  mutex = Mutex.new

  Thread.new { mutex.synchronize { data += 1} }.join
end
</code></pre>

<blockquote>
<p>Note: for the full Mutex API see <a href="http://www.ruby-doc.org/core-2.1.5/Mutex.html">http://www.ruby-doc.org/core-2.1.5/Mutex.html</a></p>
</blockquote>

<p>This particular solution is the simplest of the three. BUT it doesn&#39;t take into account any logic for handling unexpected changes to data (we&#39;ll see what that means in the next section).</p>

<div id="5-1"></div>

<h3>Atomic operations</h3>

<p>Locks and mutexes allow operations to become <em>atomic</em>, meaning that the change happens &quot;as a whole&quot;. Meaning it becomes thread safe because another thread can&#39;t accidentally read a piece of data/state/memory that is half done (e.g. <code>+=</code> in the above Ruby example would not be thread safe without the Mutex because a thread could read the value of <code>data</code> inbetween the read and the assignment that <code>+=</code> carries out).</p>

<div id="6"></div>

<h2>STM</h2>

<p>Software Transactional Memory is known as being an &quot;optimistic&quot; process. Compare this to the lock-synchronisation mechanism of a Mutex, which implies the onus of whether a write action will succeed, should be on the &quot;writer&quot; (i.e. the &quot;writer&quot; locks the data, writes the data, then releases the lock). </p>

<p>The STM on the other hand doesn&#39;t care what happens in another Thread, it instead records all the changes in a log file and then just before it confirms the write (referred to as a &quot;commit&quot; in STM terminology) it verifies the data we&#39;re modifying hasn&#39;t changed, and if it hasn&#39;t we go ahead and commit the change made by our Thread.</p>

<p>If a change has been made to the shared data source, then the transation will start over; but this time using the latest copy of the data we&#39;re modifying (this can in some cases cause a deadlock to occur).</p>

<p>Because the STM retries transactions when they fail, we should ensure that code within a transaction is idempotent and side effect free. Otherwise if the code isn&#39;t idempotent, then that code will be run again and might mean data is changed or recorded in ways you didn&#39;t expect (e.g. a call to log some data within a transaction could be called multiple times!)</p>

<blockquote>
<p>Note: the STM is best used for applications that have frequent reads and can allow for low to medium write collisions. If you expect lots of write collisions then it may be best to opt for another pattern, such as the <a href="#7">Actors</a> pattern discussed in the following section.</p>
</blockquote>

<p>In the Clojure programming language you&#39;ll also find that the STM facilitates &quot;embedded transactions&quot;, which allows for greater atomicity. What this means in pratice, is that if there is a transaction that contains a sub-transaction, then in some implementations of the STM a failed transaction won&#39;t necessarily cause the sub-transaction to fail. But in Clojure it will. Meaning that it&#39;s definitely an atomic operation (all or nothing).</p>

<div id="6-1"></div>

<h3>Clojure example</h3>

<p>The following example uses the Clojure programming language to implement a thead-safe modification via the STM (specifically the <code>ensure</code> function allows us to tell the STM what shared memory to watch for changes while our transaction is ongoing). </p>

<hr>

<div id="6-1-1"></div>

<h4>Quick Clojure Concurrency Detour</h4>

<p>A quick detour before continuing onto the example code... </p>

<p>Clojure provides quite a few different mechanisms and functions for handling concurrency.</p>

<p>The three core mechanisms are:</p>

<ul>
<li><code>atom</code></li>
<li><code>agent</code></li>
<li><code>ref</code></li>
</ul>

<p>A <code>ref</code> provides synchronised access to shared mutable state in a <em>coordinated</em> fashion (i.e. it uses the STM to ensure multiple references are coordinated before applying changes). Where as an <code>atom</code> is similiar, but differs in that it works like a straight forward CAS (compare and swap) operation. So an <code>atom</code> is considered <em>un-coordinated</em>. An <code>agent</code> is the same as an <code>atom</code> with the exception that it can be run asynchronously.</p>

<p>Clojure&#39;s atom provides a validator function (pass <code>:validator</code> argument followed by a validating function), which prevents invalid values being set; similar to a function&#39;s pre/post assertion conditions. You are also able to &quot;watch&quot; atoms for state changes via <code>add-watch</code>.</p>

<blockquote>
<p>Note: there is also <code>Var</code> type which is a mutable variable and is created via the <code>def</code> form. A variable is &quot;thread-local&quot; meaning it isn&#39;t shared across threads (where as <code>atom</code>, <code>agent</code> and <code>ref</code> are all accessible across threads)</p>
</blockquote>

<p>Now let&#39;s consider the following functions:</p>

<ul>
<li><code>ref-set</code></li>
<li><code>alter</code></li>
<li><code>ensure</code></li>
<li><code>commute</code></li>
</ul>

<p>All of these functions <em>must</em> be called from within a transaction (e.g. this is achieved by calling them from within a <code>dosync</code> block).</p>

<p>The first function <code>ref-set</code> allows you to change the value of a reference directly (i.e. specifying a value rather than using a function).</p>

<p>The second function <code>alter</code> applies a user specified function to the reference. The transaction itself will be retried if any reference written to within the transaction has changed outside of that transaction.</p>

<p>The third function <code>ensure</code> helps to resolve a problem that arises when using <code>alter</code>. The <code>alter</code> function only retries the transaction when references are written to; this means it doesn&#39;t check references that are used within the transaction and <em>haven&#39;t</em> been written to. We can work around this issue and ensure (no pun intended) that any reference used within the transaction - written to or just read - would cause the transaction to restart.</p>

<p>The fourth function <code>commute</code> increases concurrency for references that you want to monitor for changes but don&#39;t really care for their consistency; when you&#39;re really only interested in getting the latest value. It helps to increase the concurrency by running the function applied to <code>commute</code> at least twice (maybe more). This means if you have multiple threads running transactions then whichever transaction changes the value at the point of a commit wins (i.e. last-one-in-wins behavior).</p>

<p>OK, with that out of the way let&#39;s now review the example code...</p>

<hr>

<p>The requirement in the code is that the two bank accounts must have at least 1000 in total between them. If we try to remove an amount from either account which results in the total amount falling below 1000 then we should not complete that transaction:</p>

<pre><code class="language-scheme">(def current-account (ref 500))
(def savings-account (ref 600))

(defn withdraw [from constraint amount]
  (dosync
    (let [total (+ @from (ensure constraint))]
      (Thread/sleep 1000) ; allows for a more visible context switch
      (if (&gt;= (- total amount) 1000)
        (alter from - amount)
        (println &quot;Sorry, can&#39;t withdraw due to constraint violation&quot;)))))

(println &quot;STATE BEFORE MODIFYING&quot;)
(println &quot;Current Account balance is&quot; @current-account)
(println &quot;Savings Account balance is&quot; @savings-account)
(println &quot;Total balance is&quot; (+ @current-account @savings-account))

(future (withdraw current-account savings-account 100))
(future (withdraw savings-account current-account 100))

(Thread/sleep 4000)

(println &quot;STATE AFTER MODIFYING&quot;)
(println &quot;Current Account balance is&quot; @current-account)
(println &quot;Savings Account balance is&quot; @savings-account)
(println &quot;Total balance is&quot; (+ @current-account @savings-account))
</code></pre>

<p>The output of the above code could look like the following (but refer to the below note which explains why in some instances, because the transaction can fail and automatically retry, you could possibly see the failure message informing the user that the transaction failed even when it was successful):</p>

<pre><code class="language-bash">STATE BEFORE MODIFYING
Current Account balance is 500
Savings Account balance is 600
Total balance is 1100

STATE AFTER MODIFYING
Current Account balance is 500
Savings Account balance is 500
Total balance is 1000
</code></pre>

<blockquote>
<p>Note: <code>println</code> is sending data to <em>stdout</em> (defined as a thread-local dynamic variable). This variable is binded to the current Thread by default (meaning values don&#39;t cross over into other Threads).  </p>

<p>A <code>future</code> creates a new Thread, but the binding of <em>stdout</em> is inherited by the <code>future</code>&#39;s parent process (i.e. any <code>println</code> calls within the <code>withdraw</code> function - which runs in the parent process - can appear in the <code>future</code>&#39;s thread); meaning the output sent by <code>println</code> doesn&#39;t necessarily reflect the correct state.</p>

<p>For example, even when the transaction completes successfully, you might see the failure message printed - at some point in <em>stdout</em> - because the failing message is coming from an earlier transaction that indeed failed. But after a retry the transaction passed and so the message you see in <em>stdout</em> doesn&#39;t reflect the latest status of the application.</p>

<p>I would suggest that the <code>println</code> message be moved outside of the transaction and that you add additional logic after the transaction code (this means after the transaction has completed; inc. retries) as a way to work around this issue with printing messages to <em>stdout</em> prematurely after a failed transaction. </p>

<p>I didn&#39;t bother implementing this within my example, as it wasn&#39;t essential to understanding the code.</p>
</blockquote>

<div id="6-2"></div>

<h3>JRuby example</h3>

<p>If Clojure is a bit too much of a head spin (Lisp based languages can be quite confusing if you&#39;re new to the syntax/concepts) then let&#39;s see a similar example written in JRuby.</p>

<blockquote>
<p>Note: because JRuby runs on the JVM, like Clojure, we take advantage of that fact and import Clojure&#39;s STM functionality for us to utilise within our Ruby code</p>
</blockquote>

<p>In the following example we have downloaded the Clojure runtime as a jar (from <a href="http://clojure.org/downloads">http://clojure.org/downloads</a>) and are adding its location to the Java <code>$CLASSPATH</code> environment variable so when we try to <code>java_import</code> the relevant libraries, Java will be able to locate them.</p>

<p>Within our code you&#39;ll see we&#39;re using methods that correlate to what would be recognisable to Clojure&#39;s environment: <code>LockingTransaction.run_in_transaction</code>, <code>@balance.set</code> and <code>@balance.deref</code>.</p>

<pre><code class="language-ruby">$CLASSPATH &lt;&lt; &quot;clojure-1.6.0/clojure-1.6.0.jar&quot;

require &quot;java&quot;
java_import &quot;clojure.lang.Ref&quot;
java_import &quot;clojure.lang.LockingTransaction&quot;

class Account
  attr_reader :name

  def initialize(name, initial_balance)
    @name    = name
    @balance = Ref.new initial_balance
  end

  def balance
    @balance.deref
  end

  def deposit(amount)
    LockingTransaction.run_in_transaction do
      if amount &gt; 0
        @balance.set @balance.deref + amount
        p &quot;Deposited $#{amount} into account #{@name}&quot;
      else
        raise &quot;The amount must be greater than zero&quot;
      end
    end
  end

  def withdraw(amount)
    LockingTransaction.run_in_transaction do
      if amount &gt; 0 &amp;&amp; @balance.deref &gt;= amount
        @balance.set @balance.deref - amount
      else
        raise &quot;Can&#39;t withdraw $#{amount}; balance is $#{@balance.deref}&quot;
      end
    end
  end
end

def transfer(from, to, amount)
  LockingTransaction.run_in_transaction do
    to.deposit amount
    from.withdraw amount
  end
end

def transfer_and_print(from, to, amount)
  begin
    transfer from, to, amount
  rescue StandardError =&gt; e
    p &quot;Transfer failed: #{e}&quot;
  end

  p &quot;Balance of &#39;from&#39; account (#{from.name}) is $#{from.balance}&quot;
  p &quot;Balance of &#39;to&#39; account (#{to.name}) is $#{to.balance}&quot;
end

account1 = Account.new 1, 2000
account2 = Account.new 2, 100

p &quot;account1 balance is $#{account1.balance}&quot;
p &quot;account2 balance is $#{account2.balance}&quot;
p &quot;---&quot;

transfer_and_print account1, account2, 500
p &quot;---&quot;
transfer_and_print account1, account2, 5000
</code></pre>

<p>The output of the above program is as follows&hellip; (notice that we see the deposit succeeds, but the transaction as a whole fails - i.e. the deposit is revoked - as we can&#39;t withdraw the requested amount)</p>

<pre><code class=" language-bash ">&quot;account1 balance is $2000&quot;
&quot;account2 balance is $100&quot;
&quot;---&quot;
&quot;Deposited $500 into account 2&quot;
&quot;Balance of &#39;from&#39; account (1) is $1500&quot;
&quot;Balance of &#39;to&#39; account (2) is $600&quot;
&quot;---&quot;
&quot;Deposited $5000 into account 2&quot;
&quot;Transfer failed: Can&#39;t withdraw $5000; balance is $1500&quot;
&quot;Balance of &#39;from&#39; account (1) is $1500&quot;
&quot;Balance of &#39;to&#39; account (2) is $600&quot;
</code></pre>

<div id="7"></div>

<h2>Actors</h2>

<p>The basic premise of the Actors pattern is built upon it being a form of &quot;message bus&quot;. The philosophy of the pattern is that <em>everything is an Actor</em>. An Actor receives messages and based on its state can determine whether it wants to handle the task defined in the message it has received, or to delegate the task off to other subordinates. An Actor can also create more Actors dynamically.</p>

<p>Each Actor is typically run in their own thread (using a Thread Pool implementation to allow for better resource management/allocation). This also helps to facilitate &quot;isolated mutability&quot;; i.e. mutable state is contained within the Actor but only that actor can modify the state (and as the Actor sits inside it&#39;s own thread its mutable state is safe from other Actors).</p>

<blockquote>
<p>Note: be very careful using the Actor pattern with languages that do not have native support for immutable data structures as you could open yourself up to hard to debug problems if your language allows mutability (e.g. Clojure supports immutability, but Ruby does not; Ruby does allow you to <code>freeze</code> an object, but that doesn&#39;t include any nested structures). Much like how we&#39;ve utilised Clojure&#39;s STM in the above JRuby example, you can also import its immutable data structures. Although this won&#39;t help you if you&#39;re forced to use a non-JVM language such as MRI (which is the main Ruby interpreter written in C).</p>
</blockquote>

<p>The use of messages allows communication to become asynchronous and loosely coupled from the rest of the system. But this can result in non-sequential message order (unless you have an Actor whose role is to ensure ordering via some form of Queue).</p>

<p>The Actor pattern has been made popular via Erlang and Scala (in the form of the <a href="http://akka.io/">Akka</a> framework)</p>

<blockquote>
<p>Note: Akka has bindings for other JVM based languages (Clojure, JRuby, Groovy): <a href="http://doc.akka.io/docs/akka/2.3.4/additional/language-bindings.html">http://doc.akka.io/docs/akka/2.3.4/additional/language-bindings.html</a></p>
</blockquote>

<p>I&#39;ve yet to get around to writing any Scala code and so because Scala is the defacto example of the Akka framework I&#39;ve decided to borrow an example from the official Akka site:</p>

<pre><code class="language-scala">case class Greeting(who: String)

class GreetingActor extends Actor with ActorLogging {
  def receive = {
    case Greeting(who) â‡’ log.info(&quot;Hello &quot; + who)
  }
}

val system = ActorSystem(&quot;MySystem&quot;)
val greeter = system.actorOf(Props[GreetingActor], name = &quot;greeter&quot;)
greeter ! Greeting(&quot;Charlie Parker&quot;)
</code></pre>

<div id="7-1"></div>

<h3>Transactions and Actors?</h3>

<p>Actors can also coordinate more safely by combining themselves via STM transactions. These are typically referred to as &quot;transactors&quot;. The benefits of wrapping messages within a transaction is that we eliminate synchronisation concerns (i.e. as changes within a transaction are purposely <em>atomic</em>).</p>

<blockquote>
<p>Note: in Clojure, when sending an action to an agent from inside a transaction, the call is still non-blocking and yet it also still abides by the STM rules (i.e. the action is <em>held</em> until the transaction commits)</p>
</blockquote>

<div id="7-2"></div>

<h3>Actors in Clojure</h3>

<p>Clojure does not support Actors, although it does have a mechanism known as &quot;<a href="http://clojure.org/agents">agents</a>&quot;. An agent provides access to shared mutable state, but does so asynchronously (much like an Actor). Where an Actor receives a &quot;message&quot;, an agent accepts an <code>action</code>.</p>

<blockquote>
<p>Note: Actors and Agents have some surface similarities, but ultimately are different beasts. Actors &quot;encapsulates&quot; state and provides no means to access it from the outside. Where as Agents contain a single value that can be retrieved and manipulated (via <code>send</code> or <code>send-off</code> - see below for details). Actors also encapsulate behaviour, where as an Agent is provided the function that affects its value. Actors can be distributed, where as Agents cannot</p>
</blockquote>

<p>Where as the STM provides coordinated access to data (i.e. atomic - it verifies that there are no changes to shared data that has been written to; otherwise it&#39;ll cause the entire transaction to fail). Agents are independent; meaning that actions run concurrently (the call to <code>action</code> returns immediately), but the actions are executed sequentially via a separate thread. So where a transaction is a synchronous operation, an action handled by an agent is <em>asynchronous</em>.</p>

<p>In Clojure, agents are transaction aware (where as atoms are not) and the <code>!</code> at end of function name is an indicator of this: <code>swap!</code> (not coordinated) vs <code>send</code>.</p>

<blockquote>
<p>Note: the agent API in Clojure provides two methods: <code>send-off</code> and <code>send</code>. The former creates a new thread specifically for that agent; where as the latter selects a thread from a pre-defined thread pool. The problem with <code>send</code> is that agents fight for an available thread and so if your action does blocking I/O then you&#39;ll delay other agents from working (and thus reducing the extra concurrency benefits of using a thread pool)</p>
</blockquote>

<p>Once the agent&#39;s state is changed, the next action is applied to the agent (now using the latest state it points to).</p>

<div id="7-3"></div>

<h3>Differences between Agents and Erlang Actors</h3>

<p>There is one distinctive difference between Erlang&#39;s Actor and Clojure&#39;s Agent, which is that an Agents &quot;action&quot; doesn&#39;t block additional value request calls like an Erlang &quot;message&quot;. This is demonstrated in the following image, but in summary: requests to an Actor are blocked until a response to the previous message can be provided; where as Clojure Agents allow multiple <code>@deref</code> calls to be made and processed:</p>

<p><a href="../images/actors-vs-agents.png">
    <img src="../images/actors-vs-agents.png">
</a></p>

<blockquote>
<p>Note: in the above image we have two simultaneous requests to &quot;increment&quot; the value held by the Actor/Agent. One can succeed, the other goes onto a queue and is applied after the first call finishes.</p>
</blockquote>

<div id="7-4"></div>

<h3>Limitations</h3>

<p>The Actor pattern does have some limitations:</p>

<ul>
<li>Languages that do not enforce immutability are more prone to thread safety bugs</li>
<li>Actors can be left starving if a dependant Actor fails (they&#39;ll be left waiting for a message that will never arrive)

<ul>
<li>This means we should program defensively and raise exceptions to the waiting Actors</li>
</ul></li>
<li>The Actors pattern does not prevent a dead/livelock scenario (two Actors waiting on each other for messages)

<ul>
<li>Again, we should program defensively by using timeouts to break a livelock</li>
</ul></li>
<li>Actors can only handle one message at a time, meaning we should be careful to not cause delays for messages that are only trying to &quot;read&quot; a value from inside the Actor</li>
<li>The Actor pattern works best when problems can be divided into sections that do not rely on each other

<ul>
<li>i.e. communication can be sporadic. If frequent interaction is needed or each section has a dependency on each other to coordinate the task then choose an alternative combination of concurrency models</li>
</ul></li>
</ul>

<div id="8"></div>

<h2>CSP</h2>

<p>Communicating Sequential Processes is an alternative mechanism for expressing concurrency, which has been popularized by recent languages <a href="http://clojure.org/">Clojure</a> and <a href="http://golang.org/">Go</a>. It also is based on the idea of message passing, similar to the Actor pattern.</p>

<p>Some of the fundamental differences between this and the Actor pattern are:</p>

<ul>
<li>Messages are sequential</li>
<li>Communication is synchronous</li>
<li>Communication happens via defined &quot;channels&quot;</li>
<li>Processes are anonymous 

<ul>
<li>i.e. Actors know who to communicate with</li>
<li>Where as Channels are pipes with messages going in and listeners the other end</li>
</ul></li>
</ul>

<p>You also have the option of applying other patterns such as multiplexing multiple channels down into one, think &quot;fan-in&quot;, which can help in certain scenarios where you want to accept lots of messages comming in (the reverse is also possible, i.e. &quot;fan-out&quot;).</p>

<p>Picking one model over another (Actor vs CSP) will be determined by the level of complexity you feel is inherently added by either solution and/or model your language of choice supports.</p>

<p>The following is an extremely simple demonstration of the CSP/channel model written in Go (there is a channel which accepts an infinite number of messages; and our <code>main</code> function will take the messages from the channel as they become available):</p>

<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;math/rand&quot;
    &quot;time&quot;
)

func main() {
    c := createChannel(&quot;hello&quot;, 5)

    for i := range c {
        fmt.Printf(&quot;You say: %q\n&quot;, i)
    }

    fmt.Println(&quot;I&#39;m done.&quot;)
}

func createChannel(msg string, size int) &lt;-chan string {
    c := make(chan string, size)

    go func() {
        for i := 1; i &lt;= size; i++ {
            c &lt;- fmt.Sprintf(&quot;%s %d&quot;, msg, i)
            time.Sleep(time.Duration(rand.Intn(1e3)) * time.Millisecond)
        }
        close(c)
    }()

    return c
}
</code></pre>

<p>Again, it&#39;s important to realise that Channels are synchronous and can block/cause deadlocks. In Go you can implement a timeout as a way of avoiding deadlocks. I&#39;m not currently sure if Clojure has a similar work-around built into the language or whether you have to manually implement that yourself.</p>

<div id="9"></div>

<h2>Threads</h2>

<p>Threads are prevalent across both the &quot;shared memory&quot; and &quot;message passing&quot; models. The discussion of how many threads to create is an important one and depends on the type of tasks your application is expected to handle: CPU bound or I/O bound. In the following sections we&#39;ll cover this topic, as well as describing an algorithm for calculating this.</p>

<div id="9-1"></div>

<h3>CPU vs I/O</h3>

<p>A CPU/Processor can contain one or more cores. For example, a quad core processor that runs at speed of 3GHz will have 4 cores running at that speed.</p>

<p>I/O, whether a file system interaction or a network request - e.g. HTTP, TCP or Socket based - can block other processes; and so if the application is designed to work concurrently (e.g. there are other threads the CPU can jump to in the mean time) then the current thread will be left to finish and another thread will be picked up instead (this is how concurrency works - the CPU interleaves between threads - this should also clarify how concurrency <em>is not</em> the same thing as paralleism).</p>

<p>For computational intensive operations you&#39;ll want the number of threads to be equal to the number of cores available.</p>

<p>For I/O intensive operations you&#39;ll want more threads than available cores. This is because (as explained above) the CPU/Processor will &quot;context switch&quot; to another thread when the current thread is blocked (hence it is better to have more threads than cores for I/O).</p>

<div id="9-2"></div>

<h3>Calculating the number of Threads</h3>

<p>To calculate how many more threads than cores you&#39;ll need for an intensive set of I/O operations, use the following algorithm: </p>

<pre><code class=" language-ini ">Number of Threads = Number of Available Cores / (1 - Blocking Coefficient)
</code></pre>

<blockquote>
<p>Note: the blocking coefficient (coefficient being a fancy word that means: a value used as a multiplier) is different depending on the operation. For a computational operation it is 0, where as a fully blocking operation it is 1.</p>
</blockquote>

<p>An example of a blocking coefficient would be: <code>0.9</code> - which means a task blocks 90% (<code>0.9</code>) of the time &amp; works only 10% (<code>0.1</code>) of the time. Meaning, if you had 2 cores then you&#39;d want 20 threads.</p>

<pre><code class=" language-ini ">2 / (1 - 0.9) = 20
</code></pre>

<div id="9-3"></div>

<h3>Even workload distribution</h3>

<p>If you have two cores and a very large queue of messages to process, then your initial thought would maybe be to split the queue (i.e. the tasks) into two. This would mean you could have two threads running (i.e. utilising both cores); the first thread processing the first queue data and the second thread handling the other half of the queue data.</p>

<p>The problem with this solution is that is doesn&#39;t necessarily guarantee even distribution of the tasks across your available cores. If our queue data consisted of a computational task such as calculating prime numbers then the first half of the queue would take a lot less time to process because the smaller prime numbers would take less time to calculate than the other queue (which if evenly split in two would mean the other queue would have the much larger prime numbers to calculate).</p>

<p>This means one core will be sitting idle while the other core is still processing data.</p>

<p>What would be better is to have more <em>parts</em> than threads/cores. So if one &quot;part&quot; finishes more quickly than expected, then another part can be picked up. Simply diving our tasks into two parts means one core will likely be sitting idle for longer than the other core. But if we divide our tasks into more granular parts, then we can aim to utilise as much of each core as possible. </p>

<div id="10"></div>

<h2>Conclusion</h2>

<p>As mentioned at the start of this post: solving the problem of thread-safe concurrency isn&#39;t necessarily as straight forward as you would have hoped (if you&#39;re new to the concepts). Throw in distributed systems and the problem is conflated even further.</p>

<p>But with that being said, we can clearly see there are quite a few different options available to us already - albeit with differing levels of complexity depending on the problem we&#39;re trying to solve. This is a good thing because you shouldn&#39;t always reach for a more complex solution if it&#39;s not necessary. If the problem is a small one and a simple mutex resolves it then maybe that&#39;s OK. Don&#39;t over engineer your system.</p>

            <hr>
            <h2>Links</h2>
            <ul>
                <li><a href="../index.html">Home</a></li>
                <li><a href="../posts/about.html">About Me</a></li>
                <li><a href="https://github.com/integralist">GitHub</a></li>
                <li><a href="https://twitter.com/integralist">Twitter</a></li>
                <li><a href="http://www.integralist.co.uk/Resume">Resume</a></li>
            </ul>
        </article>
        <script src="../scripts/prism.js"></script>
        <script>
            var _gaq=[['_setAccount','UA-33159515-1'],['_trackPageview']];
            (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
            g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
            s.parentNode.insertBefore(g,s)}(document,'script'));
        </script>
    </body>
</html>
