# Terminal Debugging Utilities

- [Introduction](#1)
- [Prerequisites](#2)
  - [TCP and HTTP](#2.1)
  - [OSI Model](#2.2)
- [Utilities](#3)
  - [top](#4): check running processes for cpu and memory utilisation
  - [ps](#5): see what processes are running
  - [strace](#6): monitor interactions between processes
  - [lsof](#7): list of open files
  - [netstat](#8): monitoring network traffic
  - [ifconfig](#9): configure or review your network interfaces
  - [iftop](#10): monitors network traffic and displays table of bandwidth usage
  - [iptraf](#11): monitoring network traffic (more visual than `netstat`, not as detailed)
  - [tcpdump](#12): network packet sniffer
  - [wireshark](#13): network packet sniffer and analyser (gui)
  - [tshark](#14): network packet sniffer and analyser
  - [telnet](#15): utility for communicating with another host
- [Conclusion](#16)

<div id="1"></div>
## Introduction

Not all programmers need to get their hands dirty and have to dig deep into what exactly their applications or services are doing at a lower/network level. 

This is why programmers work with programming languages, as they provide a nice high-level abstraction layer that protects us from a lot of these concerns.

But regardless if you're a client-side developer or a server-side developer, at some point your application will start misbehaving and it can be useful to have experience using command-line/terminal based tools to help you debug what's going on.

That is what I want to briefly cover today: a few select programs that you may find useful to have in your debugging toolbox. I won't claim to be an expert with any of these, but I've had to use these tools at some point or another so I at least know what I have available to me whenever things start going haywire.

I'd encourage you to do follow-up reading once you've gone through this post, and to experiment with these tools if there are any in particular that you find interesting.

#### Agony of Choice

You are going to find that some of the tools I mention, have a lot of crossover behaviour between them.

One of the main points of confusion for people, when given the choice of lots of different utility tools, is: when/why should I use this over another very similar tool?

The answer: it depends (as with everything in life). 

Sometimes it can just be a personal preference. You're happy using tool x, which can sort of do that 'thing' you need it to, but maybe tool x isn't quite as good at showing you the 'thing' as tool y (which was designed _specifically_ to solve the 'thing' problem); but hey, tool x is good enough at it and it also allows me to inspect y and z problems (which are things I look at the majority of the time).

Just be aware that that there will be crossover functionality, and that on occasions certain tools might only have _slight_ additions that could be useful to you depending on the problem you're trying to debug.

<div id="2"></div>
## Prerequisites

<div id="2.1"></div>
## TCP and HTTP

The fact is in order to use tools such as `tcpdump`, `telnet` or `netstat` you do need to understand the basics of how the TCP and HTTP protocols work in order to utilise these programs fully.

As far as other tools are concerned, you may need to understand some networking basics. I mean, I know very little, but I know just _enough_ to muddle along when I need to.

I'll be covering how I've used these tools but not really much more beyond that, so you may need to do some additional reading in order to appreciate what these tools offer (outside of my own experience with them).

<div id="2.2"></div>
## OSI Model

Finally, before we get going, it's worth taking a moment to consider the [OSI Model](https://en.wikipedia.org/wiki/OSI_model). What this model represents are the different layers of a system. From the very real hardware level (e.g. physical cables that make the interwebs work) right up to the software level.

Here is a table matrix that attempts to identify these 'layers':

<table class="wikitable" style="margin: 1em auto 1em auto;">
  <tbody>
    <tr>
      <th colspan="5">OSI Model</th>
    </tr>
    <tr>
      <th colspan="2">Layer</th>
      <th><a href="https://en.wikipedia.org/wiki/Protocol_data_unit" title="Protocol data unit">Protocol data unit</a> (PDU)</th>
      <th>Function</th>
      <th>Examples</th>
    </tr>
    <tr>
      <th rowspan="4">Host<br>
        layers</th>
      <td style="background:#d8ec9b;">7.&nbsp;<a href="https://en.wikipedia.org/wiki/Application_layer" title="Application layer">Application</a></td>
      <td style="background:#d8ec9c;" rowspan="3"><a href="https://en.wikipedia.org/wiki/Data_(computing)" title="Data (computing)">Data</a></td>
      <td style="background:#d8ec9c;"><small>High-level <a href="https://en.wikipedia.org/wiki/API" class="mw-redirect" title="API">APIs</a>, including resource sharing, remote file access</small></td>
      <td><a href="https://en.wikipedia.org/wiki/HTTP" class="mw-redirect" title="HTTP">HTTP</a>, <a href="https://en.wikipedia.org/wiki/Network_File_System" title="Network File System">NFS</a>, <a href="https://en.wikipedia.org/wiki/FTP" class="mw-redirect" title="FTP">FTP</a>, <a href="https://en.wikipedia.org/wiki/Telnet" title="Telnet">Telnet</a>, <a href="https://en.wikipedia.org/wiki/SMTP" class="mw-redirect" title="SMTP">SMTP</a>, <a href="https://en.wikipedia.org/wiki/Secure_Shell" title="Secure Shell">SSH</a></td>
    </tr>
    <tr>
      <td style="background:#d8ec9b;">6.&nbsp;<a href="https://en.wikipedia.org/wiki/Presentation_layer" title="Presentation layer">Presentation</a></td>
      <td style="background:#d8ec9b;"><small>Translation of data between a networking service and an application; including <a href="https://en.wikipedia.org/wiki/Character_encoding" title="Character encoding">character encoding</a>, <a href="https://en.wikipedia.org/wiki/Data_compression" title="Data compression">data compression</a> and <a href="https://en.wikipedia.org/wiki/Encryption" title="Encryption">encryption/decryption</a></small></td>
      <td><a href="https://en.wikipedia.org/wiki/S/MIME" title="S/MIME">S/MIME</a>, <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security" title="Transport Layer Security">TLS</a></td>
    </tr>
    <tr>
      <td style="background:#d8ec9b;">5. <a href="https://en.wikipedia.org/wiki/Session_layer" title="Session layer">Session</a></td>
      <td style="background:#d8ec9b;"><small>Managing communication <a href="https://en.wikipedia.org/wiki/Session_(computer_science)" title="Session (computer science)">sessions</a>, i.e. continuous exchange of information in the form of multiple back-and-forth transmissions between two nodes</small></td>
      <td><a href="https://en.wikipedia.org/wiki/Remote_Procedure_Call" class="mw-redirect" title="Remote Procedure Call">RPC</a>, <a href="https://en.wikipedia.org/wiki/DECnet" title="DECnet">SCP</a>, <a href="https://en.wikipedia.org/wiki/Password_authentication_protocol" class="mw-redirect" title="Password authentication protocol">PAP</a></td>
    </tr>
    <tr>
      <td style="background:#e7ed9c;">4. <a href="https://en.wikipedia.org/wiki/Transport_layer" title="Transport layer">Transport</a></td>
      <td style="background:#e7ed9c;"><a href="https://en.wikipedia.org/wiki/Packet_segmentation" title="Packet segmentation">Segment</a> (TCP) / <a href="https://en.wikipedia.org/wiki/Datagram" title="Datagram">Datagram</a> (UDP)</td>
      <td style="background:#e7ed9c;"><small>Reliable transmission of data segments between points on a network, including <a href="https://en.wikipedia.org/wiki/Packet_segmentation" title="Packet segmentation">segmentation</a>, <a href="https://en.wikipedia.org/wiki/Acknowledgement_(data_networks)" title="Acknowledgement (data networks)">acknowledgement</a> and <a href="https://en.wikipedia.org/wiki/Multiplexing" title="Multiplexing">multiplexing</a></small></td>
      <td><a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol" title="Transmission Control Protocol">TCP</a>, <a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol" title="User Datagram Protocol">UDP</a>, <a href="https://en.wikipedia.org/wiki/NetBIOS_Frames_protocol" title="NetBIOS Frames protocol">NBF</a></td>
    </tr>
    <tr>
      <th rowspan="3">Media<br>
        layers</th>
      <td style="background:#eddc9c;">3. <a href="https://en.wikipedia.org/wiki/Network_layer" title="Network layer">Network</a></td>
      <td style="background:#eddc9c;"><a href="https://en.wikipedia.org/wiki/Network_packet" title="Network packet">Packet</a></td>
      <td style="background:#eddc9c;"><small>Structuring and managing a multi-node network, including <a href="https://en.wikipedia.org/wiki/Address_space" title="Address space">addressing</a>, <a href="https://en.wikipedia.org/wiki/Routing" title="Routing">routing</a> and <a href="https://en.wikipedia.org/wiki/Network_traffic_control" title="Network traffic control">traffic control</a></small></td>
      <td><a href="https://en.wikipedia.org/wiki/IPv4" title="IPv4">IPv4</a>, <a href="https://en.wikipedia.org/wiki/IPv6" title="IPv6">IPv6</a>, <a href="https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol" title="Internet Control Message Protocol">ICMP</a>, <a href="https://en.wikipedia.org/wiki/IPsec" title="IPsec">IPsec</a>, <a href="https://en.wikipedia.org/wiki/Connectionless_Network_Protocol" class="mw-redirect" title="Connectionless Network Protocol">CLNP</a>, <a href="https://en.wikipedia.org/wiki/AppleTalk#Datagram_Delivery_Protocol" title="AppleTalk">DDP</a></td>
    </tr>
    <tr>
      <td style="background:#e9c189;">2. <a href="https://en.wikipedia.org/wiki/Data_link_layer" title="Data link layer">Data link</a></td>
      <td style="background:#e9c189;"><a href="https://en.wikipedia.org/wiki/Frame_(networking)" title="Frame (networking)">Frame</a></td>
      <td style="background:#e9c189;"><small>Reliable transmission of data frames between two nodes connected by a physical layer</small></td>
      <td><a href="https://en.wikipedia.org/wiki/IEEE_802.2" title="IEEE 802.2">IEEE 802.2</a>, <a href="https://en.wikipedia.org/wiki/L2TP" class="mw-redirect" title="L2TP">L2TP</a>, <a href="https://en.wikipedia.org/wiki/LLDP" class="mw-redirect" title="LLDP">LLDP</a>, <a href="https://en.wikipedia.org/wiki/Media_access_control" title="Media access control">IEEE 802 MAC layers</a> (<a href="https://en.wikipedia.org/wiki/Ethernet" title="Ethernet">Ethernet</a>, <a href="https://en.wikipedia.org/wiki/IEEE_802.11" title="IEEE 802.11">IEEE 802.11</a>, etc.), <a href="https://en.wikipedia.org/wiki/Point-to-Point_Protocol" title="Point-to-Point Protocol">PPP</a>, <a href="https://en.wikipedia.org/wiki/Asynchronous_Transfer_Mode" title="Asynchronous Transfer Mode">ATM</a>, <a href="https://en.wikipedia.org/wiki/Multiprotocol_Label_Switching" title="Multiprotocol Label Switching">MPLS</a></td>
    </tr>
    <tr>
      <td style="background:#e9988a;">1. <a href="https://en.wikipedia.org/wiki/Physical_layer" title="Physical layer">Physical</a></td>
      <td style="background:#e9988a;"><a href="https://en.wikipedia.org/wiki/Bit" title="Bit">Bit</a></td>
      <td style="background:#e9988a;"><small>Transmission and reception of raw bit streams over a physical medium</small></td>
      <td><a href="https://en.wikipedia.org/wiki/DOCSIS" title="DOCSIS">DOCSIS</a>, <a href="https://en.wikipedia.org/wiki/DSL" class="mw-redirect" title="DSL">DSL</a>, <a href="https://en.wikipedia.org/wiki/IEEE_802" title="IEEE 802">IEEE 802</a> physical layers (<a href="https://en.wikipedia.org/wiki/Ethernet_physical_layer" title="Ethernet physical layer">Ethernet</a>, <a href="https://en.wikipedia.org/wiki/IEEE_802.11" title="IEEE 802.11">IEEE 802.11</a>, etc.), <a href="https://en.wikipedia.org/wiki/ISDN" class="mw-redirect" title="ISDN">ISDN</a>, <a href="https://en.wikipedia.org/wiki/RS-232" title="RS-232">RS-232</a></td>
    </tr>
  </tbody>
</table>

<!--
<table>
    <tr>
        <th></th>
        <th>Layer</th>
        <th>Protocols</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>7.</td>
        <td>Application</td>
        <td>HTTP, FTP, SMTP</td>
        <td>Window for user app processes</td>
    </tr>
    <tr>
        <td>6.</td>
        <td>Presentation</td>
        <td>JPEG, GIF, MPEG</td>
        <td>Format the data to be presented to the Application layer (network translator)</td>
    </tr>
    <tr>
        <td>5.</td>
        <td>Session</td>
        <td>RPC, SQL, NFS</td>
        <td>Allow session establishment between processes running on different stations</td>
    </tr>
    <tr>
        <td>4.</td>
        <td>Transport</td>
        <td>TCP, UDP, SPX</td>
        <td>Flow control, ensures all messages are delivered error-free, in sequence, no losses or duplications</td>
    </tr>
    <tr>
        <td>3.</td>
        <td>Network</td>
        <td>IP, IPX, ICMP</td>
        <td>Routers control operation of subnet, deciding physical path data takes</td>
    </tr>
    <tr>
        <td>2.</td>
        <td>Data Link</td>
        <td>PPP/SLIP</td>
        <td>Provides error-free transfer of data over physical layer</td>
    </tr>
    <tr>
        <td>1.</td>
        <td>Physical</td>
        <td>Hub</td>
        <td>Physical structure (cables, hubs etc)</td>
    </tr>
</table>
-->

> Note: you'll find many differing versions of the OSI Model (i.e. the layers described are always the same, but you may see more or less protocols defined depending on what version you look at), this is just one such version copied vertabim from Wikipedia

The reason this is useful, is because you can identify which layer the relevant tools are operating at. Tools like `netstat` operate at layer four (transport: `tcp`), where as `telnet` operates at layer seven (application: it actually has its own protocol `telnet`).

When debugging an issue, if you know the problem space is a particular layer of the OSI model, then you'll have an easier time identifying which tool is best suited to the investigation.

<div id="3"></div>
##Utilities

There are _many_ different utilities, some provided as built-ins to your OS, others might be [GNU](https://www.gnu.org/home.en.html) flavoured or home grown (e.g. they can be built using a myriad of programming languages) and which you have to download separately.

The ones listed below are a selection of tools I find particularly useful for different scenarios. But they're not all available on the Mac OS (which is what I use, and which - I'm making a _massive_ assumption - you are likely using too).

I do provide basic installation instructions for some of the tools that aren't available for the Mac OS (either natively or at all) and for those tools that aren't available for _your_ OS, I would recommend using [Docker](https://www.docker.com/) for testing them out. 

I'd suggest for the purpose of this article to try one of the following if you don't want/use Mac OS:

<!--language-bash-->

    docker run -it centos /bin/bash

    # or
    
    docker run -it ubuntu /bin/bash

> Also, the usage between Mac OS and Linux can vary  
> Example: `top -n` on Mac shows only n number of items; Linux runs n number of ticks before stopping  
> If you notice something different, then it'll likely be the OS  
> But ultimately the examples I give are for Mac OS (unless stated otherwise)

With all that out of the way, let's begin...

<div id="4"></div>
## top

**Summary**: displays running processes with cpu and memory utilisation

The `top` command displays processor activity and also displays tasks managed by the kernel in real-time. If you have a cluster of nodes that are setup to scale up based on either CPU or Memory usage, then your first starting point will be to jump onto a running instance and check the different processes running and what their consumption is.

Or maybe an application on your laptop is running very slowly? You can inspect its CPU consumption to see if it's doing something odd and maxing out at 99%

<a href="../images/shell-top.jpg">
    <img src="../images/shell-top.jpg">
</a>

Here are some basic commands:

- `top -user <user>`: filter processes by those run by specified user
  > e.g. `top -user $(who | awk 'NR==1 {print $1}')`

- `top -n 10`: stops command running after 10 intervals
  > otherwise runs forever or until `<Ctrl-c>` (`SIGINT` "interrupt" signal received)

You can change which column controls the order display (the default being CPU) by typing `o` and then typing the column name. For example:

- `+command`: order by the COMMAND column (ascending order)
- `-command`: order by the COMMAND column (descending order)

> `+` is implied (so no need to type it)

The following key strokes can be executed whilst `top` is running...

- `z`: toggles on/off ability to have currently running processes highlighted

#### Non-Mac

On the non-Mac version of `top` you may find that you need the output to show you the complete path to the running program (which can be handy if you don't recognise the program, and want to know where it's located):

- `c`: toggles on/off absolute path for the COMMAND

Similarly for non-Mac versions you can dynamically change the refresh rate:

- `d`: change interval for screen/data refresh

Finally one other useful thing for non-Mac versions is the ability to kill a process you don't like the look of:

- `k`: followed by PID of process you want to kill

I mention the above non-Mac options because when debugging on a remote server, chances are you'll need some of those details more.

Failing all that you could just install the man pages and double check the available options (or run a Docker container and double check them): 

<!--language-bash-->

    apt-get update && apt-get install man

There are also some pretty fancy alternatives, such as:

- [`brew install htop`](http://hisham.hm/htop/)
- [`npm install -g vtop`](https://github.com/MrRio/vtop) (node)

<div id="5"></div>
## ps

**Summary**: displays snapshot of running processes

The `ps` command is useful for seeing 'at a glance' what process id's have been provided to different programs and which user started them (as well as the relationship between processes). 

Majority of the time you'll use `ps` just to identify the process id (`pid`) so you can then utilise another tool for inspecting the relevant process.

<a href="../images/shell-ps.jpg">
    <img src="../images/shell-ps.jpg">
</a>

The differences between `ps` and `top` are subtle, both display details about active processes (albeit in different formats). But `top` is continuous where as `ps` is just a snapshop.

The `ps` command also offers some more advanced display options, not just a table matrix, that can help visualise the parent/children for a particular process.

Here are some useful commands you can try:

- `ps aux`: shows all running processes (even those without a tty or are not owened by you)
- `ps axjf`: shows parent process (ppids) & nested children pids with formatting (works best on Linux)

> Note: the `f` option doesn't work the same on Mac OS (`man ps` for details)

<div id="6"></div>
## strace

**Summary**: monitors interactions between processes

<a href="../images/shell-strace.jpg">
    <img src="../images/shell-strace.jpg">
</a>

This utility isn't available on Mac OS, so you'll need Linux:

With Ubuntu:

<!--language-bash-->

    apt-get update && apt-get install strace

With CentOS:

<!--language-bash-->

    yum install strace

> Mac OS has `dtrace` but it uses quite different commands

So `strace` is awesome for understanding _exactly_ what your application is doing. If you have (just for example) a Python or Ruby app, then you should know that all the function calls it makes are actually abstractions provided by the language.

Most high-level languages are written in C, and so those abstracted functions will end up calling some internal C functions and those C functions will end up making OS level system calls.

It's these 'system calls' that you'll end up tracing/tracking with `strace`.

Typically you'll run `strace` against a new process, like:

<!--language-bash-->

    strace ls -l

But you can also _attach_ to an already running process! This is great for debugging an application that's misbehaving out in the wild. You would do that like so:

<!--language-bash-->

    strace -p <process_id>

So let's consider a simple example where we want to see what the shell command `ls -l` is actually doing. First let's trace it to get an idea of the output you'll see:

<!--language-bash-->

    strace ls -l

    execve("/bin/ls", ["ls", "-l"], [/* 23 vars */]) = 0
    brk(0)                                  = 0x109a000
    access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
    mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f22f946a000
    access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
    open("/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
    fstat(3, {st_mode=S_IFREG|0644, st_size=32096, ...}) = 0
    mmap(NULL, 32096, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f22f9462000
    close(3)                                = 0
    access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
    open("/lib/x86_64-linux-gnu/libselinux.so.1", O_RDONLY|O_CLOEXEC) = 3
    read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\0[\0\0\0\0\0\0"..., 832) = 832
    fstat(3, {st_mode=S_IFREG|0644, st_size=134296, ...}) = 0
    mmap(NULL, 2238192, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f22f9027000
    mprotect(0x7f22f9047000, 2093056, PROT_NONE) = 0
    mmap(0x7f22f9246000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1f000) = 0x7f22f9246000
    mmap(0x7f22f9248000, 5872, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f22f9248000
    close(3)                                = 0
    access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
    open("/lib/x86_64-linux-gnu/libacl.so.1", O_RDONLY|O_CLOEXEC) = 3
    read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0`\34\0\0\0\0\0\0"..., 832) = 832
    fstat(3, {st_mode=S_IFREG|0644, st_size=31168, ...}) = 0
    mmap(NULL, 2126336, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f22f8e1f000
    mprotect(0x7f22f8e26000, 2093056, PROT_NONE) = 0
    mmap(0x7f22f9025000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x6000) = 0x7f22f9025000
    close(3)                                = 0
    access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
    open("/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
    read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0P \2\0\0\0\0\0"..., 832) = 832
    fstat(3, {st_mode=S_IFREG|0755, st_size=1840928, ...}) = 0
    mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f22f9461000
    mmap(NULL, 3949248, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f22f8a5a000
    mprotect(0x7f22f8c14000, 2097152, PROT_NONE) = 0
    mmap(0x7f22f8e14000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1ba000) = 0x7f22f8e14000
    mmap(0x7f22f8e1a000, 17088, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f22f8e1a000
    close(3)                                = 0
    access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
    open("/lib/x86_64-linux-gnu/libpcre.so.3", O_RDONLY|O_CLOEXEC) = 3
    read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\260\27\0\0\0\0\0\0"..., 832) = 832
    fstat(3, {st_mode=S_IFREG|0644, st_size=252032, ...}) = 0
    mmap(NULL, 2347200, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f22f881c000
    mprotect(0x7f22f8859000, 2093056, PROT_NONE) = 0
    mmap(0x7f22f8a58000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x3c000) = 0x7f22f8a58000
    close(3)                                = 0
    access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
    open("/lib/x86_64-linux-gnu/libdl.so.2", O_RDONLY|O_CLOEXEC) = 3
    read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\320\16\0\0\0\0\0\0"..., 832) = 832
    fstat(3, {st_mode=S_IFREG|0644, st_size=14664, ...}) = 0
    mmap(NULL, 2109744, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f22f8618000
    mprotect(0x7f22f861b000, 2093056, PROT_NONE) = 0
    mmap(0x7f22f881a000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x2000) = 0x7f22f881a000
    close(3)                                = 0
    access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
    open("/lib/x86_64-linux-gnu/libattr.so.1", O_RDONLY|O_CLOEXEC) = 3
    read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\300\20\0\0\0\0\0\0"..., 832) = 832
    fstat(3, {st_mode=S_IFREG|0644, st_size=18624, ...}) = 0
    mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f22f9460000
    mmap(NULL, 2113760, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f22f8413000
    mprotect(0x7f22f8417000, 2093056, PROT_NONE) = 0
    mmap(0x7f22f8616000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x3000) = 0x7f22f8616000
    close(3)                                = 0
    mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f22f945f000
    mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f22f945d000
    arch_prctl(ARCH_SET_FS, 0x7f22f945d840) = 0
    mprotect(0x7f22f8e14000, 16384, PROT_READ) = 0
    mprotect(0x7f22f8616000, 4096, PROT_READ) = 0
    mprotect(0x7f22f881a000, 4096, PROT_READ) = 0
    mprotect(0x7f22f8a58000, 4096, PROT_READ) = 0
    mprotect(0x7f22f9025000, 4096, PROT_READ) = 0
    mprotect(0x7f22f9246000, 4096, PROT_READ) = 0
    mprotect(0x619000, 4096, PROT_READ)     = 0
    mprotect(0x7f22f946c000, 4096, PROT_READ) = 0
    munmap(0x7f22f9462000, 32096)           = 0
    statfs("/sys/fs/selinux", 0x7ffca795ea30) = -1 ENOENT (No such file or directory)
    statfs("/selinux", 0x7ffca795ea30)      = -1 ENOENT (No such file or directory)
    brk(0)                                  = 0x109a000
    brk(0x10bb000)                          = 0x10bb000
    open("/proc/filesystems", O_RDONLY)     = 3
    fstat(3, {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
    mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f22f9469000
    read(3, "nodev\tsysfs\nnodev\trootfs\nnodev\tr"..., 1024) = 384
    read(3, "", 1024)                       = 0
    close(3)                                = 0
    munmap(0x7f22f9469000, 4096)            = 0
    open("/usr/lib/locale/locale-archive", O_RDONLY|O_CLOEXEC) = 3
    fstat(3, {st_mode=S_IFREG|0644, st_size=1607664, ...}) = 0
    mmap(NULL, 1607664, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f22f92d4000
    close(3)                                = 0
    ioctl(1, SNDCTL_TMR_TIMEBASE or SNDRV_TIMER_IOCTL_NEXT_DEVICE or TCGETS, {B38400 opost isig icanon echo ...}) = 0
    ioctl(1, TIOCGWINSZ, {ws_row=53, ws_col=172, ws_xpixel=1895, ws_ypixel=1171}) = 0
    open("/usr/share/locale/locale.alias", O_RDONLY|O_CLOEXEC) = 3
    fstat(3, {st_mode=S_IFREG|0644, st_size=2570, ...}) = 0
    mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f22f9469000
    read(3, "# Locale name alias data base.\n#"..., 4096) = 2570
    read(3, "", 4096)                       = 0
    close(3)                                = 0
    munmap(0x7f22f9469000, 4096)            = 0
    open("/usr/share/locale/en_US.UTF-8/LC_TIME/coreutils.mo", O_RDONLY) = -1 ENOENT (No such file or directory)
    open("/usr/share/locale/en_US.utf8/LC_TIME/coreutils.mo", O_RDONLY) = -1 ENOENT (No such file or directory)
    open("/usr/share/locale/en_US/LC_TIME/coreutils.mo", O_RDONLY) = -1 ENOENT (No such file or directory)
    open("/usr/share/locale/en.UTF-8/LC_TIME/coreutils.mo", O_RDONLY) = -1 ENOENT (No such file or directory)
    open("/usr/share/locale/en.utf8/LC_TIME/coreutils.mo", O_RDONLY) = -1 ENOENT (No such file or directory)
    open("/usr/share/locale/en/LC_TIME/coreutils.mo", O_RDONLY) = -1 ENOENT (No such file or directory)
    open("/usr/share/locale-langpack/en_US.UTF-8/LC_TIME/coreutils.mo", O_RDONLY) = -1 ENOENT (No such file or directory)
    open("/usr/share/locale-langpack/en_US.utf8/LC_TIME/coreutils.mo", O_RDONLY) = -1 ENOENT (No such file or directory)
    open("/usr/share/locale-langpack/en_US/LC_TIME/coreutils.mo", O_RDONLY) = -1 ENOENT (No such file or directory)
    open("/usr/share/locale-langpack/en.UTF-8/LC_TIME/coreutils.mo", O_RDONLY) = -1 ENOENT (No such file or directory)
    open("/usr/share/locale-langpack/en.utf8/LC_TIME/coreutils.mo", O_RDONLY) = -1 ENOENT (No such file or directory)
    open("/usr/share/locale-langpack/en/LC_TIME/coreutils.mo", O_RDONLY) = -1 ENOENT (No such file or directory)
    open("/usr/lib/x86_64-linux-gnu/gconv/gconv-modules.cache", O_RDONLY) = 3
    fstat(3, {st_mode=S_IFREG|0644, st_size=26258, ...}) = 0
    mmap(NULL, 26258, PROT_READ, MAP_SHARED, 3, 0) = 0x7f22f9463000
    close(3)                                = 0
    openat(AT_FDCWD, ".", O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC) = 3
    getdents(3, /* 10 entries */, 32768)    = 296
    getdents(3, /* 0 entries */, 32768)     = 0
    close(3)                                = 0
    open("/usr/share/locale/en_US.UTF-8/LC_MESSAGES/coreutils.mo", O_RDONLY) = -1 ENOENT (No such file or directory)
    open("/usr/share/locale/en_US.utf8/LC_MESSAGES/coreutils.mo", O_RDONLY) = -1 ENOENT (No such file or directory)
    open("/usr/share/locale/en_US/LC_MESSAGES/coreutils.mo", O_RDONLY) = -1 ENOENT (No such file or directory)
    open("/usr/share/locale/en.UTF-8/LC_MESSAGES/coreutils.mo", O_RDONLY) = -1 ENOENT (No such file or directory)
    open("/usr/share/locale/en.utf8/LC_MESSAGES/coreutils.mo", O_RDONLY) = -1 ENOENT (No such file or directory)
    open("/usr/share/locale/en/LC_MESSAGES/coreutils.mo", O_RDONLY) = -1 ENOENT (No such file or directory)
    open("/usr/share/locale-langpack/en_US.UTF-8/LC_MESSAGES/coreutils.mo", O_RDONLY) = -1 ENOENT (No such file or directory)
    open("/usr/share/locale-langpack/en_US.utf8/LC_MESSAGES/coreutils.mo", O_RDONLY) = -1 ENOENT (No such file or directory)
    open("/usr/share/locale-langpack/en_US/LC_MESSAGES/coreutils.mo", O_RDONLY) = -1 ENOENT (No such file or directory)
    open("/usr/share/locale-langpack/en.UTF-8/LC_MESSAGES/coreutils.mo", O_RDONLY) = -1 ENOENT (No such file or directory)
    open("/usr/share/locale-langpack/en.utf8/LC_MESSAGES/coreutils.mo", O_RDONLY) = -1 ENOENT (No such file or directory)
    open("/usr/share/locale-langpack/en/LC_MESSAGES/coreutils.mo", O_RDONLY) = -1 ENOENT (No such file or directory)
    fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 2), ...}) = 0
    mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f22f9462000
    write(1, "total 0\n", 8total 0
    )                = 8
    close(1)                                = 0
    munmap(0x7f22f9462000, 4096)            = 0
    close(2)                                = 0
    exit_group(0)                           = ?
    +++ exited with 0 +++

OK... so that's a lot of noise. So let's see if we can't quieten it down a bit by using the count flag `-c`:

<!--language-bash-->

    strace -c ls -l

    total 0
    % time     seconds  usecs/call     calls    errors syscall
    ------ ----------- ----------- --------- --------- ----------------
      0.00    0.000000           0        10           read
      0.00    0.000000           0         1           write
      0.00    0.000000           0        35        24 open
      0.00    0.000000           0        14           close
      0.00    0.000000           0        12           fstat
      0.00    0.000000           0        25           mmap
      0.00    0.000000           0        14           mprotect
      0.00    0.000000           0         4           munmap
      0.00    0.000000           0         3           brk
      0.00    0.000000           0         2           ioctl
      0.00    0.000000           0         8         8 access
      0.00    0.000000           0         1           execve
      0.00    0.000000           0         2           getdents
      0.00    0.000000           0         2         2 statfs
      0.00    0.000000           0         1           arch_prctl
      0.00    0.000000           0         1           openat
    ------ ----------- ----------- --------- --------- ----------------
    100.00    0.000000                   135        34 total

Now _that's_ better. We can get a good overview of what's been called and how many times and the time involved. So with something like listing the files in a directory (`ls -l`) you're not going to see much in the way of 'time', so let's use `lsof` which does take a bit of time to complete:

<!--language-bash-->

    strace -c lsof

    % time     seconds  usecs/call     calls    errors syscall
    ------ ----------- ----------- --------- --------- ----------------
     66.25    0.018456           7      2479           write
      7.11    0.001980           1      1405           read
      4.44    0.001237           1      2067        12 stat
      3.77    0.001051           1      2074      1021 close
      3.61    0.001007           4       244           alarm
      3.08    0.000857           2       543           munmap
      2.18    0.000608           2       244           rt_sigaction
      2.06    0.000575         575         1           wait4
      1.72    0.000479           1       554           fstat
      1.70    0.000474           1       875        57 readlink
      1.30    0.000363           0       834        20 open
      0.84    0.000235           0       507           lstat
      0.83    0.000230           0       568           mmap
      0.60    0.000167           1       222           openat
      0.42    0.000116           8        14           recvmsg
      0.09    0.000024           0       444           getdents
      0.00    0.000000           0         2           poll
      0.00    0.000000           0        17           lseek
      0.00    0.000000           0        18           mprotect
      0.00    0.000000           0        13           brk
      0.00    0.000000           0         1           ioctl
      0.00    0.000000           0        11        11 access
      0.00    0.000000           0         2           pipe
      0.00    0.000000           0         1           getpid
      0.00    0.000000           0        14           socket
      0.00    0.000000           0         7         6 connect
      0.00    0.000000           0         8           sendto
      0.00    0.000000           0         1           recvfrom
      0.00    0.000000           0         7           setsockopt
      0.00    0.000000           0         1           clone
      0.00    0.000000           0         1           execve
      0.00    0.000000           0         5           uname
      0.00    0.000000           0         1           umask
      0.00    0.000000           0         1           getrlimit
      0.00    0.000000           0         1           getuid
      0.00    0.000000           0         1           getgid
      0.00    0.000000           0         1           geteuid
      0.00    0.000000           0         1           getegid
      0.00    0.000000           0         1           arch_prctl
    ------ ----------- ----------- --------- --------- ----------------
    100.00    0.027859                 13191      1127 total

OK _that_ output is a bit more practical. 

If you want to get a rough idea for what some of these system calls mean, then use the below quick guide (otherwise [Google is your friend](https://www.google.co.uk/search?q=close&sitesearch=man7.org/linux/man-pages)):

<table>
  <tbody>
    <tr>
      <th>Syscall</th>
      <th>What it does?</th>
    </tr>
    <tr>
      <td>
        <tt>read</tt></td>
      <td>read bytes from a file descriptor (file, socket)</td></tr>
    <tr>
      <td>
        <tt>write</tt></td>
      <td>write bytes from a file descriptor (file, socket)</td></tr>
    <tr>
      <td>
        <tt>open</tt></td>
      <td>open a file (returns a file descriptor)</td></tr>
    <tr>
      <td>
        <tt>close</tt></td>
      <td>close a file descriptor</td></tr>
    <tr>
      <td>
        <tt>fork</tt></td>
      <td>create a new process (current process is forked)</td></tr>
    <tr>
      <td>
        <tt>exec</tt></td>
      <td>execute a new program</td></tr>
    <tr>
      <td>
        <tt>connect</tt></td>
      <td>connect to a network host</td></tr>
    <tr>
      <td>
        <tt>accept</tt></td>
      <td>accept a network connection</td></tr>
    <tr>
      <td>
        <tt>stat</tt></td>
      <td>read file statistics</td></tr>
    <tr>
      <td>
        <tt>ioctl</tt></td>
      <td>set I/O properties, or other miscellaneous functions</td></tr>
    <tr>
      <td>
        <tt>mmap</tt></td>
      <td>map a file to the process memory address space</td></tr>
    <tr>
      <td>
        <tt>brk</tt></td>
      <td>extend the heap pointer</td></tr>
  </tbody>
</table>

For debugging with `strace` I'd suggest using the `-c` flag first so you get a feel for any particular system calls that stand out as being quite odd.

Maybe you notice a lot of network connections being opened and your app is showing signs of struggling with throughput. So you might then use `strace` without the `-c` so you could delve into the specific details.

If you're debugging on a remote server that's running a web app, you might attach strace to the running server process and then start manually `curl`ing endpoints to see what sort of react the server has.

Maybe you only want to look out for certain types of system calls. In that case you can utilise filters:

<!--language-bash-->

    strace -e trace=open,connect,access lsof

> Note: you can use `!` to negate the filter

You might also find that using the `-t` flag useful for tracking when the call was made:

<!--language-bash-->

    strace -t -e trace=access lsof

    19:01:00 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
    19:01:00 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
    19:01:00 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)

As you can see `strace` is a really useful tool when the time comes 

...and it _will_ come.

By the way, you should be careful with backgrounded processes. If you attach to a backgrounded process running in the same shell instance as your `strace` execution, then you'll be locked up.

> Note: although `strace` is amazing, you might want to read [this article](http://www.brendangregg.com/blog/2014-05-11/strace-wow-much-syscall.html) that discusses the oft-ignored performance overhead of using it in production

<div id="7"></div>
## lsof

**Summary**: lists open files

<a href="../images/shell-lsof.jpg">
    <img src="../images/shell-lsof.jpg">
</a>

So we actually saw this used earlier when looking at `strace`. It will display all open files, and any one who knows a bit about operating systems will realise that an open file could in fact be:

- a regular file
- a directory
- a block special file
- a character special file
- an executing text reference
- a library
- a stream or a network file (Internet socket, NFS file or UNIX domain socket)

In order to use this command, let's see some simple examples:

- `lsof -u <user>`: filter results by specific user
- `lsof -i TCP:22 -n`: lists all running processes on port 22 (ssh)
- `lsof -i 4`: display only IPv4 network files

With that last command (running on my Mac OS laptop) I see all sorts of processes such as: Slack, Chrome, Spotify etc. Lots of interesting information

So you can see that because nearly _everything_ is a file, you can do some interesting things with this very simple sounding command.

<div id="8"></div>
## netstat

**Summary**: monitors network traffic

<a href="../images/shell-netstat.jpg">
    <img src="../images/shell-netstat.jpg">
</a>

So `netstat` (network statistics) is a command-line tool that displays network connections for the Transmission Control Protocol (both incoming and outgoing), routing tables, and a number of network interface and network protocol statistics

- `netstat -a`: show both listening and non-listening sockets (for TCP this means established connections)
- `netstat -l`: show just listening sockets
- `netstat -lt`: show just tcp sockets
- `netstat -lu`: show just udp sockets
- `netstat -aep`: extend to show the user and also the pids
- `netstat -aepn`: don't translate host names (e.g. show ip instead)
- `netstat -aepT`: show host name but don't truncate it
- `netstat -ax`: show just UNIX domain sockets
- `netstat -st`: shows summary of connections (useful for identifying TCP connection issues)
- `netstat -lc <n_seconds>`: continously refreshing every n seconds
- `netstat -atepn`: nice all-rounder output (see below for example output)

<!--language-bash-->

    Active Internet connections (servers and established)
    Proto Recv-Q Send-Q Local Address               Foreign Address             State       User       Inode      PID/Program name   
    tcp        0      0 0.0.0.0:8126                0.0.0.0:*                   LISTEN      0          8934       1071/statsd         
    tcp        0      0 0.0.0.0:8080                0.0.0.0:*                   LISTEN      498        10087      1355/puma 2.14.0 (t 
    tcp        0      0 0.0.0.0:22                  0.0.0.0:*                   LISTEN      0          8763       1196/sshd           
    tcp        0      0 127.0.0.1:24220             0.0.0.0:*                   LISTEN      497        9296       1307/ruby           
    tcp        0      0 10.6.4.51:57228             10.6.31.176:6379            ESTABLISHED 498        218757     1355/puma 2.14.0 (t 
    tcp        0      0 10.6.4.51:57224             10.6.31.176:6379            ESTABLISHED 498        218743     1355/puma 2.14.0 (t 
    tcp        0      0 10.6.4.51:8080              10.6.8.80:48205             ESTABLISHED 498        229190     1355/puma 2.14.0 (t 
    tcp        0      0 10.6.4.51:57231             10.6.31.176:6379            ESTABLISHED 498        218766     1355/puma 2.14.0 (t 
    tcp        0      0 10.6.4.51:57225             10.6.31.176:6379            ESTABLISHED 498        218747     1355/puma 2.14.0 (t 
    tcp        0      0 10.6.4.51:8080              10.6.6.76:51764             ESTABLISHED 498        10111      1355/puma 2.14.0 (t 
    tcp       53      0 10.6.4.51:56870             54.231.142.40:443           ESTABLISHED 497        229141     1307/ruby           
    tcp        1      0 127.0.0.1:34704             127.0.0.1:8080              CLOSE_WAIT  48         226010     20286/httpd

- `netstat -r`: shows routing table (see below for example output)

<!--language-bash-->

    Kernel IP routing table
    Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
    10.6.0.0        *               255.255.248.0   U         0 0          0 eth0
    link-local      *               255.255.0.0     U         0 0          0 eth0
    default         ip-xx-x-x-x.eu- 0.0.0.0         UG        0 0          0 eth0

Effectively, if you've any kind of network issues, then this tool can help you potentially identify where it's coming from or going (or if it's not coming from or going to the expected source/destination).

<div id="9"></div>
## ifconfig

**Summary**: configure or review your network interfaces

<a href="../images/shell-ifconfig.jpg">
    <img src="../images/shell-ifconfig.jpg">
</a>

So the `ifconfig` command is used to configure or review your network interfaces. For a breakdown of the following ouput I refer you to: http://www.aboutlinux.info/2006/11/ifconfig-dissected-and-demystified.html

If you don't want to configure a network interface then running the command without any arguments will display all existing network interfaces:

<!--language-bash-->

    eth0      Link encap:Ethernet  HWaddr 0A:05:1E:A5:6F:FF  
              inet addr:10.6.4.51  Bcast:10.6.7.255  Mask:255.255.248.0
              inet6 addr: fe80::805:1eff:fea5:6fff/64 Scope:Link
              UP BROADCAST RUNNING MULTICAST  MTU:9001  Metric:1
              RX packets:8776319 errors:0 dropped:0 overruns:0 frame:0
              TX packets:4212889 errors:0 dropped:0 overruns:0 carrier:0
              collisions:0 txqueuelen:1000 
              RX bytes:10239965628 (9.5 GiB)  TX bytes:10967533931 (10.2 GiB)
              Interrupt:155 

    lo        Link encap:Local Loopback  
              inet addr:127.0.0.1  Mask:255.0.0.0
              inet6 addr: ::1/128 Scope:Host
              UP LOOPBACK RUNNING  MTU:65536  Metric:1
              RX packets:341240 errors:0 dropped:0 overruns:0 frame:0
              TX packets:341240 errors:0 dropped:0 overruns:0 carrier:0
              collisions:0 txqueuelen:0 
              RX bytes:31612016 (30.1 MiB)  TX bytes:31612016 (30.1 MiB)

We can see above that we have a single Ethernet card (`eth0`) and a loop back interface (`lo`)

> In newer Linux OS' `eth<n>` is replaced by `p2p<n>`  
> And on the Mac OS it becomes `en<n>`

For more information on Network ips and how they're created (i.e. CIDRs), then you might be interested in [this quick gist](https://gist.github.com/Integralist/cff468ba808fbca09602) (but it's only basic information, so you might have better luck with your own Googling)

<div id="10"></div>
## iftop

**Summary**: monitors network traffic and displays table of bandwidth usage

<a href="../images/shell-iftop.jpg">
    <img src="../images/shell-iftop.jpg">
</a>

The `iftop` command is useful for identifying things like "why is our connection so slow?". It's equivalent to a tool like `top` when understanding CPU usage. 

The command listens to network traffic on a named interface and displays a table of current bandwidth usage by pairs of hosts.

This utility isn't available by default on any OS, so with Mac OS:

<!--language-bash-->

    brew install iftop

With Ubuntu:

<!--language-bash-->

    apt-get update && apt-get install iftop

With CentOS:

<!--language-bash-->

    yum install wget libpcap -y
    wget http://pkgs.repoforge.org/iftop/iftop-0.17-1.el6.rf.x86_64.rpm
    rpm -ivh iftop-0.17-1.el6.rf.x86_64.rpm

Below is a simple command to get you started:

<!--language-bash-->

    sudo iftop -P -i en1
    
> Note: use `ifconfig` to find the interface you're interested in

I personally find the standard output useful (as per image above), but if you press `?` while the command is running you'll see lots of additional options you can try:

<!--language-bash-->

    Host display:                          General:
     n - toggle DNS host resolution         P - pause display
     s - toggle show source host            h - toggle this help display
     d - toggle show destination host       b - toggle bar graph display
     t - cycle line display mode            B - cycle bar graph average
                                            T - toggle cumulative line totals
    Port display:                           j/k - scroll display
     N - toggle service resolution          f - edit filter code
     S - toggle show source port            l - set screen filter
     D - toggle show destination port       L - lin/log scales
     p - toggle port display                ! - shell command
                                            q - quit
    Sorting:
     1/2/3 - sort by 1st/2nd/3rd column
     < - sort by source name
     > - sort by dest name
     o - freeze current order


<div id="11"></div>
## iptraf

**Summary**: monitors network traffic (more visual than `netstat`, but not as detailed)

<a href="../images/shell-iptraf.jpg">
    <img src="../images/shell-iptraf.jpg">
</a>

This utility isn't available on Mac OS, so you'll need Linux:

With Ubuntu:

<!--language-bash-->

    apt-get update && apt-get install iptraf

With CentOS:

<!--language-bash-->

    yum install iptraf

Because `iptraf` requires a lot of user interaction to get into different sections of the tool, I'll have to just leave it up to you to explore.

You'll see options like `IP traffic monitor`, which can be useful viewing. But personally I don't find `iptraf` as useful as tools such as `iftop`. But it's here for you nonetheless.

<div id="12"></div>
## tcpdump

**Summary**: network packet sniffer

<a href="../images/shell-tcpdump.jpg">
    <img src="../images/shell-tcpdump.jpg">
</a>

...

need sudo for listening on interfaces

<div id="13"></div>
## wireshark

**Summary**: network packet sniffer and analyser (gui)

<a href="../images/shell-wireshark.jpg">
    <img src="../images/shell-wireshark.jpg">
</a>

...

create pcaps with tcpdump and analyse with tshark

<div id="14"></div>
## tshark

**Summary**: network packet sniffer and analyser (cli version of wireshark)

<a href="../images/shell-tshark.jpg">
    <img src="../images/shell-tshark.jpg">
</a>

...

need sudo for listening on interfaces

<div id="15"></div>
## telnet

**Summary**: utility for communicating with another host

<a href="../images/shell-telnet.jpg">
    <img src="../images/shell-telnet.jpg">
</a>

...

<div id="16"></div>
## Conclusion

...
