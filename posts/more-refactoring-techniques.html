<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, minimal-ui">
        <title>Even More Refactoring Techniques</title>
        <link rel="stylesheet" href="../styles/github-markdown.css">
        <style>
            body {
                min-width: 200px;
                max-width: 790px;
                margin: 0 auto;
                padding: 30px;
            }
        </style>
    </head>
    <body>
        <article class="markdown-body">

<h1>Even More Refactoring Techniques</h1>

<ul>
<li>Introduction

<ul>
<li><a href="#remove-redundancy">Remove Redundancy</a></li>
<li><a href="#dynamic-method-definition">Dynamic Method Definition</a></li>
<li><a href="#extract-class">Extract Class</a></li>
<li><a href="#hide-delegate">Hide Delegate</a></li>
<li><a href="#replace-array-with-object">Replace Array with Object</a></li>
<li><a href="#replace-conditional-with-polymorphism">Replace Conditional with Polymorphism</a></li>
<li><a href="#decompose-conditional">Decompose Conditional</a></li>
<li><a href="#introduce-null-object">Introduce Null Object</a></li>
</ul></li>
<li>Conclusion</li>
</ul>

<h2>Introduction</h2>

<p>Well here we are again to learn some more refactoring techniques. If you want to recap the other techniques then go <a href="/posts/refactoring-techniques/">read my previous post</a>, otherwise let&#39;s just crack on...</p>

<h3>Remove Redundancy</h3>

<p>This isn&#39;t an explicit technique, more a grouping of techniques.</p>

<p>The principle idea being that: code evolves, and as it evolves you may find techniques you previously implemented (as part of an earlier refactoring) have since become redundant. </p>

<p>Imagine you implemented the &quot;<a href="/posts/refactoring-techniques/#introduce-named-parameter">Introduce Named Parameter</a>&quot; technique (passing a hash with named properties as a single argument instead of multiple unidentified arguments). </p>

<p>Now, after some other refactorings have taken place, you discover the method originally refactored is no longer as complex and so your argument hash refactor has been reduced down to just a single named property. </p>

<p>In this particular scenario you should remove the named parameter and simply pass a single argument instead.</p>

<p>This principle applies with other refactoring techniques. </p>

<p>Imagine an earlier refactoring included implementing a default parameter value for a method call. As your code evolves, if you discover you now only ever call the method <em>with</em> an argument then the default value becomes redundant and makes the code more complex than it needs to be by providing a default value. So just remove the redundant code.</p>

<h3>Dynamic Method Definition</h3>

<p>Sometimes defining multiple methods can be wasteful when functionally they carry out similar steps. </p>

<p>For example, imagine we had the following code... </p>

<p>```ruby 
def failure do 
  self.result = &quot;failure&quot; 
end </p>

<p>def success do 
  self.result = &quot;success&quot; 
end </p>

<p>def error do 
  self.result = &quot;error&quot; 
end 
``` </p>

<p>Notice how the functions are structurally identical. They simply set a <code>result</code> property to have a value
This can be refactored using Ruby&#39;s <code>define_method</code> method (which let&#39;s you create methods dynamically at run time)... </p>

<p><code>ruby 
[:failure, :success, :error].each do |method| 
  define_method method do 
    self.result = method.to_s 
  end 
end 
</code> </p>

<p>Note: you could also abstract this code into a more reusable (and easier to maintain) function like so... </p>

<p><code>ruby 
def dynamic_methods(*method_names, &amp;block) 
  method_names.each do |method_name| 
    define_method method_name do 
      instance_exec(method_name, &amp;block)
    end 
  end 
end 
</code> </p>

<p>You can also use this technique to help ease creating properties on an object. For example, I used this technique in my <a href="/posts/mvcp-model-view-controller-presenter/">MVCP</a> blog post to dynamically create instance variables... </p>

<p>```ruby 
require &#39;app/presenters/base&#39; 
require &#39;app/models/person&#39; </p>

<p>class Presenters::Person &lt; Presenters::Base 
  attr_reader :run, :name, :age </p>

<p>def initialize 
    @run = true </p>

<pre><code>model = Person.new(&#39;Mark&#39;, &#39;99&#39;) 
prepare_view_data({ :name =&gt; model.name, :age =&gt; model.age }) 
</code></pre>

<p>end 
end </p>

<p>module Presenters 
  class Base 
    attr_accessor :model </p>

<pre><code>def prepare_view_data hash 
  hash.each do |name, value| 
    instance_variable_set(&quot;@#{name}&quot;, value) 
  end 
end 
</code></pre>

<p>end 
end 
``` </p>

<h3>Extract Class</h3>

<p>This is a pretty standard technique which helps ensure your objects abide by the SRP (Single Responsibility Principle). </p>

<p>If you find your classes are doing too much then simply create a new class and move the relevant fields and methods over one by one (while running the tests as you go to ensure all code continues working as expected).</p>

<p>Doing so you&#39;ll end up with two small, focused and clean classes which are easier to manage. </p>

<h3>Hide Delegate</h3>

<p>This technique focuses on the principle of object encapsulation. Specifically decoupling two or more objects by reducing the context the objects have of each other. </p>

<p>The following code demonstrates the idea...</p>

<p>```ruby
module Bar
  def display
    puts &quot;Bar Stuff&quot;
  end
end</p>

<p>module Baz
  def display
    puts &quot;Baz Stuff&quot;
  end
end</p>

<p>class Foo
  include Bar</p>

<p>def do_something
    display
  end
end</p>

<p>foo = Foo.new
foo.do_something
```</p>

<p>...as you can see, the user only needs to rely on the interface having a <code>do_something</code> method. </p>

<p>The implementation details of <code>do_somthing</code> (in this case the delegation off to another method) are hidden.</p>

<p>If we changed <code>include Bar</code> for <code>include Baz</code>, or maybe we don&#39;t mixin a module at all and just write some code inside of <code>do_something</code>, it doesn&#39;t matter because the public interface is set as far as the user is concerned.</p>

<h3>Replace Array with Object</h3>

<p>The motivation for this technique is to convert a simple data container which holds multiple data types into an object with clear and descriptive identifiers. </p>

<p>This principle helps to present your complex data into a more sensible format (I demonstrated this in a previous post on <a href="/posts/object-oriented-design-ood/#direct-references">object-oriented design</a>). This technique also makes the data interaction more maintainable by providing an easier and understandable interface to the data. </p>

<p>Here is an example where we&#39;re violating the principle of a clean data interaction...</p>

<p>```ruby 
class Foo 
  attr_reader :data </p>

<p>def initialize(data) 
    @data = data 
  end </p>

<p>def do_something 
    data.each do |item| 
      puts item[0] 
      puts item[1] 
      puts &#39;---&#39; 
    end 
  end 
end </p>

<p>obj = Foo.new([[10, 25],[3, 9],[41, 7]]) 
obj.do_something 
``` </p>

<p>Notice in the first example how our code has far too much knowledge (context) about the object it&#39;s interacting with. It knows that the Array index zero holds an X coordinate and the Array index one holds a Y coordinate. </p>

<p>If that format was to change (let&#39;s say the X and Y swap places) then that would cause our code to break in unexpected ways.</p>

<p>But now take a look at the following example which works around this issue by converting our complex data structure into a cleaner data format... </p>

<p>```ruby 
class Foo 
  attr<em>reader :new</em>data </p>

<p>def initialize(data) 
    @new_data = transform(data) 
  end </p>

<p>def do<em>something 
    new</em>data.each do |item| 
      # now we are able to reference easily understandable 
      # property names (rather than item[0], item[1]) 
      puts item.coord<em>x 
      puts item.coord</em>y 
      puts &#39;---&#39; 
    end 
  end </p>

<p>Transform = Struct.new(:coord<em>x, :coord</em>y) </p>

<p>def transform(data) 
    data.collect { |item| Transform.new(item[0], item[1]) } 
  end 
end </p>

<p>obj = Foo.new([[10, 25],[3, 9],[41, 7]]) 
obj.do_something 
``` </p>

<p>...here we convert the Array into an object and instead can more easily and safely reference the data we&#39;re interested in via recognisable property identifiers. This doesn&#39;t mean if the data source changes that we&#39;ll totally avoid all problems but it&#39;ll be clearer where the problem is arising.</p>

<h3>Replace Conditional with Polymorphism</h3>

<p>This is one of the most useful refactoring techniques available to you, and there are two ways it can help: </p>

<ol>
<li>It removes the code smell of conditional logic </li>
<li>It demonstrates perfectly the principle of object-oriented design </li>
</ol>

<p>The following example shows the typical procedural attempt to handle different scenarios based on the data object type being passed...</p>

<p>```ruby
class Foo
  def initialize(data)
    @data = data
  end</p>

<p>def do_something
    if @data.class == Bar
      puts &quot;Bar!&quot;
    elsif @data.class == Baz
      puts &quot;Baz!&quot;
    elsif @data.class == Qux
      puts &quot;Qux!&quot;
    end
  end
end</p>

<p>class Bar; end
class Baz; end
class Qux; end</p>

<p>foo<em>bar = Foo.new(Bar.new)
foo</em>bar.do_something</p>

<p>foo<em>baz = Foo.new(Baz.new)
foo</em>baz.do_something</p>

<p>foo<em>qux = Foo.new(Qux.new)
foo</em>qux.do_something
```</p>

<p>...as you can see, if we have a new Class type we need to go back and to modify the <code>Foo</code> base class. This violates the OCP (Open/Closed Principle) which states a file should be open for extension but closed for modification.</p>

<p>For us to abide by OCP we can use polymorphism and a trusted interface/duck typing to solve the problem...</p>

<p>```ruby
class Foo
  def initialize(data)
    @data = data
  end</p>

<p>def do_something
    @data.identifier
  end
end</p>

<p>class Bar
  def identifier
    puts &quot;#{self.class}!&quot;
  end
end</p>

<p>class Baz
  def identifier
    puts &quot;#{self.class}!&quot;
  end
end</p>

<p>class Qux
  def identifier
    puts &quot;#{self.class}!&quot;
  end
end</p>

<p>foo<em>bar = Foo.new(Bar.new)
foo</em>bar.do_something</p>

<p>foo<em>baz = Foo.new(Baz.new)
foo</em>baz.do_something</p>

<p>foo<em>qux = Foo.new(Qux.new)
foo</em>qux.do_something
```</p>

<p>Notice we have removed the need for a conditional and just sent the message to the relevant object to be handled. Much cleaner and easier to maintain and scale.</p>

<h3>Decompose Conditional</h3>

<p>Not all conditional statements can be avoided through the use of polymorphism. In those cases you can simplify the conditional logic (and the subsequent statements) by <a href="/posts/refactoring-techniques/#extract-method">extracting them into external methods</a>. </p>

<p>Here is a simple example...</p>

<p><code>ruby 
if date &lt; SUMMER_START || date &gt; SUMMER_END 
  charge = # some complex calculation if it&#39;s winter 
else 
  charge = # some other complex calculation if it&#39;s summer 
end 
</code> </p>

<p>...which we can refactor like so... </p>

<p><code>ruby 
if not_summer(date) 
  charge = winter_charge 
else 
  charge = summer_charge 
end 
</code></p>

<p>...much better.</p>

<h3>Introduce Null Object</h3>

<p>The motivation behind this technique is to avoid using a conditional whose purpose is to check whether a property exists or not before using it.</p>

<p>Here is a simple example of what we want to avoid...</p>

<p>```ruby
class Post
  attr_reader :id</p>

<p>def initialize id
    @id        = id
    @published = false
  end</p>

<p>def self.find<em>and</em>publish id
    # Simulated database operation
    post = Posts.find { |post| post.id == id }
    post.publish unless post.nil?
  end</p>

<p>def publish
    puts @published = true
  end
end</p>

<p>Posts = [Post.new(1), Post.new(2)]</p>

<p>Post.find<em>and</em>publish(0) # displays nothing
Post.find<em>and</em>publish(1) # displays true
```</p>

<p>...in the above example we check whether <code>post</code> is <code>nil</code> or not. If it isn&#39;t <code>nil</code> then we call the <code>publish</code> method, otherwise we don&#39;t do anything.</p>

<p>This is kind of ugly.</p>

<p>The following code demonstrates how we can avoid that problem by introducing the concept of having an object to handle null scenarios (it&#39;s the same principle of using duck typing/trusted interfaces/polymorphism)...</p>

<p>```ruby
class Post
  attr_reader :id</p>

<p>def initialize id
    @id        = id
    @published = false
  end</p>

<p>def self.find<em>and</em>publish id
    # Simulated database operation
    post = Posts.find { |post| post.id == id } || NullPost.new
    post.publish
  end</p>

<p>def publish
    puts @published = true
  end
end</p>

<p>class NullPost
  def publish
    # noop
  end
end</p>

<p>Posts = [Post.new(1), Post.new(2)]</p>

<p>Post.find<em>and</em>publish(0) # displays nothing
Post.find<em>and</em>publish(1) # displays true
```</p>

<p>...as you can see, effectively we have the same code with the exception that we no longer check for <code>nil?</code> in the second example and instead we rely on another object <code>NullPost</code> implementing the same interface but returns a null related value.</p>

<p>This way we&#39;re using objects to handle our logic. Yes, we end up with more code (one extra Class) but ultimately this is more maintainable and understandable than lots of inline logic.</p>

<h2>Conclusion</h2>

<p>Again, there are still many different refactoring techniques that I&#39;ve not included. But hopefully you&#39;ve found this second instalment just as useful as the first, I&#39;ll update the post or start anew with more techniques soon.</p>

            <hr>
            <h2>Links</h2>
            <ul>
                <li><a href="../index.html">Home</a></li>
                <li><a href="../posts/about.html">About Me</a></li>
                <li><a href="https://github.com/integralist">GitHub</a></li>
                <li><a href="https://twitter.com/integralist">Twitter</a></li>
                <li><a href="http://www.integralist.co.uk/Resume">Resume</a></li>
            </ul>
        </article>
        <script>
            var _gaq=[['_setAccount','UA-33159515-1'],['_trackPageview']];
            (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
            g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
            s.parentNode.insertBefore(g,s)}(document,'script'));
        </script>
    </body>
</html>
